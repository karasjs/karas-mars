/*!
 * Name: @galacean/mars-player
 * Description: Mars runtime player for the web
 * Author: Ant Group CO., Ltd.
 * Contributors: 燃然,飂兮,十弦,云垣,茂安,意绮
 * Version: v2.1.0-beta.0
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global$u =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || commonjsGlobal || Function('return this')();

var objectGetOwnPropertyDescriptor = {};

var fails$t = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

var fails$s = fails$t;

// Detect IE8's incomplete defineProperty implementation
var descriptors = !fails$s(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});

var fails$r = fails$t;

var functionBindNative = !fails$r(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});

var NATIVE_BIND$3 = functionBindNative;

var call$m = Function.prototype.call;

var functionCall = NATIVE_BIND$3 ? call$m.bind(call$m) : function () {
  return call$m.apply(call$m, arguments);
};

var objectPropertyIsEnumerable = {};

var $propertyIsEnumerable$1 = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable$1.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$2(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable$1;

var createPropertyDescriptor$5 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var NATIVE_BIND$2 = functionBindNative;

var FunctionPrototype$2 = Function.prototype;
var call$l = FunctionPrototype$2.call;
var uncurryThisWithBind = NATIVE_BIND$2 && FunctionPrototype$2.bind.bind(call$l, call$l);

var functionUncurryThis = NATIVE_BIND$2 ? uncurryThisWithBind : function (fn) {
  return function () {
    return call$l.apply(fn, arguments);
  };
};

var uncurryThis$x = functionUncurryThis;

var toString$5 = uncurryThis$x({}.toString);
var stringSlice$2 = uncurryThis$x(''.slice);

var classofRaw$2 = function (it) {
  return stringSlice$2(toString$5(it), 8, -1);
};

var uncurryThis$w = functionUncurryThis;
var fails$q = fails$t;
var classof$d = classofRaw$2;

var $Object$4 = Object;
var split = uncurryThis$w(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject = fails$q(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object$4('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof$d(it) == 'String' ? split(it, '') : $Object$4(it);
} : $Object$4;

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
var isNullOrUndefined$7 = function (it) {
  return it === null || it === undefined;
};

var isNullOrUndefined$6 = isNullOrUndefined$7;

var $TypeError$g = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible$3 = function (it) {
  if (isNullOrUndefined$6(it)) throw $TypeError$g("Can't call method on " + it);
  return it;
};

// toObject with fallback for non-array-like ES3 strings
var IndexedObject$4 = indexedObject;
var requireObjectCoercible$2 = requireObjectCoercible$3;

var toIndexedObject$9 = function (it) {
  return IndexedObject$4(requireObjectCoercible$2(it));
};

var documentAll$2 = typeof document == 'object' && document.all;

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var IS_HTMLDDA = typeof documentAll$2 == 'undefined' && documentAll$2 !== undefined;

var documentAll_1 = {
  all: documentAll$2,
  IS_HTMLDDA: IS_HTMLDDA
};

var $documentAll$1 = documentAll_1;

var documentAll$1 = $documentAll$1.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
var isCallable$o = $documentAll$1.IS_HTMLDDA ? function (argument) {
  return typeof argument == 'function' || argument === documentAll$1;
} : function (argument) {
  return typeof argument == 'function';
};

var isCallable$n = isCallable$o;
var $documentAll = documentAll_1;

var documentAll = $documentAll.all;

var isObject$i = $documentAll.IS_HTMLDDA ? function (it) {
  return typeof it == 'object' ? it !== null : isCallable$n(it) || it === documentAll;
} : function (it) {
  return typeof it == 'object' ? it !== null : isCallable$n(it);
};

var global$t = global$u;
var isCallable$m = isCallable$o;

var aFunction = function (argument) {
  return isCallable$m(argument) ? argument : undefined;
};

var getBuiltIn$c = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global$t[namespace]) : global$t[namespace] && global$t[namespace][method];
};

var uncurryThis$v = functionUncurryThis;

var objectIsPrototypeOf = uncurryThis$v({}.isPrototypeOf);

var engineUserAgent = typeof navigator != 'undefined' && String(navigator.userAgent) || '';

var global$s = global$u;
var userAgent$5 = engineUserAgent;

var process$4 = global$s.process;
var Deno$1 = global$s.Deno;
var versions = process$4 && process$4.versions || Deno$1 && Deno$1.version;
var v8 = versions && versions.v8;
var match, version$1;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version$1 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version$1 && userAgent$5) {
  match = userAgent$5.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent$5.match(/Chrome\/(\d+)/);
    if (match) version$1 = +match[1];
  }
}

var engineV8Version = version$1;

/* eslint-disable es/no-symbol -- required for testing */

var V8_VERSION$1 = engineV8Version;
var fails$p = fails$t;
var global$r = global$u;

var $String$5 = global$r.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$p(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String$5(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;
});

/* eslint-disable es/no-symbol -- required for testing */

var NATIVE_SYMBOL$1 = symbolConstructorDetection;

var useSymbolAsUid = NATIVE_SYMBOL$1
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';

var getBuiltIn$b = getBuiltIn$c;
var isCallable$l = isCallable$o;
var isPrototypeOf$4 = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;

var $Object$3 = Object;

var isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn$b('Symbol');
  return isCallable$l($Symbol) && isPrototypeOf$4($Symbol.prototype, $Object$3(it));
};

var $String$4 = String;

var tryToString$6 = function (argument) {
  try {
    return $String$4(argument);
  } catch (error) {
    return 'Object';
  }
};

var isCallable$k = isCallable$o;
var tryToString$5 = tryToString$6;

var $TypeError$f = TypeError;

// `Assert: IsCallable(argument) is true`
var aCallable$d = function (argument) {
  if (isCallable$k(argument)) return argument;
  throw $TypeError$f(tryToString$5(argument) + ' is not a function');
};

var aCallable$c = aCallable$d;
var isNullOrUndefined$5 = isNullOrUndefined$7;

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
var getMethod$7 = function (V, P) {
  var func = V[P];
  return isNullOrUndefined$5(func) ? undefined : aCallable$c(func);
};

var call$k = functionCall;
var isCallable$j = isCallable$o;
var isObject$h = isObject$i;

var $TypeError$e = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
var ordinaryToPrimitive$1 = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable$j(fn = input.toString) && !isObject$h(val = call$k(fn, input))) return val;
  if (isCallable$j(fn = input.valueOf) && !isObject$h(val = call$k(fn, input))) return val;
  if (pref !== 'string' && isCallable$j(fn = input.toString) && !isObject$h(val = call$k(fn, input))) return val;
  throw $TypeError$e("Can't convert object to primitive value");
};

var shared$4 = {exports: {}};

var global$q = global$u;

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty$6 = Object.defineProperty;

var defineGlobalProperty$3 = function (key, value) {
  try {
    defineProperty$6(global$q, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global$q[key] = value;
  } return value;
};

var global$p = global$u;
var defineGlobalProperty$2 = defineGlobalProperty$3;

var SHARED = '__core-js_shared__';
var store$3 = global$p[SHARED] || defineGlobalProperty$2(SHARED, {});

var sharedStore = store$3;

var store$2 = sharedStore;

(shared$4.exports = function (key, value) {
  return store$2[key] || (store$2[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.31.1',
  mode: 'global',
  copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});

var requireObjectCoercible$1 = requireObjectCoercible$3;

var $Object$2 = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
var toObject$b = function (argument) {
  return $Object$2(requireObjectCoercible$1(argument));
};

var uncurryThis$u = functionUncurryThis;
var toObject$a = toObject$b;

var hasOwnProperty = uncurryThis$u({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject$a(it), key);
};

var uncurryThis$t = functionUncurryThis;

var id$1 = 0;
var postfix = Math.random();
var toString$4 = uncurryThis$t(1.0.toString);

var uid$4 = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$4(++id$1 + postfix, 36);
};

var global$o = global$u;
var shared$3 = shared$4.exports;
var hasOwn$c = hasOwnProperty_1;
var uid$3 = uid$4;
var NATIVE_SYMBOL = symbolConstructorDetection;
var USE_SYMBOL_AS_UID = useSymbolAsUid;

var Symbol$1 = global$o.Symbol;
var WellKnownSymbolsStore = shared$3('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1['for'] || Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$3;

var wellKnownSymbol$j = function (name) {
  if (!hasOwn$c(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$c(Symbol$1, name)
      ? Symbol$1[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};

var call$j = functionCall;
var isObject$g = isObject$i;
var isSymbol$2 = isSymbol$3;
var getMethod$6 = getMethod$7;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$i = wellKnownSymbol$j;

var $TypeError$d = TypeError;
var TO_PRIMITIVE = wellKnownSymbol$i('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
var toPrimitive$2 = function (input, pref) {
  if (!isObject$g(input) || isSymbol$2(input)) return input;
  var exoticToPrim = getMethod$6(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call$j(exoticToPrim, input, pref);
    if (!isObject$g(result) || isSymbol$2(result)) return result;
    throw $TypeError$d("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};

var toPrimitive$1 = toPrimitive$2;
var isSymbol$1 = isSymbol$3;

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
var toPropertyKey$5 = function (argument) {
  var key = toPrimitive$1(argument, 'string');
  return isSymbol$1(key) ? key : key + '';
};

var global$n = global$u;
var isObject$f = isObject$i;

var document$3 = global$n.document;
// typeof document.createElement is 'object' in old IE
var EXISTS$1 = isObject$f(document$3) && isObject$f(document$3.createElement);

var documentCreateElement$1 = function (it) {
  return EXISTS$1 ? document$3.createElement(it) : {};
};

var DESCRIPTORS$e = descriptors;
var fails$o = fails$t;
var createElement$1 = documentCreateElement$1;

// Thanks to IE8 for its funny defineProperty
var ie8DomDefine = !DESCRIPTORS$e && !fails$o(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement$1('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});

var DESCRIPTORS$d = descriptors;
var call$i = functionCall;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var createPropertyDescriptor$4 = createPropertyDescriptor$5;
var toIndexedObject$8 = toIndexedObject$9;
var toPropertyKey$4 = toPropertyKey$5;
var hasOwn$b = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$d ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$8(O);
  P = toPropertyKey$4(P);
  if (IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$1(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn$b(O, P)) return createPropertyDescriptor$4(!call$i(propertyIsEnumerableModule.f, O, P), O[P]);
};

var objectDefineProperty = {};

var DESCRIPTORS$c = descriptors;
var fails$n = fails$t;

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
var v8PrototypeDefineBug = DESCRIPTORS$c && fails$n(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});

var isObject$e = isObject$i;

var $String$3 = String;
var $TypeError$c = TypeError;

// `Assert: Type(argument) is Object`
var anObject$d = function (argument) {
  if (isObject$e(argument)) return argument;
  throw $TypeError$c($String$3(argument) + ' is not an object');
};

var DESCRIPTORS$b = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$c = anObject$d;
var toPropertyKey$3 = toPropertyKey$5;

var $TypeError$b = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE$1 = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
objectDefineProperty.f = DESCRIPTORS$b ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$c(O);
  P = toPropertyKey$3(P);
  anObject$c(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject$c(O);
  P = toPropertyKey$3(P);
  anObject$c(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$b('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var DESCRIPTORS$a = descriptors;
var definePropertyModule$5 = objectDefineProperty;
var createPropertyDescriptor$3 = createPropertyDescriptor$5;

var createNonEnumerableProperty$6 = DESCRIPTORS$a ? function (object, key, value) {
  return definePropertyModule$5.f(object, key, createPropertyDescriptor$3(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var makeBuiltIn$3 = {exports: {}};

var DESCRIPTORS$9 = descriptors;
var hasOwn$a = hasOwnProperty_1;

var FunctionPrototype$1 = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS$9 && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn$a(FunctionPrototype$1, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$9 || (DESCRIPTORS$9 && getDescriptor(FunctionPrototype$1, 'name').configurable));

var functionName = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};

var uncurryThis$s = functionUncurryThis;
var isCallable$i = isCallable$o;
var store$1 = sharedStore;

var functionToString = uncurryThis$s(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable$i(store$1.inspectSource)) {
  store$1.inspectSource = function (it) {
    return functionToString(it);
  };
}

var inspectSource$3 = store$1.inspectSource;

var global$m = global$u;
var isCallable$h = isCallable$o;

var WeakMap$2 = global$m.WeakMap;

var weakMapBasicDetection = isCallable$h(WeakMap$2) && /native code/.test(String(WeakMap$2));

var shared$2 = shared$4.exports;
var uid$2 = uid$4;

var keys$1 = shared$2('keys');

var sharedKey$3 = function (key) {
  return keys$1[key] || (keys$1[key] = uid$2(key));
};

var hiddenKeys$5 = {};

var NATIVE_WEAK_MAP = weakMapBasicDetection;
var global$l = global$u;
var isObject$d = isObject$i;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
var hasOwn$9 = hasOwnProperty_1;
var shared$1 = sharedStore;
var sharedKey$2 = sharedKey$3;
var hiddenKeys$4 = hiddenKeys$5;

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError$3 = global$l.TypeError;
var WeakMap$1 = global$l.WeakMap;
var set$2, get$1, has;

var enforce = function (it) {
  return has(it) ? get$1(it) : set$2(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject$d(it) || (state = get$1(it)).type !== TYPE) {
      throw TypeError$3('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared$1.state) {
  var store = shared$1.state || (shared$1.state = new WeakMap$1());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set$2 = function (it, metadata) {
    if (store.has(it)) throw TypeError$3(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get$1 = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey$2('state');
  hiddenKeys$4[STATE] = true;
  set$2 = function (it, metadata) {
    if (hasOwn$9(it, STATE)) throw TypeError$3(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$5(it, STATE, metadata);
    return metadata;
  };
  get$1 = function (it) {
    return hasOwn$9(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn$9(it, STATE);
  };
}

var internalState = {
  set: set$2,
  get: get$1,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

var uncurryThis$r = functionUncurryThis;
var fails$m = fails$t;
var isCallable$g = isCallable$o;
var hasOwn$8 = hasOwnProperty_1;
var DESCRIPTORS$8 = descriptors;
var CONFIGURABLE_FUNCTION_NAME$2 = functionName.CONFIGURABLE;
var inspectSource$2 = inspectSource$3;
var InternalStateModule$8 = internalState;

var enforceInternalState$2 = InternalStateModule$8.enforce;
var getInternalState$5 = InternalStateModule$8.get;
var $String$2 = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty$5 = Object.defineProperty;
var stringSlice$1 = uncurryThis$r(''.slice);
var replace = uncurryThis$r(''.replace);
var join$1 = uncurryThis$r([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS$8 && !fails$m(function () {
  return defineProperty$5(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn$2 = makeBuiltIn$3.exports = function (value, name, options) {
  if (stringSlice$1($String$2(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String$2(name), /^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn$8(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$2 && value.name !== name)) {
    if (DESCRIPTORS$8) defineProperty$5(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$8(options, 'arity') && value.length !== options.arity) {
    defineProperty$5(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn$8(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS$8) defineProperty$5(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState$2(value);
  if (!hasOwn$8(state, 'source')) {
    state.source = join$1(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn$2(function toString() {
  return isCallable$g(this) && getInternalState$5(this).source || inspectSource$2(this);
}, 'toString');

var isCallable$f = isCallable$o;
var definePropertyModule$4 = objectDefineProperty;
var makeBuiltIn$1 = makeBuiltIn$3.exports;
var defineGlobalProperty$1 = defineGlobalProperty$3;

var defineBuiltIn$a = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable$f(value)) makeBuiltIn$1(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule$4.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};

var objectGetOwnPropertyNames = {};

var ceil = Math.ceil;
var floor$4 = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
var mathTrunc = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor$4 : ceil)(n);
};

var trunc = mathTrunc;

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
var toIntegerOrInfinity$b = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};

var toIntegerOrInfinity$a = toIntegerOrInfinity$b;

var max$2 = Math.max;
var min$4 = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex$6 = function (index, length) {
  var integer = toIntegerOrInfinity$a(index);
  return integer < 0 ? max$2(integer + length, 0) : min$4(integer, length);
};

var toIntegerOrInfinity$9 = toIntegerOrInfinity$b;

var min$3 = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
var toLength$5 = function (argument) {
  return argument > 0 ? min$3(toIntegerOrInfinity$9(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var toLength$4 = toLength$5;

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
var lengthOfArrayLike$i = function (obj) {
  return toLength$4(obj.length);
};

var toIndexedObject$7 = toIndexedObject$9;
var toAbsoluteIndex$5 = toAbsoluteIndex$6;
var lengthOfArrayLike$h = lengthOfArrayLike$i;

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod$6 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$7($this);
    var length = lengthOfArrayLike$h(O);
    var index = toAbsoluteIndex$5(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$6(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$6(false)
};

var uncurryThis$q = functionUncurryThis;
var hasOwn$7 = hasOwnProperty_1;
var toIndexedObject$6 = toIndexedObject$9;
var indexOf = arrayIncludes.indexOf;
var hiddenKeys$3 = hiddenKeys$5;

var push$4 = uncurryThis$q([].push);

var objectKeysInternal = function (object, names) {
  var O = toIndexedObject$6(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn$7(hiddenKeys$3, key) && hasOwn$7(O, key) && push$4(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn$7(O, key = names[i++])) {
    ~indexOf(result, key) || push$4(result, key);
  }
  return result;
};

// IE8- don't enum bug keys
var enumBugKeys$3 = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];

var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;

var hiddenKeys$2 = enumBugKeys$2.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys$1(O, hiddenKeys$2);
};

var objectGetOwnPropertySymbols = {};

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

var getBuiltIn$a = getBuiltIn$c;
var uncurryThis$p = functionUncurryThis;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject$b = anObject$d;

var concat = uncurryThis$p([].concat);

// all object keys, includes non-enumerable and symbols
var ownKeys$1 = getBuiltIn$a('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule$1.f(anObject$b(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};

var hasOwn$6 = hasOwnProperty_1;
var ownKeys = ownKeys$1;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
var definePropertyModule$3 = objectDefineProperty;

var copyConstructorProperties$1 = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule$3.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn$6(target, key) && !(exceptions && hasOwn$6(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};

var fails$l = fails$t;
var isCallable$e = isCallable$o;

var replacement = /#|\.prototype\./;

var isForced$3 = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable$e(detection) ? fails$l(detection)
    : !!detection;
};

var normalize = isForced$3.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced$3.data = {};
var NATIVE = isForced$3.NATIVE = 'N';
var POLYFILL = isForced$3.POLYFILL = 'P';

var isForced_1 = isForced$3;

var global$k = global$u;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
var defineBuiltIn$9 = defineBuiltIn$a;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced$2 = isForced_1;

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$k;
  } else if (STATIC) {
    target = global$k[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global$k[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor$1(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced$2(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty$4(sourceProperty, 'sham', true);
    }
    defineBuiltIn$9(target, key, sourceProperty, options);
  }
};

var objectDefineProperties = {};

var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
var objectKeys$2 = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys$1);
};

var DESCRIPTORS$7 = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$2 = objectDefineProperty;
var anObject$a = anObject$d;
var toIndexedObject$5 = toIndexedObject$9;
var objectKeys$1 = objectKeys$2;

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
objectDefineProperties.f = DESCRIPTORS$7 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$a(O);
  var props = toIndexedObject$5(Properties);
  var keys = objectKeys$1(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);
  return O;
};

var getBuiltIn$9 = getBuiltIn$c;

var html$2 = getBuiltIn$9('document', 'documentElement');

/* global ActiveXObject -- old IE, WSH */

var anObject$9 = anObject$d;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$1 = hiddenKeys$5;
var html$1 = html$2;
var documentCreateElement = documentCreateElement$1;
var sharedKey$1 = sharedKey$3;

var GT = '>';
var LT = '<';
var PROTOTYPE$1 = 'prototype';
var SCRIPT = 'script';
var IE_PROTO$1 = sharedKey$1('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html$1.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys$1[IE_PROTO$1] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
var objectCreate$1 = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE$1] = anObject$9(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE$1] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};

var wellKnownSymbol$h = wellKnownSymbol$j;
var create$4 = objectCreate$1;
var defineProperty$4 = objectDefineProperty.f;

var UNSCOPABLES = wellKnownSymbol$h('unscopables');
var ArrayPrototype$1 = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
  defineProperty$4(ArrayPrototype$1, UNSCOPABLES, {
    configurable: true,
    value: create$4(null)
  });
}

// add a key to Array.prototype[@@unscopables]
var addToUnscopables$2 = function (key) {
  ArrayPrototype$1[UNSCOPABLES][key] = true;
};

var $$c = _export;
var $includes$1 = arrayIncludes.includes;
var fails$k = fails$t;
var addToUnscopables$1 = addToUnscopables$2;

// FF99+ bug
var BROKEN_ON_SPARSE = fails$k(function () {
  // eslint-disable-next-line es/no-array-prototype-includes -- detection
  return !Array(1).includes();
});

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$$c({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes$1(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables$1('includes');

var global$j = global$u;
var uncurryThis$o = functionUncurryThis;

var entryUnbind$1 = function (CONSTRUCTOR, METHOD) {
  return uncurryThis$o(global$j[CONSTRUCTOR].prototype[METHOD]);
};

var entryUnbind = entryUnbind$1;

entryUnbind('Array', 'includes');

var fails$j = fails$t;

var correctPrototypeGetter = !fails$j(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var hasOwn$5 = hasOwnProperty_1;
var isCallable$d = isCallable$o;
var toObject$9 = toObject$b;
var sharedKey = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;

var IE_PROTO = sharedKey('IE_PROTO');
var $Object$1 = Object;
var ObjectPrototype$2 = $Object$1.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
var objectGetPrototypeOf$1 = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf : function (O) {
  var object = toObject$9(O);
  if (hasOwn$5(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$d(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object$1 ? ObjectPrototype$2 : null;
};

var DESCRIPTORS$6 = descriptors;
var fails$i = fails$t;
var uncurryThis$n = functionUncurryThis;
var objectGetPrototypeOf = objectGetPrototypeOf$1;
var objectKeys = objectKeys$2;
var toIndexedObject$4 = toIndexedObject$9;
var $propertyIsEnumerable = objectPropertyIsEnumerable.f;

var propertyIsEnumerable = uncurryThis$n($propertyIsEnumerable);
var push$3 = uncurryThis$n([].push);

// in some IE versions, `propertyIsEnumerable` returns incorrect result on integer keys
// of `null` prototype objects
var IE_BUG = DESCRIPTORS$6 && fails$i(function () {
  // eslint-disable-next-line es/no-object-create -- safe
  var O = Object.create(null);
  O[2] = 2;
  return !propertyIsEnumerable(O, 2);
});

// `Object.{ entries, values }` methods implementation
var createMethod$5 = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject$4(it);
    var keys = objectKeys(O);
    var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O) === null;
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS$6 || (IE_WORKAROUND ? key in O : propertyIsEnumerable(O, key))) {
        push$3(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

var objectToArray = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod$5(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod$5(false)
};

var $$b = _export;
var $values = objectToArray.values;

// `Object.values` method
// https://tc39.es/ecma262/#sec-object.values
$$b({ target: 'Object', stat: true }, {
  values: function values(O) {
    return $values(O);
  }
});

var global$i = global$u;

var path$2 = global$i;

var path$1 = path$2;

path$1.Object.values;

var $$a = _export;
var $entries = objectToArray.entries;

// `Object.entries` method
// https://tc39.es/ecma262/#sec-object.entries
$$a({ target: 'Object', stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});

var path = path$2;

path.Object.entries;

var typedArrayConstructor = {exports: {}};

var wellKnownSymbol$g = wellKnownSymbol$j;

var ITERATOR$5 = wellKnownSymbol$g('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$5] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

var checkCorrectnessOfIteration$3 = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$5] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};

// eslint-disable-next-line es/no-typed-arrays -- safe
var arrayBufferBasicDetection = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';

var wellKnownSymbol$f = wellKnownSymbol$j;

var TO_STRING_TAG$3 = wellKnownSymbol$f('toStringTag');
var test = {};

test[TO_STRING_TAG$3] = 'z';

var toStringTagSupport = String(test) === '[object z]';

var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$c = isCallable$o;
var classofRaw$1 = classofRaw$2;
var wellKnownSymbol$e = wellKnownSymbol$j;

var TO_STRING_TAG$2 = wellKnownSymbol$e('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw$1(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
var classof$c = TO_STRING_TAG_SUPPORT$2 ? classofRaw$1 : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG$2)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw$1(O)
    // ES3 arguments fallback
    : (result = classofRaw$1(O)) == 'Object' && isCallable$c(O.callee) ? 'Arguments' : result;
};

var makeBuiltIn = makeBuiltIn$3.exports;
var defineProperty$3 = objectDefineProperty;

var defineBuiltInAccessor$5 = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty$3.f(target, name, descriptor);
};

var uncurryThis$m = functionUncurryThis;
var aCallable$b = aCallable$d;

var functionUncurryThisAccessor = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis$m(aCallable$b(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};

var isCallable$b = isCallable$o;

var $String$1 = String;
var $TypeError$a = TypeError;

var aPossiblePrototype$1 = function (argument) {
  if (typeof argument == 'object' || isCallable$b(argument)) return argument;
  throw $TypeError$a("Can't set " + $String$1(argument) + ' as a prototype');
};

/* eslint-disable no-proto -- safe */

var uncurryThisAccessor = functionUncurryThisAccessor;
var anObject$8 = anObject$d;
var aPossiblePrototype = aPossiblePrototype$1;

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject$8(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);

var NATIVE_ARRAY_BUFFER$1 = arrayBufferBasicDetection;
var DESCRIPTORS$5 = descriptors;
var global$h = global$u;
var isCallable$a = isCallable$o;
var isObject$c = isObject$i;
var hasOwn$4 = hasOwnProperty_1;
var classof$b = classof$c;
var tryToString$4 = tryToString$6;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;
var defineBuiltIn$8 = defineBuiltIn$a;
var defineBuiltInAccessor$4 = defineBuiltInAccessor$5;
var isPrototypeOf$3 = objectIsPrototypeOf;
var getPrototypeOf$4 = objectGetPrototypeOf$1;
var setPrototypeOf$5 = objectSetPrototypeOf;
var wellKnownSymbol$d = wellKnownSymbol$j;
var uid$1 = uid$4;
var InternalStateModule$7 = internalState;

var enforceInternalState$1 = InternalStateModule$7.enforce;
var getInternalState$4 = InternalStateModule$7.get;
var Int8Array$4 = global$h.Int8Array;
var Int8ArrayPrototype$1 = Int8Array$4 && Int8Array$4.prototype;
var Uint8ClampedArray$1 = global$h.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;
var TypedArray$1 = Int8Array$4 && getPrototypeOf$4(Int8Array$4);
var TypedArrayPrototype$2 = Int8ArrayPrototype$1 && getPrototypeOf$4(Int8ArrayPrototype$1);
var ObjectPrototype$1 = Object.prototype;
var TypeError$2 = global$h.TypeError;

var TO_STRING_TAG$1 = wellKnownSymbol$d('toStringTag');
var TYPED_ARRAY_TAG$1 = uid$1('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS$2 = NATIVE_ARRAY_BUFFER$1 && !!setPrototypeOf$5 && classof$b(global$h.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME, Constructor, Prototype;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject$c(it)) return false;
  var klass = classof$b(it);
  return klass === 'DataView'
    || hasOwn$4(TypedArrayConstructorsList, klass)
    || hasOwn$4(BigIntArrayConstructorsList, klass);
};

var getTypedArrayConstructor$6 = function (it) {
  var proto = getPrototypeOf$4(it);
  if (!isObject$c(proto)) return;
  var state = getInternalState$4(proto);
  return (state && hasOwn$4(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor$6(proto);
};

var isTypedArray$1 = function (it) {
  if (!isObject$c(it)) return false;
  var klass = classof$b(it);
  return hasOwn$4(TypedArrayConstructorsList, klass)
    || hasOwn$4(BigIntArrayConstructorsList, klass);
};

var aTypedArray$x = function (it) {
  if (isTypedArray$1(it)) return it;
  throw TypeError$2('Target is not a typed array');
};

var aTypedArrayConstructor$5 = function (C) {
  if (isCallable$a(C) && (!setPrototypeOf$5 || isPrototypeOf$3(TypedArray$1, C))) return C;
  throw TypeError$2(tryToString$4(C) + ' is not a typed array constructor');
};

var exportTypedArrayMethod$y = function (KEY, property, forced, options) {
  if (!DESCRIPTORS$5) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global$h[ARRAY];
    if (TypedArrayConstructor && hasOwn$4(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error) {
      // old WebKit bug - some methods are non-configurable
      try {
        TypedArrayConstructor.prototype[KEY] = property;
      } catch (error2) { /* empty */ }
    }
  }
  if (!TypedArrayPrototype$2[KEY] || forced) {
    defineBuiltIn$8(TypedArrayPrototype$2, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype$1[KEY] || property, options);
  }
};

var exportTypedArrayStaticMethod$3 = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS$5) return;
  if (setPrototypeOf$5) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global$h[ARRAY];
      if (TypedArrayConstructor && hasOwn$4(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error) { /* empty */ }
    }
    if (!TypedArray$1[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return defineBuiltIn$8(TypedArray$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && TypedArray$1[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global$h[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn$8(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  Constructor = global$h[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
  else NATIVE_ARRAY_BUFFER_VIEWS$2 = false;
}

for (NAME in BigIntArrayConstructorsList) {
  Constructor = global$h[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !isCallable$a(TypedArray$1) || TypedArray$1 === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray$1 = function TypedArray() {
    throw TypeError$2('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {
    if (global$h[NAME]) setPrototypeOf$5(global$h[NAME], TypedArray$1);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !TypedArrayPrototype$2 || TypedArrayPrototype$2 === ObjectPrototype$1) {
  TypedArrayPrototype$2 = TypedArray$1.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {
    if (global$h[NAME]) setPrototypeOf$5(global$h[NAME].prototype, TypedArrayPrototype$2);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS$2 && getPrototypeOf$4(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$2) {
  setPrototypeOf$5(Uint8ClampedArrayPrototype, TypedArrayPrototype$2);
}

if (DESCRIPTORS$5 && !hasOwn$4(TypedArrayPrototype$2, TO_STRING_TAG$1)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineBuiltInAccessor$4(TypedArrayPrototype$2, TO_STRING_TAG$1, {
    configurable: true,
    get: function () {
      return isObject$c(this) ? this[TYPED_ARRAY_TAG$1] : undefined;
    }
  });
  for (NAME in TypedArrayConstructorsList) if (global$h[NAME]) {
    createNonEnumerableProperty$3(global$h[NAME], TYPED_ARRAY_TAG$1, NAME);
  }
}

var arrayBufferViewCore = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG$1,
  aTypedArray: aTypedArray$x,
  aTypedArrayConstructor: aTypedArrayConstructor$5,
  exportTypedArrayMethod: exportTypedArrayMethod$y,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$3,
  getTypedArrayConstructor: getTypedArrayConstructor$6,
  isView: isView,
  isTypedArray: isTypedArray$1,
  TypedArray: TypedArray$1,
  TypedArrayPrototype: TypedArrayPrototype$2
};

/* eslint-disable no-new -- required for testing */

var global$g = global$u;
var fails$h = fails$t;
var checkCorrectnessOfIteration$2 = checkCorrectnessOfIteration$3;
var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer$2 = global$g.ArrayBuffer;
var Int8Array$3 = global$g.Int8Array;

var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails$h(function () {
  Int8Array$3(1);
}) || !fails$h(function () {
  new Int8Array$3(-1);
}) || !checkCorrectnessOfIteration$2(function (iterable) {
  new Int8Array$3();
  new Int8Array$3(null);
  new Int8Array$3(1.5);
  new Int8Array$3(iterable);
}, true) || fails$h(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array$3(new ArrayBuffer$2(2), 1, undefined).length !== 1;
});

var defineBuiltIn$7 = defineBuiltIn$a;

var defineBuiltIns$3 = function (target, src, options) {
  for (var key in src) defineBuiltIn$7(target, key, src[key], options);
  return target;
};

var isPrototypeOf$2 = objectIsPrototypeOf;

var $TypeError$9 = TypeError;

var anInstance$5 = function (it, Prototype) {
  if (isPrototypeOf$2(Prototype, it)) return it;
  throw $TypeError$9('Incorrect invocation');
};

var toIntegerOrInfinity$8 = toIntegerOrInfinity$b;
var toLength$3 = toLength$5;

var $RangeError$3 = RangeError;

// `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex
var toIndex$2 = function (it) {
  if (it === undefined) return 0;
  var number = toIntegerOrInfinity$8(it);
  var length = toLength$3(number);
  if (number !== length) throw $RangeError$3('Wrong length or index');
  return length;
};

// IEEE754 conversions based on https://github.com/feross/ieee754
var $Array$3 = Array;
var abs = Math.abs;
var pow = Math.pow;
var floor$3 = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = $Array$3(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare -- NaN check
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare -- NaN check
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor$3(log(number) / LN2);
    c = pow(2, -exponent);
    if (number * c < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  while (mantissaLength >= 8) {
    buffer[index++] = mantissa & 255;
    mantissa /= 256;
    mantissaLength -= 8;
  }
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  while (exponentLength > 0) {
    buffer[index++] = exponent & 255;
    exponent /= 256;
    exponentLength -= 8;
  }
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  while (nBits > 0) {
    exponent = exponent * 256 + buffer[index--];
    nBits -= 8;
  }
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  while (nBits > 0) {
    mantissa = mantissa * 256 + buffer[index--];
    nBits -= 8;
  }
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

var ieee754 = {
  pack: pack,
  unpack: unpack
};

var toObject$8 = toObject$b;
var toAbsoluteIndex$4 = toAbsoluteIndex$6;
var lengthOfArrayLike$g = lengthOfArrayLike$i;

// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
var arrayFill$1 = function fill(value /* , start = 0, end = @length */) {
  var O = toObject$8(this);
  var length = lengthOfArrayLike$g(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex$4(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex$4(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

var toPropertyKey$2 = toPropertyKey$5;
var definePropertyModule$1 = objectDefineProperty;
var createPropertyDescriptor$2 = createPropertyDescriptor$5;

var createProperty$1 = function (object, key, value) {
  var propertyKey = toPropertyKey$2(key);
  if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor$2(0, value));
  else object[propertyKey] = value;
};

var toAbsoluteIndex$3 = toAbsoluteIndex$6;
var lengthOfArrayLike$f = lengthOfArrayLike$i;
var createProperty = createProperty$1;

var $Array$2 = Array;
var max$1 = Math.max;

var arraySliceSimple = function (O, start, end) {
  var length = lengthOfArrayLike$f(O);
  var k = toAbsoluteIndex$3(start, length);
  var fin = toAbsoluteIndex$3(end === undefined ? length : end, length);
  var result = $Array$2(max$1(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};

var defineProperty$2 = objectDefineProperty.f;
var hasOwn$3 = hasOwnProperty_1;
var wellKnownSymbol$c = wellKnownSymbol$j;

var TO_STRING_TAG = wellKnownSymbol$c('toStringTag');

var setToStringTag$5 = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn$3(target, TO_STRING_TAG)) {
    defineProperty$2(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};

var global$f = global$u;
var uncurryThis$l = functionUncurryThis;
var DESCRIPTORS$4 = descriptors;
var NATIVE_ARRAY_BUFFER = arrayBufferBasicDetection;
var FunctionName$1 = functionName;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
var defineBuiltInAccessor$3 = defineBuiltInAccessor$5;
var defineBuiltIns$2 = defineBuiltIns$3;
var fails$g = fails$t;
var anInstance$4 = anInstance$5;
var toIntegerOrInfinity$7 = toIntegerOrInfinity$b;
var toLength$2 = toLength$5;
var toIndex$1 = toIndex$2;
var IEEE754 = ieee754;
var getPrototypeOf$3 = objectGetPrototypeOf$1;
var setPrototypeOf$4 = objectSetPrototypeOf;
var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var arrayFill = arrayFill$1;
var arraySlice$6 = arraySliceSimple;
var setToStringTag$4 = setToStringTag$5;
var InternalStateModule$6 = internalState;

var PROPER_FUNCTION_NAME$1 = FunctionName$1.PROPER;
var CONFIGURABLE_FUNCTION_NAME$1 = FunctionName$1.CONFIGURABLE;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH$1 = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var getInternalArrayBufferState = InternalStateModule$6.getterFor(ARRAY_BUFFER);
var getInternalDataViewState = InternalStateModule$6.getterFor(DATA_VIEW);
var setInternalState$6 = InternalStateModule$6.set;
var NativeArrayBuffer = global$f[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var ArrayBufferPrototype$1 = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
var $DataView = global$f[DATA_VIEW];
var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var Array$1 = global$f.Array;
var RangeError$3 = global$f.RangeError;
var fill = uncurryThis$l(arrayFill);
var reverse = uncurryThis$l([].reverse);

var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter$1 = function (Constructor, key, getInternalState) {
  defineBuiltInAccessor$3(Constructor[PROTOTYPE], key, {
    configurable: true,
    get: function () {
      return getInternalState(this)[key];
    }
  });
};

var get = function (view, count, index, isLittleEndian) {
  var store = getInternalDataViewState(view);
  var intIndex = toIndex$1(index);
  var boolIsLittleEndian = !!isLittleEndian;
  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);
  var bytes = store.bytes;
  var start = intIndex + store.byteOffset;
  var pack = arraySlice$6(bytes, start, start + count);
  return boolIsLittleEndian ? pack : reverse(pack);
};

var set$1 = function (view, count, index, conversion, value, isLittleEndian) {
  var store = getInternalDataViewState(view);
  var intIndex = toIndex$1(index);
  var pack = conversion(+value);
  var boolIsLittleEndian = !!isLittleEndian;
  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);
  var bytes = store.bytes;
  var start = intIndex + store.byteOffset;
  for (var i = 0; i < count; i++) bytes[start + i] = pack[boolIsLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance$4(this, ArrayBufferPrototype$1);
    var byteLength = toIndex$1(length);
    setInternalState$6(this, {
      type: ARRAY_BUFFER,
      bytes: fill(Array$1(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS$4) {
      this.byteLength = byteLength;
      this.detached = false;
    }
  };

  ArrayBufferPrototype$1 = $ArrayBuffer[PROTOTYPE];

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance$4(this, DataViewPrototype);
    anInstance$4(buffer, ArrayBufferPrototype$1);
    var bufferState = getInternalArrayBufferState(buffer);
    var bufferLength = bufferState.byteLength;
    var offset = toIntegerOrInfinity$7(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError$3('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength$2(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError$3(WRONG_LENGTH$1);
    setInternalState$6(this, {
      type: DATA_VIEW,
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset,
      bytes: bufferState.bytes
    });
    if (!DESCRIPTORS$4) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  DataViewPrototype = $DataView[PROTOTYPE];

  if (DESCRIPTORS$4) {
    addGetter$1($ArrayBuffer, 'byteLength', getInternalArrayBufferState);
    addGetter$1($DataView, 'buffer', getInternalDataViewState);
    addGetter$1($DataView, 'byteLength', getInternalDataViewState);
    addGetter$1($DataView, 'byteOffset', getInternalDataViewState);
  }

  defineBuiltIns$2(DataViewPrototype, {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : false), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set$1(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set$1(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set$1(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : false);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set$1(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : false);
    }
  });
} else {
  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME$1 && NativeArrayBuffer.name !== ARRAY_BUFFER;
  /* eslint-disable no-new -- required for testing */
  if (!fails$g(function () {
    NativeArrayBuffer(1);
  }) || !fails$g(function () {
    new NativeArrayBuffer(-1);
  }) || fails$g(function () {
    new NativeArrayBuffer();
    new NativeArrayBuffer(1.5);
    new NativeArrayBuffer(NaN);
    return NativeArrayBuffer.length != 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME$1;
  })) {
    /* eslint-enable no-new -- required for testing */
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance$4(this, ArrayBufferPrototype$1);
      return new NativeArrayBuffer(toIndex$1(length));
    };

    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype$1;

    for (var keys = getOwnPropertyNames$1(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty$2($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }

    ArrayBufferPrototype$1.constructor = $ArrayBuffer;
  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME$1) {
    createNonEnumerableProperty$2(NativeArrayBuffer, 'name', ARRAY_BUFFER);
  }

  // WebKit bug - the same parent prototype for typed arrays and data view
  if (setPrototypeOf$4 && getPrototypeOf$3(DataViewPrototype) !== ObjectPrototype) {
    setPrototypeOf$4(DataViewPrototype, ObjectPrototype);
  }

  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = uncurryThis$l(DataViewPrototype.setInt8);
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns$2(DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag$4($ArrayBuffer, ARRAY_BUFFER);
setToStringTag$4($DataView, DATA_VIEW);

var arrayBuffer = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};

var isObject$b = isObject$i;

var floor$2 = Math.floor;

// `IsIntegralNumber` abstract operation
// https://tc39.es/ecma262/#sec-isintegralnumber
// eslint-disable-next-line es/no-number-isinteger -- safe
var isIntegralNumber$1 = Number.isInteger || function isInteger(it) {
  return !isObject$b(it) && isFinite(it) && floor$2(it) === it;
};

var toIntegerOrInfinity$6 = toIntegerOrInfinity$b;

var $RangeError$2 = RangeError;

var toPositiveInteger$1 = function (it) {
  var result = toIntegerOrInfinity$6(it);
  if (result < 0) throw $RangeError$2("The argument can't be less than 0");
  return result;
};

var toPositiveInteger = toPositiveInteger$1;

var $RangeError$1 = RangeError;

var toOffset$2 = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw $RangeError$1('Wrong offset');
  return offset;
};

var classofRaw = classofRaw$2;
var uncurryThis$k = functionUncurryThis;

var functionUncurryThisClause = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis$k(fn);
};

var uncurryThis$j = functionUncurryThisClause;
var aCallable$a = aCallable$d;
var NATIVE_BIND$1 = functionBindNative;

var bind$a = uncurryThis$j(uncurryThis$j.bind);

// optional / simple context binding
var functionBindContext = function (fn, that) {
  aCallable$a(fn);
  return that === undefined ? fn : NATIVE_BIND$1 ? bind$a(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

var uncurryThis$i = functionUncurryThis;
var fails$f = fails$t;
var isCallable$9 = isCallable$o;
var classof$a = classof$c;
var getBuiltIn$8 = getBuiltIn$c;
var inspectSource$1 = inspectSource$3;

var noop$1 = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn$8('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis$i(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$1);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$9(argument)) return false;
  try {
    construct(noop$1, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable$9(argument)) return false;
  switch (classof$a(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource$1(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
var isConstructor$3 = !construct || fails$f(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;

var isConstructor$2 = isConstructor$3;
var tryToString$3 = tryToString$6;

var $TypeError$8 = TypeError;

// `Assert: IsConstructor(argument) is true`
var aConstructor$3 = function (argument) {
  if (isConstructor$2(argument)) return argument;
  throw $TypeError$8(tryToString$3(argument) + ' is not a constructor');
};

var iterators = {};

var classof$9 = classof$c;
var getMethod$5 = getMethod$7;
var isNullOrUndefined$4 = isNullOrUndefined$7;
var Iterators$4 = iterators;
var wellKnownSymbol$b = wellKnownSymbol$j;

var ITERATOR$4 = wellKnownSymbol$b('iterator');

var getIteratorMethod$4 = function (it) {
  if (!isNullOrUndefined$4(it)) return getMethod$5(it, ITERATOR$4)
    || getMethod$5(it, '@@iterator')
    || Iterators$4[classof$9(it)];
};

var call$h = functionCall;
var aCallable$9 = aCallable$d;
var anObject$7 = anObject$d;
var tryToString$2 = tryToString$6;
var getIteratorMethod$3 = getIteratorMethod$4;

var $TypeError$7 = TypeError;

var getIterator$4 = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$3(argument) : usingIterator;
  if (aCallable$9(iteratorMethod)) return anObject$7(call$h(iteratorMethod, argument));
  throw $TypeError$7(tryToString$2(argument) + ' is not iterable');
};

var wellKnownSymbol$a = wellKnownSymbol$j;
var Iterators$3 = iterators;

var ITERATOR$3 = wellKnownSymbol$a('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
var isArrayIteratorMethod$2 = function (it) {
  return it !== undefined && (Iterators$3.Array === it || ArrayPrototype[ITERATOR$3] === it);
};

var classof$8 = classof$c;

var isBigIntArray$3 = function (it) {
  var klass = classof$8(it);
  return klass == 'BigInt64Array' || klass == 'BigUint64Array';
};

var toPrimitive = toPrimitive$2;

var $TypeError$6 = TypeError;

// `ToBigInt` abstract operation
// https://tc39.es/ecma262/#sec-tobigint
var toBigInt$4 = function (argument) {
  var prim = toPrimitive(argument, 'number');
  if (typeof prim == 'number') throw $TypeError$6("Can't convert number to bigint");
  // eslint-disable-next-line es/no-bigint -- safe
  return BigInt(prim);
};

var bind$9 = functionBindContext;
var call$g = functionCall;
var aConstructor$2 = aConstructor$3;
var toObject$7 = toObject$b;
var lengthOfArrayLike$e = lengthOfArrayLike$i;
var getIterator$3 = getIterator$4;
var getIteratorMethod$2 = getIteratorMethod$4;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
var isBigIntArray$2 = isBigIntArray$3;
var aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;
var toBigInt$3 = toBigInt$4;

var typedArrayFrom$2 = function from(source /* , mapfn, thisArg */) {
  var C = aConstructor$2(this);
  var O = toObject$7(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod$2(O);
  var i, length, result, thisIsBigIntArray, value, step, iterator, next;
  if (iteratorMethod && !isArrayIteratorMethod$1(iteratorMethod)) {
    iterator = getIterator$3(O, iteratorMethod);
    next = iterator.next;
    O = [];
    while (!(step = call$g(next, iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind$9(mapfn, arguments[2]);
  }
  length = lengthOfArrayLike$e(O);
  result = new (aTypedArrayConstructor$4(C))(length);
  thisIsBigIntArray = isBigIntArray$2(result);
  for (i = 0; length > i; i++) {
    value = mapping ? mapfn(O[i], i) : O[i];
    // FF30- typed arrays doesn't properly convert objects to typed array values
    result[i] = thisIsBigIntArray ? toBigInt$3(value) : +value;
  }
  return result;
};

var classof$7 = classofRaw$2;

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
var isArray$2 = Array.isArray || function isArray(argument) {
  return classof$7(argument) == 'Array';
};

var isArray$1 = isArray$2;
var isConstructor$1 = isConstructor$3;
var isObject$a = isObject$i;
var wellKnownSymbol$9 = wellKnownSymbol$j;

var SPECIES$3 = wellKnownSymbol$9('species');
var $Array$1 = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
var arraySpeciesConstructor$1 = function (originalArray) {
  var C;
  if (isArray$1(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor$1(C) && (C === $Array$1 || isArray$1(C.prototype))) C = undefined;
    else if (isObject$a(C)) {
      C = C[SPECIES$3];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array$1 : C;
};

var arraySpeciesConstructor = arraySpeciesConstructor$1;

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
var arraySpeciesCreate$1 = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};

var bind$8 = functionBindContext;
var uncurryThis$h = functionUncurryThis;
var IndexedObject$3 = indexedObject;
var toObject$6 = toObject$b;
var lengthOfArrayLike$d = lengthOfArrayLike$i;
var arraySpeciesCreate = arraySpeciesCreate$1;

var push$2 = uncurryThis$h([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod$4 = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject$6($this);
    var self = IndexedObject$3(O);
    var boundFunction = bind$8(callbackfn, that);
    var length = lengthOfArrayLike$d(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push$2(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push$2(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$4(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod$4(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod$4(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod$4(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod$4(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod$4(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$4(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod$4(7)
};

var getBuiltIn$7 = getBuiltIn$c;
var defineBuiltInAccessor$2 = defineBuiltInAccessor$5;
var wellKnownSymbol$8 = wellKnownSymbol$j;
var DESCRIPTORS$3 = descriptors;

var SPECIES$2 = wellKnownSymbol$8('species');

var setSpecies$3 = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$7(CONSTRUCTOR_NAME);

  if (DESCRIPTORS$3 && Constructor && !Constructor[SPECIES$2]) {
    defineBuiltInAccessor$2(Constructor, SPECIES$2, {
      configurable: true,
      get: function () { return this; }
    });
  }
};

var isCallable$8 = isCallable$o;
var isObject$9 = isObject$i;
var setPrototypeOf$3 = objectSetPrototypeOf;

// makes subclassing work correct for wrapped built-ins
var inheritIfRequired$2 = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf$3 &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable$8(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject$9(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf$3($this, NewTargetPrototype);
  return $this;
};

var $$9 = _export;
var global$e = global$u;
var call$f = functionCall;
var DESCRIPTORS$2 = descriptors;
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$2 = typedArrayConstructorsRequireWrappers;
var ArrayBufferViewCore$A = arrayBufferViewCore;
var ArrayBufferModule = arrayBuffer;
var anInstance$3 = anInstance$5;
var createPropertyDescriptor$1 = createPropertyDescriptor$5;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
var isIntegralNumber = isIntegralNumber$1;
var toLength$1 = toLength$5;
var toIndex = toIndex$2;
var toOffset$1 = toOffset$2;
var toPropertyKey$1 = toPropertyKey$5;
var hasOwn$2 = hasOwnProperty_1;
var classof$6 = classof$c;
var isObject$8 = isObject$i;
var isSymbol = isSymbol$3;
var create$3 = objectCreate$1;
var isPrototypeOf$1 = objectIsPrototypeOf;
var setPrototypeOf$2 = objectSetPrototypeOf;
var getOwnPropertyNames = objectGetOwnPropertyNames.f;
var typedArrayFrom$1 = typedArrayFrom$2;
var forEach$2 = arrayIteration.forEach;
var setSpecies$2 = setSpecies$3;
var defineBuiltInAccessor$1 = defineBuiltInAccessor$5;
var definePropertyModule = objectDefineProperty;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var InternalStateModule$5 = internalState;
var inheritIfRequired$1 = inheritIfRequired$2;

var getInternalState$3 = InternalStateModule$5.get;
var setInternalState$5 = InternalStateModule$5.set;
var enforceInternalState = InternalStateModule$5.enforce;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError$2 = global$e.RangeError;
var ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;
var ArrayBufferPrototype = ArrayBuffer$1.prototype;
var DataView$1 = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$A.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore$A.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore$A.TypedArray;
var TypedArrayPrototype$1 = ArrayBufferViewCore$A.TypedArrayPrototype;
var aTypedArrayConstructor$3 = ArrayBufferViewCore$A.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore$A.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function (C, list) {
  aTypedArrayConstructor$3(C);
  var index = 0;
  var length = list.length;
  var result = new C(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var addGetter = function (it, key) {
  defineBuiltInAccessor$1(it, key, {
    configurable: true,
    get: function () {
      return getInternalState$3(this)[key];
    }
  });
};

var isArrayBuffer = function (it) {
  var klass;
  return isPrototypeOf$1(ArrayBufferPrototype, it) || (klass = classof$6(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && !isSymbol(key)
    && key in target
    && isIntegralNumber(+key)
    && key >= 0;
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  key = toPropertyKey$1(key);
  return isTypedArrayIndex(target, key)
    ? createPropertyDescriptor$1(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  key = toPropertyKey$1(key);
  if (isTypedArrayIndex(target, key)
    && isObject$8(descriptor)
    && hasOwn$2(descriptor, 'value')
    && !hasOwn$2(descriptor, 'get')
    && !hasOwn$2(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!hasOwn$2(descriptor, 'writable') || descriptor.writable)
    && (!hasOwn$2(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS$2) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype$1, 'buffer');
    addGetter(TypedArrayPrototype$1, 'byteOffset');
    addGetter(TypedArrayPrototype$1, 'byteLength');
    addGetter(TypedArrayPrototype$1, 'length');
  }

  $$9({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  typedArrayConstructor.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global$e[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState$3(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState$3(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance$3(that, TypedArrayConstructorPrototype);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject$8(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer$1(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset$1(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError$2(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError$2(WRONG_LENGTH);
          } else {
            byteLength = toLength$1($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError$2(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return call$f(typedArrayFrom$1, TypedArrayConstructor, data);
        }
        setInternalState$5(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView$1(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf$2) setPrototypeOf$2(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create$3(TypedArrayPrototype$1);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$2) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance$3(dummy, TypedArrayConstructorPrototype);
        return inheritIfRequired$1(function () {
          if (!isObject$8(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES), $length)
            : typedArrayOffset !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES))
              : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return call$f(typedArrayFrom$1, TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });

      if (setPrototypeOf$2) setPrototypeOf$2(TypedArrayConstructor, TypedArray);
      forEach$2(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty$1(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    var FORCED = TypedArrayConstructor != NativeTypedArrayConstructor;

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $$9({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty$1(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies$2(CONSTRUCTOR_NAME);
  };
} else typedArrayConstructor.exports = function () { /* empty */ };

var createTypedArrayConstructor$8 = typedArrayConstructor.exports;

// `Int8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$8('Int8', function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor$7 = typedArrayConstructor.exports;

// `Uint8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$7('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor$6 = typedArrayConstructor.exports;

// `Uint8ClampedArray` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$6('Uint8', function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

var createTypedArrayConstructor$5 = typedArrayConstructor.exports;

// `Int16Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$5('Int16', function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor$4 = typedArrayConstructor.exports;

// `Uint16Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$4('Uint16', function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor$3 = typedArrayConstructor.exports;

// `Int32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$3('Int32', function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor$2 = typedArrayConstructor.exports;

// `Uint32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$2('Uint32', function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor$1 = typedArrayConstructor.exports;

// `Float32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor$1('Float32', function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var createTypedArrayConstructor = typedArrayConstructor.exports;

// `Float64Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Float64', function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$5 = classof$c;

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
  return '[object ' + classof$5(this) + ']';
};

var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineBuiltIn$6 = defineBuiltIn$a;
var toString$3 = objectToString;

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn$6(Object.prototype, 'toString', toString$3, { unsafe: true });
}

var classof$4 = classof$c;

var $String = String;

var toString$2 = function (argument) {
  if (classof$4(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};

var uncurryThis$g = functionUncurryThis;
var toIntegerOrInfinity$5 = toIntegerOrInfinity$b;
var toString$1 = toString$2;
var requireObjectCoercible = requireObjectCoercible$3;

var charAt$1 = uncurryThis$g(''.charAt);
var charCodeAt = uncurryThis$g(''.charCodeAt);
var stringSlice = uncurryThis$g(''.slice);

var createMethod$3 = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString$1(requireObjectCoercible($this));
    var position = toIntegerOrInfinity$5(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt$1(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$3(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$3(true)
};

var fails$e = fails$t;
var isCallable$7 = isCallable$o;
var isObject$7 = isObject$i;
var getPrototypeOf$2 = objectGetPrototypeOf$1;
var defineBuiltIn$5 = defineBuiltIn$a;
var wellKnownSymbol$7 = wellKnownSymbol$j;

var ITERATOR$2 = wellKnownSymbol$7('iterator');
var BUGGY_SAFARI_ITERATORS$1 = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator$1;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator$1 = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator$1)) BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$2(getPrototypeOf$2(arrayIterator$1));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject$7(IteratorPrototype$2) || fails$e(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype$2[ITERATOR$2].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable$7(IteratorPrototype$2[ITERATOR$2])) {
  defineBuiltIn$5(IteratorPrototype$2, ITERATOR$2, function () {
    return this;
  });
}

var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};

var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create$2 = objectCreate$1;
var createPropertyDescriptor = createPropertyDescriptor$5;
var setToStringTag$3 = setToStringTag$5;
var Iterators$2 = iterators;

var returnThis$1 = function () { return this; };

var iteratorCreateConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create$2(IteratorPrototype$1, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag$3(IteratorConstructor, TO_STRING_TAG, false);
  Iterators$2[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var $$8 = _export;
var call$e = functionCall;
var FunctionName = functionName;
var isCallable$6 = isCallable$o;
var createIteratorConstructor = iteratorCreateConstructor;
var getPrototypeOf$1 = objectGetPrototypeOf$1;
var setPrototypeOf$1 = objectSetPrototypeOf;
var setToStringTag$2 = setToStringTag$5;
var createNonEnumerableProperty = createNonEnumerableProperty$6;
var defineBuiltIn$4 = defineBuiltIn$a;
var wellKnownSymbol$6 = wellKnownSymbol$j;
var Iterators$1 = iterators;
var IteratorsCore = iteratorsCore;

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1 = wellKnownSymbol$6('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

var iteratorDefine = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$1]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$1(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf$1(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf$1) {
          setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable$6(CurrentIteratorPrototype[ITERATOR$1])) {
          defineBuiltIn$4(CurrentIteratorPrototype, ITERATOR$1, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag$2(CurrentIteratorPrototype, TO_STRING_TAG, true);
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call$e(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn$4(IterablePrototype, KEY, methods[KEY]);
      }
    } else $$8({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
    defineBuiltIn$4(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });
  }
  Iterators$1[NAME] = defaultIterator;

  return methods;
};

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
var createIterResultObject$4 = function (value, done) {
  return { value: value, done: done };
};

var charAt = stringMultibyte.charAt;
var toString = toString$2;
var InternalStateModule$4 = internalState;
var defineIterator$2 = iteratorDefine;
var createIterResultObject$3 = createIterResultObject$4;

var STRING_ITERATOR = 'String Iterator';
var setInternalState$4 = InternalStateModule$4.set;
var getInternalState$2 = InternalStateModule$4.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator$2(String, 'String', function (iterated) {
  setInternalState$4(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState$2(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject$3(undefined, true);
  point = charAt(string, index);
  state.index += point.length;
  return createIterResultObject$3(point, false);
});

var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1 = typedArrayConstructorsRequireWrappers;
var exportTypedArrayStaticMethod$2 = arrayBufferViewCore.exportTypedArrayStaticMethod;
var typedArrayFrom = typedArrayFrom$2;

// `%TypedArray%.from` method
// https://tc39.es/ecma262/#sec-%typedarray%.from
exportTypedArrayStaticMethod$2('from', typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1);

var ArrayBufferViewCore$z = arrayBufferViewCore;
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = typedArrayConstructorsRequireWrappers;

var aTypedArrayConstructor$2 = ArrayBufferViewCore$z.aTypedArrayConstructor;
var exportTypedArrayStaticMethod$1 = ArrayBufferViewCore$z.exportTypedArrayStaticMethod;

// `%TypedArray%.of` method
// https://tc39.es/ecma262/#sec-%typedarray%.of
exportTypedArrayStaticMethod$1('of', function of(/* ...items */) {
  var index = 0;
  var length = arguments.length;
  var result = new (aTypedArrayConstructor$2(this))(length);
  while (length > index) result[index] = arguments[index++];
  return result;
}, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);

var ArrayBufferViewCore$y = arrayBufferViewCore;
var lengthOfArrayLike$c = lengthOfArrayLike$i;
var toIntegerOrInfinity$4 = toIntegerOrInfinity$b;

var aTypedArray$w = ArrayBufferViewCore$y.aTypedArray;
var exportTypedArrayMethod$x = ArrayBufferViewCore$y.exportTypedArrayMethod;

// `%TypedArray%.prototype.at` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.at
exportTypedArrayMethod$x('at', function at(index) {
  var O = aTypedArray$w(this);
  var len = lengthOfArrayLike$c(O);
  var relativeIndex = toIntegerOrInfinity$4(index);
  var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
  return (k < 0 || k >= len) ? undefined : O[k];
});

var tryToString$1 = tryToString$6;

var $TypeError$5 = TypeError;

var deletePropertyOrThrow$1 = function (O, P) {
  if (!delete O[P]) throw $TypeError$5('Cannot delete property ' + tryToString$1(P) + ' of ' + tryToString$1(O));
};

var toObject$5 = toObject$b;
var toAbsoluteIndex$2 = toAbsoluteIndex$6;
var lengthOfArrayLike$b = lengthOfArrayLike$i;
var deletePropertyOrThrow = deletePropertyOrThrow$1;

var min$2 = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.copywithin
// eslint-disable-next-line es/no-array-prototype-copywithin -- safe
var arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject$5(this);
  var len = lengthOfArrayLike$b(O);
  var to = toAbsoluteIndex$2(target, len);
  var from = toAbsoluteIndex$2(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min$2((end === undefined ? len : toAbsoluteIndex$2(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else deletePropertyOrThrow(O, to);
    to += inc;
    from += inc;
  } return O;
};

var uncurryThis$f = functionUncurryThis;
var ArrayBufferViewCore$x = arrayBufferViewCore;
var $ArrayCopyWithin = arrayCopyWithin;

var u$ArrayCopyWithin = uncurryThis$f($ArrayCopyWithin);
var aTypedArray$v = ArrayBufferViewCore$x.aTypedArray;
var exportTypedArrayMethod$w = ArrayBufferViewCore$x.exportTypedArrayMethod;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod$w('copyWithin', function copyWithin(target, start /* , end */) {
  return u$ArrayCopyWithin(aTypedArray$v(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});

var ArrayBufferViewCore$w = arrayBufferViewCore;
var $every = arrayIteration.every;

var aTypedArray$u = ArrayBufferViewCore$w.aTypedArray;
var exportTypedArrayMethod$v = ArrayBufferViewCore$w.exportTypedArrayMethod;

// `%TypedArray%.prototype.every` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod$v('every', function every(callbackfn /* , thisArg */) {
  return $every(aTypedArray$u(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

var ArrayBufferViewCore$v = arrayBufferViewCore;
var $fill = arrayFill$1;
var toBigInt$2 = toBigInt$4;
var classof$3 = classof$c;
var call$d = functionCall;
var uncurryThis$e = functionUncurryThis;
var fails$d = fails$t;

var aTypedArray$t = ArrayBufferViewCore$v.aTypedArray;
var exportTypedArrayMethod$u = ArrayBufferViewCore$v.exportTypedArrayMethod;
var slice = uncurryThis$e(''.slice);

// V8 ~ Chrome < 59, Safari < 14.1, FF < 55, Edge <=18
var CONVERSION_BUG = fails$d(function () {
  var count = 0;
  // eslint-disable-next-line es/no-typed-arrays -- safe
  new Int8Array(2).fill({ valueOf: function () { return count++; } });
  return count !== 1;
});

// `%TypedArray%.prototype.fill` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
exportTypedArrayMethod$u('fill', function fill(value /* , start, end */) {
  var length = arguments.length;
  aTypedArray$t(this);
  var actualValue = slice(classof$3(this), 0, 3) === 'Big' ? toBigInt$2(value) : +value;
  return call$d($fill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);
}, CONVERSION_BUG);

var lengthOfArrayLike$a = lengthOfArrayLike$i;

var arrayFromConstructorAndList$5 = function (Constructor, list) {
  var index = 0;
  var length = lengthOfArrayLike$a(list);
  var result = new Constructor(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var anObject$6 = anObject$d;
var aConstructor$1 = aConstructor$3;
var isNullOrUndefined$3 = isNullOrUndefined$7;
var wellKnownSymbol$5 = wellKnownSymbol$j;

var SPECIES$1 = wellKnownSymbol$5('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
var speciesConstructor$2 = function (O, defaultConstructor) {
  var C = anObject$6(O).constructor;
  var S;
  return C === undefined || isNullOrUndefined$3(S = anObject$6(C)[SPECIES$1]) ? defaultConstructor : aConstructor$1(S);
};

var ArrayBufferViewCore$u = arrayBufferViewCore;
var speciesConstructor$1 = speciesConstructor$2;

var aTypedArrayConstructor$1 = ArrayBufferViewCore$u.aTypedArrayConstructor;
var getTypedArrayConstructor$5 = ArrayBufferViewCore$u.getTypedArrayConstructor;

// a part of `TypedArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#typedarray-species-create
var typedArraySpeciesConstructor$5 = function (originalArray) {
  return aTypedArrayConstructor$1(speciesConstructor$1(originalArray, getTypedArrayConstructor$5(originalArray)));
};

var arrayFromConstructorAndList$4 = arrayFromConstructorAndList$5;
var typedArraySpeciesConstructor$4 = typedArraySpeciesConstructor$5;

var typedArrayFromSpeciesAndList = function (instance, list) {
  return arrayFromConstructorAndList$4(typedArraySpeciesConstructor$4(instance), list);
};

var ArrayBufferViewCore$t = arrayBufferViewCore;
var $filter = arrayIteration.filter;
var fromSpeciesAndList$2 = typedArrayFromSpeciesAndList;

var aTypedArray$s = ArrayBufferViewCore$t.aTypedArray;
var exportTypedArrayMethod$t = ArrayBufferViewCore$t.exportTypedArrayMethod;

// `%TypedArray%.prototype.filter` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod$t('filter', function filter(callbackfn /* , thisArg */) {
  var list = $filter(aTypedArray$s(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  return fromSpeciesAndList$2(this, list);
});

var ArrayBufferViewCore$s = arrayBufferViewCore;
var $find = arrayIteration.find;

var aTypedArray$r = ArrayBufferViewCore$s.aTypedArray;
var exportTypedArrayMethod$s = ArrayBufferViewCore$s.exportTypedArrayMethod;

// `%TypedArray%.prototype.find` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod$s('find', function find(predicate /* , thisArg */) {
  return $find(aTypedArray$r(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

var ArrayBufferViewCore$r = arrayBufferViewCore;
var $findIndex = arrayIteration.findIndex;

var aTypedArray$q = ArrayBufferViewCore$r.aTypedArray;
var exportTypedArrayMethod$r = ArrayBufferViewCore$r.exportTypedArrayMethod;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod$r('findIndex', function findIndex(predicate /* , thisArg */) {
  return $findIndex(aTypedArray$q(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

var bind$7 = functionBindContext;
var IndexedObject$2 = indexedObject;
var toObject$4 = toObject$b;
var lengthOfArrayLike$9 = lengthOfArrayLike$i;

// `Array.prototype.{ findLast, findLastIndex }` methods implementation
var createMethod$2 = function (TYPE) {
  var IS_FIND_LAST_INDEX = TYPE == 1;
  return function ($this, callbackfn, that) {
    var O = toObject$4($this);
    var self = IndexedObject$2(O);
    var boundFunction = bind$7(callbackfn, that);
    var index = lengthOfArrayLike$9(self);
    var value, result;
    while (index-- > 0) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (result) switch (TYPE) {
        case 0: return value; // findLast
        case 1: return index; // findLastIndex
      }
    }
    return IS_FIND_LAST_INDEX ? -1 : undefined;
  };
};

var arrayIterationFromLast = {
  // `Array.prototype.findLast` method
  // https://github.com/tc39/proposal-array-find-from-last
  findLast: createMethod$2(0),
  // `Array.prototype.findLastIndex` method
  // https://github.com/tc39/proposal-array-find-from-last
  findLastIndex: createMethod$2(1)
};

var ArrayBufferViewCore$q = arrayBufferViewCore;
var $findLast = arrayIterationFromLast.findLast;

var aTypedArray$p = ArrayBufferViewCore$q.aTypedArray;
var exportTypedArrayMethod$q = ArrayBufferViewCore$q.exportTypedArrayMethod;

// `%TypedArray%.prototype.findLast` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findlast
exportTypedArrayMethod$q('findLast', function findLast(predicate /* , thisArg */) {
  return $findLast(aTypedArray$p(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

var ArrayBufferViewCore$p = arrayBufferViewCore;
var $findLastIndex = arrayIterationFromLast.findLastIndex;

var aTypedArray$o = ArrayBufferViewCore$p.aTypedArray;
var exportTypedArrayMethod$p = ArrayBufferViewCore$p.exportTypedArrayMethod;

// `%TypedArray%.prototype.findLastIndex` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findlastindex
exportTypedArrayMethod$p('findLastIndex', function findLastIndex(predicate /* , thisArg */) {
  return $findLastIndex(aTypedArray$o(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

var ArrayBufferViewCore$o = arrayBufferViewCore;
var $forEach = arrayIteration.forEach;

var aTypedArray$n = ArrayBufferViewCore$o.aTypedArray;
var exportTypedArrayMethod$o = ArrayBufferViewCore$o.exportTypedArrayMethod;

// `%TypedArray%.prototype.forEach` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod$o('forEach', function forEach(callbackfn /* , thisArg */) {
  $forEach(aTypedArray$n(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

var ArrayBufferViewCore$n = arrayBufferViewCore;
var $includes = arrayIncludes.includes;

var aTypedArray$m = ArrayBufferViewCore$n.aTypedArray;
var exportTypedArrayMethod$n = ArrayBufferViewCore$n.exportTypedArrayMethod;

// `%TypedArray%.prototype.includes` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod$n('includes', function includes(searchElement /* , fromIndex */) {
  return $includes(aTypedArray$m(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

var ArrayBufferViewCore$m = arrayBufferViewCore;
var $indexOf = arrayIncludes.indexOf;

var aTypedArray$l = ArrayBufferViewCore$m.aTypedArray;
var exportTypedArrayMethod$m = ArrayBufferViewCore$m.exportTypedArrayMethod;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod$m('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return $indexOf(aTypedArray$l(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

var ArrayBufferViewCore$l = arrayBufferViewCore;
var uncurryThis$d = functionUncurryThis;

var aTypedArray$k = ArrayBufferViewCore$l.aTypedArray;
var exportTypedArrayMethod$l = ArrayBufferViewCore$l.exportTypedArrayMethod;
var $join = uncurryThis$d([].join);

// `%TypedArray%.prototype.join` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
exportTypedArrayMethod$l('join', function join(separator) {
  return $join(aTypedArray$k(this), separator);
});

var NATIVE_BIND = functionBindNative;

var FunctionPrototype = Function.prototype;
var apply$4 = FunctionPrototype.apply;
var call$c = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call$c.bind(apply$4) : function () {
  return call$c.apply(apply$4, arguments);
});

var fails$c = fails$t;

var arrayMethodIsStrict$1 = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$c(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};

/* eslint-disable es/no-array-prototype-lastindexof -- safe */
var apply$3 = functionApply;
var toIndexedObject$3 = toIndexedObject$9;
var toIntegerOrInfinity$3 = toIntegerOrInfinity$b;
var lengthOfArrayLike$8 = lengthOfArrayLike$i;
var arrayMethodIsStrict = arrayMethodIsStrict$1;

var min$1 = Math.min;
var $lastIndexOf$1 = [].lastIndexOf;
var NEGATIVE_ZERO = !!$lastIndexOf$1 && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
var FORCED$2 = NEGATIVE_ZERO || !STRICT_METHOD;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
var arrayLastIndexOf = FORCED$2 ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return apply$3($lastIndexOf$1, this, arguments) || 0;
  var O = toIndexedObject$3(this);
  var length = lengthOfArrayLike$8(O);
  var index = length - 1;
  if (arguments.length > 1) index = min$1(index, toIntegerOrInfinity$3(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : $lastIndexOf$1;

var ArrayBufferViewCore$k = arrayBufferViewCore;
var apply$2 = functionApply;
var $lastIndexOf = arrayLastIndexOf;

var aTypedArray$j = ArrayBufferViewCore$k.aTypedArray;
var exportTypedArrayMethod$k = ArrayBufferViewCore$k.exportTypedArrayMethod;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
exportTypedArrayMethod$k('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  var length = arguments.length;
  return apply$2($lastIndexOf, aTypedArray$j(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
});

var ArrayBufferViewCore$j = arrayBufferViewCore;
var $map = arrayIteration.map;
var typedArraySpeciesConstructor$3 = typedArraySpeciesConstructor$5;

var aTypedArray$i = ArrayBufferViewCore$j.aTypedArray;
var exportTypedArrayMethod$j = ArrayBufferViewCore$j.exportTypedArrayMethod;

// `%TypedArray%.prototype.map` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod$j('map', function map(mapfn /* , thisArg */) {
  return $map(aTypedArray$i(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (typedArraySpeciesConstructor$3(O))(length);
  });
});

var aCallable$8 = aCallable$d;
var toObject$3 = toObject$b;
var IndexedObject$1 = indexedObject;
var lengthOfArrayLike$7 = lengthOfArrayLike$i;

var $TypeError$4 = TypeError;

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod$1 = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aCallable$8(callbackfn);
    var O = toObject$3(that);
    var self = IndexedObject$1(O);
    var length = lengthOfArrayLike$7(O);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw $TypeError$4('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod$1(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod$1(true)
};

var ArrayBufferViewCore$i = arrayBufferViewCore;
var $reduce = arrayReduce.left;

var aTypedArray$h = ArrayBufferViewCore$i.aTypedArray;
var exportTypedArrayMethod$i = ArrayBufferViewCore$i.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduce` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod$i('reduce', function reduce(callbackfn /* , initialValue */) {
  var length = arguments.length;
  return $reduce(aTypedArray$h(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
});

var ArrayBufferViewCore$h = arrayBufferViewCore;
var $reduceRight = arrayReduce.right;

var aTypedArray$g = ArrayBufferViewCore$h.aTypedArray;
var exportTypedArrayMethod$h = ArrayBufferViewCore$h.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduceRight` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod$h('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  var length = arguments.length;
  return $reduceRight(aTypedArray$g(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
});

var ArrayBufferViewCore$g = arrayBufferViewCore;

var aTypedArray$f = ArrayBufferViewCore$g.aTypedArray;
var exportTypedArrayMethod$g = ArrayBufferViewCore$g.exportTypedArrayMethod;
var floor$1 = Math.floor;

// `%TypedArray%.prototype.reverse` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod$g('reverse', function reverse() {
  var that = this;
  var length = aTypedArray$f(that).length;
  var middle = floor$1(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});

var global$d = global$u;
var call$b = functionCall;
var ArrayBufferViewCore$f = arrayBufferViewCore;
var lengthOfArrayLike$6 = lengthOfArrayLike$i;
var toOffset = toOffset$2;
var toIndexedObject$2 = toObject$b;
var fails$b = fails$t;

var RangeError$1 = global$d.RangeError;
var Int8Array$2 = global$d.Int8Array;
var Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;
var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
var aTypedArray$e = ArrayBufferViewCore$f.aTypedArray;
var exportTypedArrayMethod$f = ArrayBufferViewCore$f.exportTypedArrayMethod;

var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails$b(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  var array = new Uint8ClampedArray(2);
  call$b($set, array, { length: 1, 0: 3 }, 1);
  return array[1] !== 3;
});

// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other
var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore$f.NATIVE_ARRAY_BUFFER_VIEWS && fails$b(function () {
  var array = new Int8Array$2(2);
  array.set(1);
  array.set('2', 1);
  return array[0] !== 0 || array[1] !== 2;
});

// `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod$f('set', function set(arrayLike /* , offset */) {
  aTypedArray$e(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var src = toIndexedObject$2(arrayLike);
  if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call$b($set, this, src, offset);
  var length = this.length;
  var len = lengthOfArrayLike$6(src);
  var index = 0;
  if (len + offset > length) throw RangeError$1('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);

var uncurryThis$c = functionUncurryThis;

var arraySlice$5 = uncurryThis$c([].slice);

var ArrayBufferViewCore$e = arrayBufferViewCore;
var typedArraySpeciesConstructor$2 = typedArraySpeciesConstructor$5;
var fails$a = fails$t;
var arraySlice$4 = arraySlice$5;

var aTypedArray$d = ArrayBufferViewCore$e.aTypedArray;
var exportTypedArrayMethod$e = ArrayBufferViewCore$e.exportTypedArrayMethod;

var FORCED$1 = fails$a(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod$e('slice', function slice(start, end) {
  var list = arraySlice$4(aTypedArray$d(this), start, end);
  var C = typedArraySpeciesConstructor$2(this);
  var index = 0;
  var length = list.length;
  var result = new C(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED$1);

var ArrayBufferViewCore$d = arrayBufferViewCore;
var $some = arrayIteration.some;

var aTypedArray$c = ArrayBufferViewCore$d.aTypedArray;
var exportTypedArrayMethod$d = ArrayBufferViewCore$d.exportTypedArrayMethod;

// `%TypedArray%.prototype.some` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod$d('some', function some(callbackfn /* , thisArg */) {
  return $some(aTypedArray$c(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

var arraySlice$3 = arraySliceSimple;

var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort$1(array, comparefn) : merge(
    array,
    mergeSort(arraySlice$3(array, 0, middle), comparefn),
    mergeSort(arraySlice$3(array, middle), comparefn),
    comparefn
  );
};

var insertionSort$1 = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  } return array;
};

var merge = function (array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;

  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = (lindex < llength && rindex < rlength)
      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
      : lindex < llength ? left[lindex++] : right[rindex++];
  } return array;
};

var arraySort = mergeSort;

var userAgent$4 = engineUserAgent;

var firefox = userAgent$4.match(/firefox\/(\d+)/i);

var engineFfVersion = !!firefox && +firefox[1];

var UA = engineUserAgent;

var engineIsIeOrEdge = /MSIE|Trident/.test(UA);

var userAgent$3 = engineUserAgent;

var webkit = userAgent$3.match(/AppleWebKit\/(\d+)\./);

var engineWebkitVersion = !!webkit && +webkit[1];

var global$c = global$u;
var uncurryThis$b = functionUncurryThisClause;
var fails$9 = fails$t;
var aCallable$7 = aCallable$d;
var internalSort = arraySort;
var ArrayBufferViewCore$c = arrayBufferViewCore;
var FF = engineFfVersion;
var IE_OR_EDGE = engineIsIeOrEdge;
var V8 = engineV8Version;
var WEBKIT = engineWebkitVersion;

var aTypedArray$b = ArrayBufferViewCore$c.aTypedArray;
var exportTypedArrayMethod$c = ArrayBufferViewCore$c.exportTypedArrayMethod;
var Uint16Array$1 = global$c.Uint16Array;
var nativeSort = Uint16Array$1 && uncurryThis$b(Uint16Array$1.prototype.sort);

// WebKit
var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails$9(function () {
  nativeSort(new Uint16Array$1(2), null);
}) && fails$9(function () {
  nativeSort(new Uint16Array$1(2), {});
}));

var STABLE_SORT = !!nativeSort && !fails$9(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 74;
  if (FF) return FF < 67;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 602;

  var array = new Uint16Array$1(516);
  var expected = Array(516);
  var index, mod;

  for (index = 0; index < 516; index++) {
    mod = index % 4;
    array[index] = 515 - index;
    expected[index] = index - 2 * mod + 3;
  }

  nativeSort(array, function (a, b) {
    return (a / 4 | 0) - (b / 4 | 0);
  });

  for (index = 0; index < 516; index++) {
    if (array[index] !== expected[index]) return true;
  }
});

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    // eslint-disable-next-line no-self-compare -- NaN check
    if (y !== y) return -1;
    // eslint-disable-next-line no-self-compare -- NaN check
    if (x !== x) return 1;
    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
    return x > y;
  };
};

// `%TypedArray%.prototype.sort` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod$c('sort', function sort(comparefn) {
  if (comparefn !== undefined) aCallable$7(comparefn);
  if (STABLE_SORT) return nativeSort(this, comparefn);

  return internalSort(aTypedArray$b(this), getSortCompare(comparefn));
}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);

var ArrayBufferViewCore$b = arrayBufferViewCore;
var toLength = toLength$5;
var toAbsoluteIndex$1 = toAbsoluteIndex$6;
var typedArraySpeciesConstructor$1 = typedArraySpeciesConstructor$5;

var aTypedArray$a = ArrayBufferViewCore$b.aTypedArray;
var exportTypedArrayMethod$b = ArrayBufferViewCore$b.exportTypedArrayMethod;

// `%TypedArray%.prototype.subarray` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod$b('subarray', function subarray(begin, end) {
  var O = aTypedArray$a(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex$1(begin, length);
  var C = typedArraySpeciesConstructor$1(O);
  return new C(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex$1(end, length)) - beginIndex)
  );
});

var global$b = global$u;
var apply$1 = functionApply;
var ArrayBufferViewCore$a = arrayBufferViewCore;
var fails$8 = fails$t;
var arraySlice$2 = arraySlice$5;

var Int8Array$1 = global$b.Int8Array;
var aTypedArray$9 = ArrayBufferViewCore$a.aTypedArray;
var exportTypedArrayMethod$a = ArrayBufferViewCore$a.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails$8(function () {
  $toLocaleString.call(new Int8Array$1(1));
});

var FORCED = fails$8(function () {
  return [1, 2].toLocaleString() != new Int8Array$1([1, 2]).toLocaleString();
}) || !fails$8(function () {
  Int8Array$1.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod$a('toLocaleString', function toLocaleString() {
  return apply$1(
    $toLocaleString,
    TO_LOCALE_STRING_BUG ? arraySlice$2(aTypedArray$9(this)) : aTypedArray$9(this),
    arraySlice$2(arguments)
  );
}, FORCED);

var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod;
var fails$7 = fails$t;
var global$a = global$u;
var uncurryThis$a = functionUncurryThis;

var Uint8Array$2 = global$a.Uint8Array;
var Uint8ArrayPrototype = Uint8Array$2 && Uint8Array$2.prototype || {};
var arrayToString = [].toString;
var join = uncurryThis$a([].join);

if (fails$7(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return join(this);
  };
}

var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

// `%TypedArray%.prototype.toString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod$9('toString', arrayToString, IS_NOT_ARRAY_METHOD);

var lengthOfArrayLike$5 = lengthOfArrayLike$i;

// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toReversed
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed
var arrayToReversed$1 = function (O, C) {
  var len = lengthOfArrayLike$5(O);
  var A = new C(len);
  var k = 0;
  for (; k < len; k++) A[k] = O[len - k - 1];
  return A;
};

var arrayToReversed = arrayToReversed$1;
var ArrayBufferViewCore$9 = arrayBufferViewCore;

var aTypedArray$8 = ArrayBufferViewCore$9.aTypedArray;
var exportTypedArrayMethod$8 = ArrayBufferViewCore$9.exportTypedArrayMethod;
var getTypedArrayConstructor$4 = ArrayBufferViewCore$9.getTypedArrayConstructor;

// `%TypedArray%.prototype.toReversed` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.toreversed
exportTypedArrayMethod$8('toReversed', function toReversed() {
  return arrayToReversed(aTypedArray$8(this), getTypedArrayConstructor$4(this));
});

var ArrayBufferViewCore$8 = arrayBufferViewCore;
var uncurryThis$9 = functionUncurryThis;
var aCallable$6 = aCallable$d;
var arrayFromConstructorAndList$3 = arrayFromConstructorAndList$5;

var aTypedArray$7 = ArrayBufferViewCore$8.aTypedArray;
var getTypedArrayConstructor$3 = ArrayBufferViewCore$8.getTypedArrayConstructor;
var exportTypedArrayMethod$7 = ArrayBufferViewCore$8.exportTypedArrayMethod;
var sort = uncurryThis$9(ArrayBufferViewCore$8.TypedArrayPrototype.sort);

// `%TypedArray%.prototype.toSorted` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tosorted
exportTypedArrayMethod$7('toSorted', function toSorted(compareFn) {
  if (compareFn !== undefined) aCallable$6(compareFn);
  var O = aTypedArray$7(this);
  var A = arrayFromConstructorAndList$3(getTypedArrayConstructor$3(O), O);
  return sort(A, compareFn);
});

var lengthOfArrayLike$4 = lengthOfArrayLike$i;
var toIntegerOrInfinity$2 = toIntegerOrInfinity$b;

var $RangeError = RangeError;

// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.with
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with
var arrayWith$1 = function (O, C, index, value) {
  var len = lengthOfArrayLike$4(O);
  var relativeIndex = toIntegerOrInfinity$2(index);
  var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
  if (actualIndex >= len || actualIndex < 0) throw $RangeError('Incorrect index');
  var A = new C(len);
  var k = 0;
  for (; k < len; k++) A[k] = k === actualIndex ? value : O[k];
  return A;
};

var arrayWith = arrayWith$1;
var ArrayBufferViewCore$7 = arrayBufferViewCore;
var isBigIntArray$1 = isBigIntArray$3;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$b;
var toBigInt$1 = toBigInt$4;

var aTypedArray$6 = ArrayBufferViewCore$7.aTypedArray;
var getTypedArrayConstructor$2 = ArrayBufferViewCore$7.getTypedArrayConstructor;
var exportTypedArrayMethod$6 = ArrayBufferViewCore$7.exportTypedArrayMethod;

var PROPER_ORDER$1 = !!function () {
  try {
    // eslint-disable-next-line no-throw-literal, es/no-typed-arrays, es/no-array-prototype-with -- required for testing
    new Int8Array(1)['with'](2, { valueOf: function () { throw 8; } });
  } catch (error) {
    // some early implementations, like WebKit, does not follow the final semantic
    // https://github.com/tc39/proposal-change-array-by-copy/pull/86
    return error === 8;
  }
}();

// `%TypedArray%.prototype.with` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.with
exportTypedArrayMethod$6('with', { 'with': function (index, value) {
  var O = aTypedArray$6(this);
  var relativeIndex = toIntegerOrInfinity$1(index);
  var actualValue = isBigIntArray$1(O) ? toBigInt$1(value) : +value;
  return arrayWith(O, getTypedArrayConstructor$2(O), relativeIndex, actualValue);
} }['with'], !PROPER_ORDER$1);

var toIndexedObject$1 = toIndexedObject$9;
var addToUnscopables = addToUnscopables$2;
var Iterators = iterators;
var InternalStateModule$3 = internalState;
var defineProperty$1 = objectDefineProperty.f;
var defineIterator$1 = iteratorDefine;
var createIterResultObject$2 = createIterResultObject$4;
var DESCRIPTORS$1 = descriptors;

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$3 = InternalStateModule$3.set;
var getInternalState$1 = InternalStateModule$3.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
var es_array_iterator = defineIterator$1(Array, 'Array', function (iterated, kind) {
  setInternalState$3(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject$1(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return createIterResultObject$2(undefined, true);
  }
  if (kind == 'keys') return createIterResultObject$2(index, false);
  if (kind == 'values') return createIterResultObject$2(target[index], false);
  return createIterResultObject$2([index, target[index]], false);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (DESCRIPTORS$1 && values.name !== 'values') try {
  defineProperty$1(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }

var global$9 = global$u;
var fails$6 = fails$t;
var uncurryThis$8 = functionUncurryThis;
var ArrayBufferViewCore$6 = arrayBufferViewCore;
var ArrayIterators = es_array_iterator;
var wellKnownSymbol$4 = wellKnownSymbol$j;

var ITERATOR = wellKnownSymbol$4('iterator');
var Uint8Array$1 = global$9.Uint8Array;
var arrayValues = uncurryThis$8(ArrayIterators.values);
var arrayKeys = uncurryThis$8(ArrayIterators.keys);
var arrayEntries = uncurryThis$8(ArrayIterators.entries);
var aTypedArray$5 = ArrayBufferViewCore$6.aTypedArray;
var exportTypedArrayMethod$5 = ArrayBufferViewCore$6.exportTypedArrayMethod;
var TypedArrayPrototype = Uint8Array$1 && Uint8Array$1.prototype;

var GENERIC = !fails$6(function () {
  TypedArrayPrototype[ITERATOR].call([1]);
});

var ITERATOR_IS_VALUES = !!TypedArrayPrototype
  && TypedArrayPrototype.values
  && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values
  && TypedArrayPrototype.values.name === 'values';

var typedArrayValues = function values() {
  return arrayValues(aTypedArray$5(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod$5('entries', function entries() {
  return arrayEntries(aTypedArray$5(this));
}, GENERIC);
// `%TypedArray%.prototype.keys` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod$5('keys', function keys() {
  return arrayKeys(aTypedArray$5(this));
}, GENERIC);
// `%TypedArray%.prototype.values` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod$5('values', typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod$5(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });

// TODO: Remove from `core-js@4`
var ArrayBufferViewCore$5 = arrayBufferViewCore;
var lengthOfArrayLike$3 = lengthOfArrayLike$i;
var isBigIntArray = isBigIntArray$3;
var toAbsoluteIndex = toAbsoluteIndex$6;
var toBigInt = toBigInt$4;
var toIntegerOrInfinity = toIntegerOrInfinity$b;
var fails$5 = fails$t;

var aTypedArray$4 = ArrayBufferViewCore$5.aTypedArray;
var getTypedArrayConstructor$1 = ArrayBufferViewCore$5.getTypedArrayConstructor;
var exportTypedArrayMethod$4 = ArrayBufferViewCore$5.exportTypedArrayMethod;
var max = Math.max;
var min = Math.min;

// some early implementations, like WebKit, does not follow the final semantic
var PROPER_ORDER = !fails$5(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  var array = new Int8Array([1]);

  var spliced = array.toSpliced(1, 0, {
    valueOf: function () {
      array[0] = 2;
      return 3;
    }
  });

  return spliced[0] !== 2 || spliced[1] !== 3;
});

// `%TypedArray%.prototype.toSpliced` method
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSpliced
exportTypedArrayMethod$4('toSpliced', function toSpliced(start, deleteCount /* , ...items */) {
  var O = aTypedArray$4(this);
  var C = getTypedArrayConstructor$1(O);
  var len = lengthOfArrayLike$3(O);
  var actualStart = toAbsoluteIndex(start, len);
  var argumentsLength = arguments.length;
  var k = 0;
  var insertCount, actualDeleteCount, thisIsBigIntArray, convertedItems, value, newLen, A;
  if (argumentsLength === 0) {
    insertCount = actualDeleteCount = 0;
  } else if (argumentsLength === 1) {
    insertCount = 0;
    actualDeleteCount = len - actualStart;
  } else {
    actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    insertCount = argumentsLength - 2;
    if (insertCount) {
      convertedItems = new C(insertCount);
      thisIsBigIntArray = isBigIntArray(convertedItems);
      for (var i = 2; i < argumentsLength; i++) {
        value = arguments[i];
        // FF30- typed arrays doesn't properly convert objects to typed array values
        convertedItems[i - 2] = thisIsBigIntArray ? toBigInt(value) : +value;
      }
    }
  }
  newLen = len + insertCount - actualDeleteCount;
  A = new C(newLen);

  for (; k < actualStart; k++) A[k] = O[k];
  for (; k < actualStart + insertCount; k++) A[k] = convertedItems[k - actualStart];
  for (; k < newLen; k++) A[k] = O[k + actualDeleteCount - insertCount];

  return A;
}, !PROPER_ORDER);

var internalMetadata = {exports: {}};

var objectGetOwnPropertyNamesExternal = {};

/* eslint-disable es/no-object-getownpropertynames -- safe */

var classof$2 = classofRaw$2;
var toIndexedObject = toIndexedObject$9;
var $getOwnPropertyNames = objectGetOwnPropertyNames.f;
var arraySlice$1 = arraySliceSimple;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice$1(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
  return windowNames && classof$2(it) == 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};

// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
var fails$4 = fails$t;

var arrayBufferNonExtensible = fails$4(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8);
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe
    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
  }
});

var fails$3 = fails$t;
var isObject$6 = isObject$i;
var classof$1 = classofRaw$2;
var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;

// eslint-disable-next-line es/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails$3(function () { $isExtensible(1); });

// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
var objectIsExtensible = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {
  if (!isObject$6(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$1(it) == 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;

var fails$2 = fails$t;

var freezing = !fails$2(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});

var $$7 = _export;
var uncurryThis$7 = functionUncurryThis;
var hiddenKeys = hiddenKeys$5;
var isObject$5 = isObject$i;
var hasOwn$1 = hasOwnProperty_1;
var defineProperty = objectDefineProperty.f;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
var isExtensible = objectIsExtensible;
var uid = uid$4;
var FREEZING = freezing;

var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + id++, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey$1 = function (it, create) {
  // return a primitive with prefix
  if (!isObject$5(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!hasOwn$1(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!hasOwn$1(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn$1(it, METADATA)) setMetadata(it);
  return it;
};

var enable = function () {
  meta.enable = function () { /* empty */ };
  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis$7([].splice);
  var test = {};
  test[METADATA] = 1;

  // prevent exposing of metadata key
  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      } return result;
    };

    $$7({ target: 'Object', stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};

var meta = internalMetadata.exports = {
  enable: enable,
  fastKey: fastKey$1,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;

var call$a = functionCall;
var anObject$5 = anObject$d;
var getMethod$4 = getMethod$7;

var iteratorClose$1 = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject$5(iterator);
  try {
    innerResult = getMethod$4(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call$a(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject$5(innerResult);
  return value;
};

var bind$6 = functionBindContext;
var call$9 = functionCall;
var anObject$4 = anObject$d;
var tryToString = tryToString$6;
var isArrayIteratorMethod = isArrayIteratorMethod$2;
var lengthOfArrayLike$2 = lengthOfArrayLike$i;
var isPrototypeOf = objectIsPrototypeOf;
var getIterator$2 = getIterator$4;
var getIteratorMethod$1 = getIteratorMethod$4;
var iteratorClose = iteratorClose$1;

var $TypeError$3 = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

var iterate$5 = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$6(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject$4(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod$1(iterable);
    if (!iterFn) throw $TypeError$3(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike$2(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator$2(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call$9(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};

var $$6 = _export;
var global$8 = global$u;
var uncurryThis$6 = functionUncurryThis;
var isForced$1 = isForced_1;
var defineBuiltIn$3 = defineBuiltIn$a;
var InternalMetadataModule = internalMetadata.exports;
var iterate$4 = iterate$5;
var anInstance$2 = anInstance$5;
var isCallable$5 = isCallable$o;
var isNullOrUndefined$2 = isNullOrUndefined$7;
var isObject$4 = isObject$i;
var fails$1 = fails$t;
var checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$3;
var setToStringTag$1 = setToStringTag$5;
var inheritIfRequired = inheritIfRequired$2;

var collection$1 = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global$8[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var uncurriedNativeMethod = uncurryThis$6(NativePrototype[KEY]);
    defineBuiltIn$3(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        uncurriedNativeMethod(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject$4(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject$4(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject$4(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  var REPLACE = isForced$1(
    CONSTRUCTOR_NAME,
    !isCallable$5(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$1(function () {
      new NativeConstructor().entries().next();
    }))
  );

  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.enable();
  } else if (isForced$1(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails$1(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration$1(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails$1(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance$2(dummy, NativePrototype);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (!isNullOrUndefined$2(iterable)) iterate$4(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $$6({ global: true, constructor: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag$1(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};

var create$1 = objectCreate$1;
var defineBuiltInAccessor = defineBuiltInAccessor$5;
var defineBuiltIns$1 = defineBuiltIns$3;
var bind$5 = functionBindContext;
var anInstance$1 = anInstance$5;
var isNullOrUndefined$1 = isNullOrUndefined$7;
var iterate$3 = iterate$5;
var defineIterator = iteratorDefine;
var createIterResultObject$1 = createIterResultObject$4;
var setSpecies$1 = setSpecies$3;
var DESCRIPTORS = descriptors;
var fastKey = internalMetadata.exports.fastKey;
var InternalStateModule$2 = internalState;

var setInternalState$2 = InternalStateModule$2.set;
var internalStateGetterFor = InternalStateModule$2.getterFor;

var collectionStrong$1 = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance$1(that, Prototype);
      setInternalState$2(that, {
        type: CONSTRUCTOR_NAME,
        index: create$1(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (!isNullOrUndefined$1(iterable)) iterate$3(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    defineBuiltIns$1(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind$5(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    defineBuiltIns$1(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineBuiltInAccessor(Prototype, 'size', {
      configurable: true,
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState$2(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return createIterResultObject$1(undefined, true);
      }
      // return step by kind
      if (kind == 'keys') return createIterResultObject$1(entry.key, false);
      if (kind == 'values') return createIterResultObject$1(entry.value, false);
      return createIterResultObject$1([entry.key, entry.value], false);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species
    setSpecies$1(CONSTRUCTOR_NAME);
  }
};

var collection = collection$1;
var collectionStrong = collectionStrong$1;

// `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects
collection('Map', function (init) {
  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);

var classof = classofRaw$2;

var engineIsNode = typeof process != 'undefined' && classof(process) == 'process';

var $TypeError$2 = TypeError;

var validateArgumentsLength$1 = function (passed, required) {
  if (passed < required) throw $TypeError$2('Not enough arguments');
  return passed;
};

var userAgent$2 = engineUserAgent;

// eslint-disable-next-line redos/no-vulnerable -- safe
var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);

var global$7 = global$u;
var apply = functionApply;
var bind$4 = functionBindContext;
var isCallable$4 = isCallable$o;
var hasOwn = hasOwnProperty_1;
var fails = fails$t;
var html = html$2;
var arraySlice = arraySlice$5;
var createElement = documentCreateElement$1;
var validateArgumentsLength = validateArgumentsLength$1;
var IS_IOS$1 = engineIsIos;
var IS_NODE$3 = engineIsNode;

var set = global$7.setImmediate;
var clear = global$7.clearImmediate;
var process$3 = global$7.process;
var Dispatch = global$7.Dispatch;
var Function$1 = global$7.Function;
var MessageChannel = global$7.MessageChannel;
var String$1 = global$7.String;
var counter = 0;
var queue$2 = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var $location, defer, channel, port;

fails(function () {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  $location = global$7.location;
});

var run = function (id) {
  if (hasOwn(queue$2, id)) {
    var fn = queue$2[id];
    delete queue$2[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var eventListener = function (event) {
  run(event.data);
};

var globalPostMessageDefer = function (id) {
  // old engines have not location.origin
  global$7.postMessage(String$1(id), $location.protocol + '//' + $location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable$4(handler) ? handler : Function$1(handler);
    var args = arraySlice(arguments, 1);
    queue$2[++counter] = function () {
      apply(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue$2[id];
  };
  // Node.js 0.8-
  if (IS_NODE$3) {
    defer = function (id) {
      process$3.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS$1) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = eventListener;
    defer = bind$4(port.postMessage, port);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global$7.addEventListener &&
    isCallable$4(global$7.postMessage) &&
    !global$7.importScripts &&
    $location && $location.protocol !== 'file:' &&
    !fails(globalPostMessageDefer)
  ) {
    defer = globalPostMessageDefer;
    global$7.addEventListener('message', eventListener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

var task$1 = {
  set: set,
  clear: clear
};

var Queue$2 = function () {
  this.head = null;
  this.tail = null;
};

Queue$2.prototype = {
  add: function (item) {
    var entry = { item: item, next: null };
    var tail = this.tail;
    if (tail) tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      var next = this.head = entry.next;
      if (next === null) this.tail = null;
      return entry.item;
    }
  }
};

var queue$1 = Queue$2;

var userAgent$1 = engineUserAgent;

var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && typeof Pebble != 'undefined';

var userAgent = engineUserAgent;

var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);

var global$6 = global$u;
var bind$3 = functionBindContext;
var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var macrotask = task$1.set;
var Queue$1 = queue$1;
var IS_IOS = engineIsIos;
var IS_IOS_PEBBLE = engineIsIosPebble;
var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
var IS_NODE$2 = engineIsNode;

var MutationObserver = global$6.MutationObserver || global$6.WebKitMutationObserver;
var document$2 = global$6.document;
var process$2 = global$6.process;
var Promise$2 = global$6.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$6, 'queueMicrotask');
var microtask$1 = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var notify$1, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!microtask$1) {
  var queue = new Queue$1();

  var flush = function () {
    var parent, fn;
    if (IS_NODE$2 && (parent = process$2.domain)) parent.exit();
    while (fn = queue.get()) try {
      fn();
    } catch (error) {
      if (queue.head) notify$1();
      throw error;
    }
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {
    toggle = true;
    node = document$2.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify$1 = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (!IS_IOS_PEBBLE && Promise$2 && Promise$2.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise$2.resolve(undefined);
    // workaround of WebKit ~ iOS Safari 10.1 bug
    promise.constructor = Promise$2;
    then = bind$3(promise.then, promise);
    notify$1 = function () {
      then(flush);
    };
  // Node.js without promises
  } else if (IS_NODE$2) {
    notify$1 = function () {
      process$2.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessage
  // - onreadystatechange
  // - setTimeout
  } else {
    // `webpack` dev server bug on IE global methods - use bind(fn, global)
    macrotask = bind$3(macrotask, global$6);
    notify$1 = function () {
      macrotask(flush);
    };
  }

  microtask$1 = function (fn) {
    if (!queue.head) notify$1();
    queue.add(fn);
  };
}

var microtask_1 = microtask$1;

var hostReportErrors$1 = function (a, b) {
  try {
    // eslint-disable-next-line no-console -- safe
    arguments.length == 1 ? console.error(a) : console.error(a, b);
  } catch (error) { /* empty */ }
};

var perform$3 = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};

var global$5 = global$u;

var promiseNativeConstructor = global$5.Promise;

/* global Deno -- Deno case */

var engineIsDeno = typeof Deno == 'object' && Deno && typeof Deno.version == 'object';

var IS_DENO$1 = engineIsDeno;
var IS_NODE$1 = engineIsNode;

var engineIsBrowser = !IS_DENO$1 && !IS_NODE$1
  && typeof window == 'object'
  && typeof document == 'object';

var global$4 = global$u;
var NativePromiseConstructor$3 = promiseNativeConstructor;
var isCallable$3 = isCallable$o;
var isForced = isForced_1;
var inspectSource = inspectSource$3;
var wellKnownSymbol$3 = wellKnownSymbol$j;
var IS_BROWSER = engineIsBrowser;
var IS_DENO = engineIsDeno;
var V8_VERSION = engineV8Version;

NativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;
var SPECIES = wellKnownSymbol$3('species');
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$3(global$4.PromiseRejectionEvent);

var FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);
  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // We can't detect it synchronously, so just check versions
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
    // Detect correctness of subclassing with @@species support
    var promise = new NativePromiseConstructor$3(function (resolve) { resolve(1); });
    var FakePromise = function (exec) {
      exec(function () { /* empty */ }, function () { /* empty */ });
    };
    var constructor = promise.constructor = {};
    constructor[SPECIES] = FakePromise;
    SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  } return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT$1;
});

var promiseConstructorDetection = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
  SUBCLASSING: SUBCLASSING
};

var newPromiseCapability$2 = {};

var aCallable$5 = aCallable$d;

var $TypeError$1 = TypeError;

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw $TypeError$1('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable$5(resolve);
  this.reject = aCallable$5(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
newPromiseCapability$2.f = function (C) {
  return new PromiseCapability(C);
};

var $$5 = _export;
var IS_NODE = engineIsNode;
var global$3 = global$u;
var call$8 = functionCall;
var defineBuiltIn$2 = defineBuiltIn$a;
var setPrototypeOf = objectSetPrototypeOf;
var setToStringTag = setToStringTag$5;
var setSpecies = setSpecies$3;
var aCallable$4 = aCallable$d;
var isCallable$2 = isCallable$o;
var isObject$3 = isObject$i;
var anInstance = anInstance$5;
var speciesConstructor = speciesConstructor$2;
var task = task$1.set;
var microtask = microtask_1;
var hostReportErrors = hostReportErrors$1;
var perform$2 = perform$3;
var Queue = queue$1;
var InternalStateModule$1 = internalState;
var NativePromiseConstructor$2 = promiseNativeConstructor;
var PromiseConstructorDetection = promiseConstructorDetection;
var newPromiseCapabilityModule$3 = newPromiseCapability$2;

var PROMISE = 'Promise';
var FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule$1.getterFor(PROMISE);
var setInternalState$1 = InternalStateModule$1.set;
var NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;
var PromiseConstructor = NativePromiseConstructor$2;
var PromisePrototype = NativePromisePrototype$1;
var TypeError$1 = global$3.TypeError;
var document$1 = global$3.document;
var process$1 = global$3.process;
var newPromiseCapability$1 = newPromiseCapabilityModule$3.f;
var newGenericPromiseCapability = newPromiseCapability$1;

var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$3.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;

var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

// helpers
var isThenable = function (it) {
  var then;
  return isObject$3(it) && isCallable$2(then = it.then) ? then : false;
};

var callReaction = function (reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve = reaction.resolve;
  var reject = reaction.reject;
  var domain = reaction.domain;
  var result, then, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value); // can throw
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject(TypeError$1('Promise-chain cycle'));
      } else if (then = isThenable(result)) {
        call$8(then, result, resolve, reject);
      } else resolve(result);
    } else reject(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject(error);
  }
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function () {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$3.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$3['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  call$8(task, global$3, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$2(function () {
        if (IS_NODE) {
          process$1.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  call$8(task, global$3, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process$1.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind$2 = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError$1("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          call$8(then, value,
            bind$2(internalResolve, wrapper, state),
            bind$2(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED_PROMISE_CONSTRUCTOR$4) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromisePrototype);
    aCallable$4(executor);
    call$8(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind$2(internalResolve, state), bind$2(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };

  PromisePrototype = PromiseConstructor.prototype;

  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState$1(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };

  // `Promise.prototype.then` method
  // https://tc39.es/ecma262/#sec-promise.prototype.then
  Internal.prototype = defineBuiltIn$2(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable$2(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable$2(onRejected) && onRejected;
    reaction.domain = IS_NODE ? process$1.domain : undefined;
    if (state.state == PENDING) state.reactions.add(reaction);
    else microtask(function () {
      callReaction(reaction, state);
    });
    return reaction.promise;
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalPromiseState(promise);
    this.promise = promise;
    this.resolve = bind$2(internalResolve, state);
    this.reject = bind$2(internalReject, state);
  };

  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (isCallable$2(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {
    nativeThen = NativePromisePrototype$1.then;

    if (!NATIVE_PROMISE_SUBCLASSING) {
      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
      defineBuiltIn$2(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          call$8(nativeThen, that, resolve, reject);
        }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
      }, { unsafe: true });
    }

    // make `.constructor === Promise` work for native promise-based APIs
    try {
      delete NativePromisePrototype$1.constructor;
    } catch (error) { /* empty */ }

    // make `instanceof Promise` work for native promise-based APIs
    if (setPrototypeOf) {
      setPrototypeOf(NativePromisePrototype$1, PromisePrototype);
    }
  }
}

$$5({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);

var NativePromiseConstructor$1 = promiseNativeConstructor;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$3;
var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;

var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function (iterable) {
  NativePromiseConstructor$1.all(iterable).then(undefined, function () { /* empty */ });
});

var $$4 = _export;
var call$7 = functionCall;
var aCallable$3 = aCallable$d;
var newPromiseCapabilityModule$2 = newPromiseCapability$2;
var perform$1 = perform$3;
var iterate$2 = iterate$5;
var PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;

// `Promise.all` method
// https://tc39.es/ecma262/#sec-promise.all
$$4({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$2.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform$1(function () {
      var $promiseResolve = aCallable$3(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate$2(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call$7($promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

var $$3 = _export;
var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
var NativePromiseConstructor = promiseNativeConstructor;
var getBuiltIn$6 = getBuiltIn$c;
var isCallable$1 = isCallable$o;
var defineBuiltIn$1 = defineBuiltIn$a;

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

// `Promise.prototype.catch` method
// https://tc39.es/ecma262/#sec-promise.prototype.catch
$$3({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {
  'catch': function (onRejected) {
    return this.then(undefined, onRejected);
  }
});

// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
if (isCallable$1(NativePromiseConstructor)) {
  var method = getBuiltIn$6('Promise').prototype['catch'];
  if (NativePromisePrototype['catch'] !== method) {
    defineBuiltIn$1(NativePromisePrototype, 'catch', method, { unsafe: true });
  }
}

var $$2 = _export;
var call$6 = functionCall;
var aCallable$2 = aCallable$d;
var newPromiseCapabilityModule$1 = newPromiseCapability$2;
var perform = perform$3;
var iterate$1 = iterate$5;
var PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;

// `Promise.race` method
// https://tc39.es/ecma262/#sec-promise.race
$$2({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$1.f(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable$2(C.resolve);
      iterate$1(iterable, function (promise) {
        call$6($promiseResolve, C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

var $$1 = _export;
var call$5 = functionCall;
var newPromiseCapabilityModule = newPromiseCapability$2;
var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;

// `Promise.reject` method
// https://tc39.es/ecma262/#sec-promise.reject
$$1({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {
  reject: function reject(r) {
    var capability = newPromiseCapabilityModule.f(this);
    call$5(capability.reject, undefined, r);
    return capability.promise;
  }
});

var anObject$3 = anObject$d;
var isObject$2 = isObject$i;
var newPromiseCapability = newPromiseCapability$2;

var promiseResolve$1 = function (C, x) {
  anObject$3(C);
  if (isObject$2(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var $ = _export;
var getBuiltIn$5 = getBuiltIn$c;
var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
var promiseResolve = promiseResolve$1;

getBuiltIn$5('Promise');

// `Promise.resolve` method
// https://tc39.es/ecma262/#sec-promise.resolve
$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  resolve: function resolve(x) {
    return promiseResolve(this, x);
  }
});

var global$2 = global$u;
var shared = sharedStore;
var isCallable = isCallable$o;
var getPrototypeOf = objectGetPrototypeOf$1;
var defineBuiltIn = defineBuiltIn$a;
var wellKnownSymbol$2 = wellKnownSymbol$j;

var USE_FUNCTION_CONSTRUCTOR = 'USE_FUNCTION_CONSTRUCTOR';
var ASYNC_ITERATOR$2 = wellKnownSymbol$2('asyncIterator');
var AsyncIterator = global$2.AsyncIterator;
var PassedAsyncIteratorPrototype = shared.AsyncIteratorPrototype;
var AsyncIteratorPrototype$1, prototype;

if (PassedAsyncIteratorPrototype) {
  AsyncIteratorPrototype$1 = PassedAsyncIteratorPrototype;
} else if (isCallable(AsyncIterator)) {
  AsyncIteratorPrototype$1 = AsyncIterator.prototype;
} else if (shared[USE_FUNCTION_CONSTRUCTOR] || global$2[USE_FUNCTION_CONSTRUCTOR]) {
  try {
    // eslint-disable-next-line no-new-func -- we have no alternatives without usage of modern syntax
    prototype = getPrototypeOf(getPrototypeOf(getPrototypeOf(Function('return async function*(){}()')())));
    if (getPrototypeOf(prototype) === Object.prototype) AsyncIteratorPrototype$1 = prototype;
  } catch (error) { /* empty */ }
}

if (!AsyncIteratorPrototype$1) AsyncIteratorPrototype$1 = {};

if (!isCallable(AsyncIteratorPrototype$1[ASYNC_ITERATOR$2])) {
  defineBuiltIn(AsyncIteratorPrototype$1, ASYNC_ITERATOR$2, function () {
    return this;
  });
}

var asyncIteratorPrototype = AsyncIteratorPrototype$1;

var call$4 = functionCall;
var anObject$2 = anObject$d;
var create = objectCreate$1;
var getMethod$3 = getMethod$7;
var defineBuiltIns = defineBuiltIns$3;
var InternalStateModule = internalState;
var getBuiltIn$4 = getBuiltIn$c;
var AsyncIteratorPrototype = asyncIteratorPrototype;
var createIterResultObject = createIterResultObject$4;

var Promise$1 = getBuiltIn$4('Promise');

var ASYNC_FROM_SYNC_ITERATOR = 'AsyncFromSyncIterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ASYNC_FROM_SYNC_ITERATOR);

var asyncFromSyncIteratorContinuation = function (result, resolve, reject) {
  var done = result.done;
  Promise$1.resolve(result.value).then(function (value) {
    resolve(createIterResultObject(value, done));
  }, reject);
};

var AsyncFromSyncIterator$2 = function AsyncIterator(iteratorRecord) {
  iteratorRecord.type = ASYNC_FROM_SYNC_ITERATOR;
  setInternalState(this, iteratorRecord);
};

AsyncFromSyncIterator$2.prototype = defineBuiltIns(create(AsyncIteratorPrototype), {
  next: function next() {
    var state = getInternalState(this);
    return new Promise$1(function (resolve, reject) {
      var result = anObject$2(call$4(state.next, state.iterator));
      asyncFromSyncIteratorContinuation(result, resolve, reject);
    });
  },
  'return': function () {
    var iterator = getInternalState(this).iterator;
    return new Promise$1(function (resolve, reject) {
      var $return = getMethod$3(iterator, 'return');
      if ($return === undefined) return resolve(createIterResultObject(undefined, true));
      var result = anObject$2(call$4($return, iterator));
      asyncFromSyncIteratorContinuation(result, resolve, reject);
    });
  }
});

var asyncFromSyncIterator = AsyncFromSyncIterator$2;

// `GetIteratorDirect(obj)` abstract operation
// https://tc39.es/proposal-iterator-helpers/#sec-getiteratordirect
var getIteratorDirect$3 = function (obj) {
  return {
    iterator: obj,
    next: obj.next,
    done: false
  };
};

var call$3 = functionCall;
var AsyncFromSyncIterator$1 = asyncFromSyncIterator;
var anObject$1 = anObject$d;
var getIterator$1 = getIterator$4;
var getIteratorDirect$2 = getIteratorDirect$3;
var getMethod$2 = getMethod$7;
var wellKnownSymbol$1 = wellKnownSymbol$j;

var ASYNC_ITERATOR$1 = wellKnownSymbol$1('asyncIterator');

var getAsyncIterator$1 = function (it, usingIterator) {
  var method = arguments.length < 2 ? getMethod$2(it, ASYNC_ITERATOR$1) : usingIterator;
  return method ? anObject$1(call$3(method, it)) : new AsyncFromSyncIterator$1(getIteratorDirect$2(getIterator$1(it)));
};

var global$1 = global$u;

var entryVirtual = function (CONSTRUCTOR) {
  return global$1[CONSTRUCTOR].prototype;
};

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

var doesNotExceedSafeInteger$1 = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};

var call$2 = functionCall;
var getBuiltIn$3 = getBuiltIn$c;
var getMethod$1 = getMethod$7;

var asyncIteratorClose = function (iterator, method, argument, reject) {
  try {
    var returnMethod = getMethod$1(iterator, 'return');
    if (returnMethod) {
      return getBuiltIn$3('Promise').resolve(call$2(returnMethod, iterator)).then(function () {
        method(argument);
      }, function (error) {
        reject(error);
      });
    }
  } catch (error2) {
    return reject(error2);
  } method(argument);
};

// https://github.com/tc39/proposal-iterator-helpers
// https://github.com/tc39/proposal-array-from-async
var call$1 = functionCall;
var aCallable$1 = aCallable$d;
var anObject = anObject$d;
var isObject$1 = isObject$i;
var doesNotExceedSafeInteger = doesNotExceedSafeInteger$1;
var getBuiltIn$2 = getBuiltIn$c;
var getIteratorDirect$1 = getIteratorDirect$3;
var closeAsyncIteration = asyncIteratorClose;

var createMethod = function (TYPE) {
  var IS_TO_ARRAY = TYPE == 0;
  var IS_FOR_EACH = TYPE == 1;
  var IS_EVERY = TYPE == 2;
  var IS_SOME = TYPE == 3;
  return function (object, fn, target) {
    anObject(object);
    var MAPPING = fn !== undefined;
    if (MAPPING || !IS_TO_ARRAY) aCallable$1(fn);
    var record = getIteratorDirect$1(object);
    var Promise = getBuiltIn$2('Promise');
    var iterator = record.iterator;
    var next = record.next;
    var counter = 0;

    return new Promise(function (resolve, reject) {
      var ifAbruptCloseAsyncIterator = function (error) {
        closeAsyncIteration(iterator, reject, error, reject);
      };

      var loop = function () {
        try {
          if (MAPPING) try {
            doesNotExceedSafeInteger(counter);
          } catch (error5) { ifAbruptCloseAsyncIterator(error5); }
          Promise.resolve(anObject(call$1(next, iterator))).then(function (step) {
            try {
              if (anObject(step).done) {
                if (IS_TO_ARRAY) {
                  target.length = counter;
                  resolve(target);
                } else resolve(IS_SOME ? false : IS_EVERY || undefined);
              } else {
                var value = step.value;
                try {
                  if (MAPPING) {
                    var result = fn(value, counter);

                    var handler = function ($result) {
                      if (IS_FOR_EACH) {
                        loop();
                      } else if (IS_EVERY) {
                        $result ? loop() : closeAsyncIteration(iterator, resolve, false, reject);
                      } else if (IS_TO_ARRAY) {
                        try {
                          target[counter++] = $result;
                          loop();
                        } catch (error4) { ifAbruptCloseAsyncIterator(error4); }
                      } else {
                        $result ? closeAsyncIteration(iterator, resolve, IS_SOME || value, reject) : loop();
                      }
                    };

                    if (isObject$1(result)) Promise.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
                    else handler(result);
                  } else {
                    target[counter++] = value;
                    loop();
                  }
                } catch (error3) { ifAbruptCloseAsyncIterator(error3); }
              }
            } catch (error2) { reject(error2); }
          }, reject);
        } catch (error) { reject(error); }
      };

      loop();
    });
  };
};

var asyncIteratorIteration = {
  toArray: createMethod(0),
  forEach: createMethod(1),
  every: createMethod(2),
  some: createMethod(3),
  find: createMethod(4)
};

var bind$1 = functionBindContext;
var uncurryThis$5 = functionUncurryThis;
var toObject$2 = toObject$b;
var isConstructor = isConstructor$3;
var getAsyncIterator = getAsyncIterator$1;
var getIterator = getIterator$4;
var getIteratorDirect = getIteratorDirect$3;
var getIteratorMethod = getIteratorMethod$4;
var getMethod = getMethod$7;
var getVirtual = entryVirtual;
var getBuiltIn$1 = getBuiltIn$c;
var wellKnownSymbol = wellKnownSymbol$j;
var AsyncFromSyncIterator = asyncFromSyncIterator;
var toArray = asyncIteratorIteration.toArray;

var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');
var arrayIterator = uncurryThis$5(getVirtual('Array').values);
var arrayIteratorNext = uncurryThis$5(arrayIterator([]).next);

var safeArrayIterator = function () {
  return new SafeArrayIterator(this);
};

var SafeArrayIterator = function (O) {
  this.iterator = arrayIterator(O);
};

SafeArrayIterator.prototype.next = function () {
  return arrayIteratorNext(this.iterator);
};

// `Array.fromAsync` method implementation
// https://github.com/tc39/proposal-array-from-async
var arrayFromAsync$1 = function fromAsync(asyncItems /* , mapfn = undefined, thisArg = undefined */) {
  var C = this;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var thisArg = argumentsLength > 2 ? arguments[2] : undefined;
  return new (getBuiltIn$1('Promise'))(function (resolve) {
    var O = toObject$2(asyncItems);
    if (mapfn !== undefined) mapfn = bind$1(mapfn, thisArg);
    var usingAsyncIterator = getMethod(O, ASYNC_ITERATOR);
    var usingSyncIterator = usingAsyncIterator ? undefined : getIteratorMethod(O) || safeArrayIterator;
    var A = isConstructor(C) ? new C() : [];
    var iterator = usingAsyncIterator
      ? getAsyncIterator(O, usingAsyncIterator)
      : new AsyncFromSyncIterator(getIteratorDirect(getIterator(O, usingSyncIterator)));
    resolve(toArray(iterator, mapfn, A));
  });
};

// TODO: Remove from `core-js@4`
var getBuiltIn = getBuiltIn$c;
var aConstructor = aConstructor$3;
var arrayFromAsync = arrayFromAsync$1;
var ArrayBufferViewCore$4 = arrayBufferViewCore;
var arrayFromConstructorAndList$2 = arrayFromConstructorAndList$5;

var aTypedArrayConstructor = ArrayBufferViewCore$4.aTypedArrayConstructor;
var exportTypedArrayStaticMethod = ArrayBufferViewCore$4.exportTypedArrayStaticMethod;

// `%TypedArray%.fromAsync` method
// https://github.com/tc39/proposal-array-from-async
exportTypedArrayStaticMethod('fromAsync', function fromAsync(asyncItems /* , mapfn = undefined, thisArg = undefined */) {
  var C = this;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var thisArg = argumentsLength > 2 ? arguments[2] : undefined;
  return new (getBuiltIn('Promise'))(function (resolve) {
    aConstructor(C);
    resolve(arrayFromAsync(asyncItems, mapfn, thisArg));
  }).then(function (list) {
    return arrayFromConstructorAndList$2(aTypedArrayConstructor(C), list);
  });
}, true);

// TODO: Remove from `core-js@4`
var ArrayBufferViewCore$3 = arrayBufferViewCore;
var $filterReject$1 = arrayIteration.filterReject;
var fromSpeciesAndList$1 = typedArrayFromSpeciesAndList;

var aTypedArray$3 = ArrayBufferViewCore$3.aTypedArray;
var exportTypedArrayMethod$3 = ArrayBufferViewCore$3.exportTypedArrayMethod;

// `%TypedArray%.prototype.filterOut` method
// https://github.com/tc39/proposal-array-filtering
exportTypedArrayMethod$3('filterOut', function filterOut(callbackfn /* , thisArg */) {
  var list = $filterReject$1(aTypedArray$3(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  return fromSpeciesAndList$1(this, list);
}, true);

var ArrayBufferViewCore$2 = arrayBufferViewCore;
var $filterReject = arrayIteration.filterReject;
var fromSpeciesAndList = typedArrayFromSpeciesAndList;

var aTypedArray$2 = ArrayBufferViewCore$2.aTypedArray;
var exportTypedArrayMethod$2 = ArrayBufferViewCore$2.exportTypedArrayMethod;

// `%TypedArray%.prototype.filterReject` method
// https://github.com/tc39/proposal-array-filtering
exportTypedArrayMethod$2('filterReject', function filterReject(callbackfn /* , thisArg */) {
  var list = $filterReject(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  return fromSpeciesAndList(this, list);
}, true);

var bind = functionBindContext;
var uncurryThis$4 = functionUncurryThis;
var IndexedObject = indexedObject;
var toObject$1 = toObject$b;
var toPropertyKey = toPropertyKey$5;
var lengthOfArrayLike$1 = lengthOfArrayLike$i;
var objectCreate = objectCreate$1;
var arrayFromConstructorAndList$1 = arrayFromConstructorAndList$5;

var $Array = Array;
var push$1 = uncurryThis$4([].push);

var arrayGroup = function ($this, callbackfn, that, specificConstructor) {
  var O = toObject$1($this);
  var self = IndexedObject(O);
  var boundFunction = bind(callbackfn, that);
  var target = objectCreate(null);
  var length = lengthOfArrayLike$1(self);
  var index = 0;
  var Constructor, key, value;
  for (;length > index; index++) {
    value = self[index];
    key = toPropertyKey(boundFunction(value, index, O));
    // in some IE versions, `hasOwnProperty` returns incorrect result on integer keys
    // but since it's a `null` prototype object, we can safely use `in`
    if (key in target) push$1(target[key], value);
    else target[key] = [value];
  }
  // TODO: Remove this block from `core-js@4`
  if (specificConstructor) {
    Constructor = specificConstructor(O);
    if (Constructor !== $Array) {
      for (key in target) target[key] = arrayFromConstructorAndList$1(Constructor, target[key]);
    }
  } return target;
};

// TODO: Remove from `core-js@4`
var ArrayBufferViewCore$1 = arrayBufferViewCore;
var $group = arrayGroup;
var typedArraySpeciesConstructor = typedArraySpeciesConstructor$5;

var aTypedArray$1 = ArrayBufferViewCore$1.aTypedArray;
var exportTypedArrayMethod$1 = ArrayBufferViewCore$1.exportTypedArrayMethod;

// `%TypedArray%.prototype.groupBy` method
// https://github.com/tc39/proposal-array-grouping
exportTypedArrayMethod$1('groupBy', function groupBy(callbackfn /* , thisArg */) {
  var thisArg = arguments.length > 1 ? arguments[1] : undefined;
  return $group(aTypedArray$1(this), callbackfn, thisArg, typedArraySpeciesConstructor);
}, true);

var uncurryThis$3 = functionUncurryThis;

// eslint-disable-next-line es/no-map -- safe
var MapPrototype$1 = Map.prototype;

var mapHelpers = {
  // eslint-disable-next-line es/no-map -- safe
  Map: Map,
  set: uncurryThis$3(MapPrototype$1.set),
  get: uncurryThis$3(MapPrototype$1.get),
  has: uncurryThis$3(MapPrototype$1.has),
  remove: uncurryThis$3(MapPrototype$1['delete']),
  proto: MapPrototype$1
};

var call = functionCall;

var iterateSimple$1 = function (iterator, fn, $next) {
  var next = $next || iterator.next;
  var step, result;
  while (!(step = call(next, iterator)).done) {
    result = fn(step.value);
    if (result !== undefined) return result;
  }
};

var uncurryThis$2 = functionUncurryThis;
var iterateSimple = iterateSimple$1;
var MapHelpers$1 = mapHelpers;

var Map$2 = MapHelpers$1.Map;
var MapPrototype = MapHelpers$1.proto;
var forEach$1 = uncurryThis$2(MapPrototype.forEach);
var entries = uncurryThis$2(MapPrototype.entries);
var next = entries(new Map$2()).next;

var mapIterate = function (map, fn, interruptible) {
  return interruptible ? iterateSimple(entries(map), function (entry) {
    return fn(entry[1], entry[0]);
  }, next) : forEach$1(map, fn);
};

var uncurryThis$1 = functionUncurryThis;
var aCallable = aCallable$d;
var isNullOrUndefined = isNullOrUndefined$7;
var lengthOfArrayLike = lengthOfArrayLike$i;
var toObject = toObject$b;
var MapHelpers = mapHelpers;
var iterate = mapIterate;

var Map$1 = MapHelpers.Map;
var mapHas = MapHelpers.has;
var mapSet = MapHelpers.set;
var push = uncurryThis$1([].push);

// `Array.prototype.uniqueBy` method
// https://github.com/tc39/proposal-array-unique
var arrayUniqueBy$1 = function uniqueBy(resolver) {
  var that = toObject(this);
  var length = lengthOfArrayLike(that);
  var result = [];
  var map = new Map$1();
  var resolverFunction = !isNullOrUndefined(resolver) ? aCallable(resolver) : function (value) {
    return value;
  };
  var index, item, key;
  for (index = 0; index < length; index++) {
    item = that[index];
    key = resolverFunction(item);
    if (!mapHas(map, key)) mapSet(map, key, item);
  }
  iterate(map, function (value) {
    push(result, value);
  });
  return result;
};

var uncurryThis = functionUncurryThis;
var ArrayBufferViewCore = arrayBufferViewCore;
var arrayFromConstructorAndList = arrayFromConstructorAndList$5;
var $arrayUniqueBy = arrayUniqueBy$1;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var arrayUniqueBy = uncurryThis($arrayUniqueBy);

// `%TypedArray%.prototype.uniqueBy` method
// https://github.com/tc39/proposal-array-unique
exportTypedArrayMethod('uniqueBy', function uniqueBy(resolver) {
  aTypedArray(this);
  return arrayFromConstructorAndList(getTypedArrayConstructor(this), arrayUniqueBy(this, resolver));
}, true);

var CLICK_BEHAVIOR_DESTROY_PARTICLE = 1;
var SPRITE_VERTEX_STRIDE = 6;
var VFX_ITEM_TYPE_TREE = 'tree';
var SEMANTIC_PRE_COLOR_ATTACHMENT_0 = 'PRE_COLOR_0';
var SEMANTIC_PRE_COLOR_ATTACHMENT_SIZE_0 = 'PRE_COLOR_SIZE_0';
var SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_0 = 'PRE_MAIN_COLOR_0';
var SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_SIZE_0 = 'PRE_MAIN_COLOR_SIZE_0';
var PLAYER_OPTIONS_ENV_EDITOR = 'editor';
var FILTER_NAME_NONE = 'none';
var DEG2RAD = 0.017453292519943295;
var HELP_LINK$1 = {
    'Filter not imported': 'https://yuque.antfin.com/huoxing/knaszl/qtnsf2g9ofigggor#n4Y1K',
    'Item duration can\'t be less than 0': 'https://yuque.antfin.com/huoxing/knaszl/wozlz0#vFPqF',
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values$1(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read$1(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * Helper class to create a WebGL Context
 *
 * @param canvas
 * @param glType
 * @param options
 * @returns
 */
function createGLContext(canvas, glType, options) {
    if (glType === void 0) { glType = 'webgl'; }
    var context;
    if (glType === 'webgl2') {
        context = canvas.getContext('webgl2', options);
        if (!context) {
            console.debug('WebGL2 context retrieval failed, falling back to WebGL context.');
        }
    }
    if (!context || glType === 'webgl') {
        context = canvas.getContext('webgl', options);
    }
    if (!context) {
        throw new Error('This browser does not support WebGL or the WebGL version is incorrect. Please check your WebGL version.');
    }
    return context;
}

function gpuTimer(gl) {
    var _this = this;
    var ext = gl.getExtension('EXT_disjoint_timer_query_webgl2');
    if (ext) {
        var query_1 = gl.createQuery();
        var getTime_1 = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        if (query_1) {
                            var available = gl.getQueryParameter(query_1, gl.QUERY_RESULT_AVAILABLE);
                            var disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
                            if (available && !disjoint) {
                                // See how much time the rendering of the object took in nanoseconds.
                                var timeElapsed = gl.getQueryParameter(query_1, gl.QUERY_RESULT); // Do something useful with the time.  Note that care should be
                                // taken to use all significant bits of the result, not just the
                                // least significant 32 bits.
                                resolve(timeElapsed / 1000 / 1000);
                            }
                            if (available || disjoint) {
                                // Clean up the query object.
                                gl.deleteQuery(query_1); // Don't re-enter this polling loop.
                                query_1 = null;
                            }
                            available !== null && query_1 && window.setTimeout(function () {
                                getTime_1().then(resolve).catch;
                            }, 1);
                        }
                    })];
            });
        }); };
        if (!query_1) {
            return;
        }
        return {
            begin: function () {
                query_1 && gl.beginQuery(ext.TIME_ELAPSED_EXT, query_1);
            },
            end: function () {
                gl.endQuery(ext.TIME_ELAPSED_EXT);
            },
            getTime: getTime_1,
        };
    }
}

// @ts-expect-error
var glContext = {};
// 重要：iOS 9/10 低版本需要拷贝 gl context 的 prototype，要不然会有属性值的缺失
if (typeof WebGL2RenderingContext === 'function') {
    copy(WebGL2RenderingContext);
}
else if (typeof WebGLRenderingContext !== 'undefined') {
    copy(WebGLRenderingContext);
    copy(WebGLRenderingContext.prototype);
}
else {
    // iOS 16 lockdown mode
    throw new Error('WebGL Constants not in global');
}
if (!('HALF_FLOAT' in glContext)) {
    // @ts-expect-error set default value
    glContext['HALF_FLOAT'] = 5131;
}
function isWebGL2(gl) {
    return typeof WebGL2RenderingContext !== 'undefined' && gl.constructor.name === 'WebGL2RenderingContext';
}
function copy(target) {
    for (var name_1 in target) {
        if (/^[A-Z_]/.test(name_1)) {
            // @ts-expect-error safe to assign
            glContext[name_1] = target[name_1];
        }
    }
}

var filterFuncMap = {};
var filterShaderFuncMap = {};
/**
 * 注册滤镜
 * @param name - 滤镜名
 * @param func - 函数，用于在创建 Mesh 前执行
 * @param shaderFunc - 函数，用于获取创建 shader 文本的参数
 */
function registerFilter(name, func, shaderFunc) {
    if (name in filterFuncMap) {
        console.error("Filter ".concat(name, " registered twice."));
    }
    filterFuncMap[name] = func;
    filterShaderFuncMap[name] = shaderFunc;
}
/**
 * 批量注册插件
 * @param filters
 */
function registerFilters(filters) {
    Object.keys(filters).forEach(function (name) {
        var _a = __read$1(filters[name], 2), register = _a[0], createShaderDefine = _a[1];
        registerFilter(name, register, createShaderDefine);
    });
}
/**
 * 执行注册的 shader 回调，创建滤镜的 shader
 * @param filter - `filterShaderFunc` 回调函数的参数
 */
function createFilterShaders(filter) {
    var func = filterShaderFuncMap[filter.name];
    if (!func) {
        throw Error("Filter ".concat(filter.name, " not imported, see ").concat(HELP_LINK$1['Filter not imported']));
    }
    return func(filter);
}
/**
 * 获取滤镜需要在 Mesh 中传递的参数和在 renderPass 中的回调
 * @param filter - `filterFunc` 回调的参数
 * @param composition - 合成对象
 */
function createFilter(filter, composition) {
    var func = filterFuncMap[filter.name];
    if (!func) {
        throw Error("Filter ".concat(filter.name, " not imported, see ").concat(HELP_LINK$1['Filter not imported']));
    }
    var ret = func(filter, composition);
    if (!ret.passSplitOptions) {
        ret.passSplitOptions = {
            attachments: [{ texture: { format: glContext.RGBA } }],
        };
    }
    return ret;
}

function addItem(arr, value) {
    if (!arr.includes(value)) {
        arr.push(value);
    }
    return arr;
}
/**
 * 性能测试：https://blog.mutoe.com/2019/compare-filter-vs-splice-in-javascript/
 * @param arr
 * @param value
 * @returns
 */
function removeItem(arr, value) {
    var index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
    }
    return arr;
}
/**
 * 原 arrAddWithOrder 根据property的大小在arr中插入item
 * @param arr
 * @param item
 * @param property
 * @param descending
 * @returns
 */
function addItemWithOrder(arr, item, property, descending) {
    if (descending === void 0) { descending = false; }
    if (arr.includes(item)) {
        return;
    }
    arr.push(item);
    if (arr.length === 1) {
        return;
    }
    //单次插入排序
    var index = arr.length - 1;
    if (index) {
        var currentItem = arr[index];
        if (descending) {
            while (arr[index - 1][property] < currentItem[property]) {
                arr[index] = arr[index - 1];
                index--;
                if (index === 0) {
                    break;
                }
            }
        }
        else {
            while (arr[index - 1][property] > currentItem[property]) {
                arr[index] = arr[index - 1];
                index--;
                if (index === 0) {
                    break;
                }
            }
        }
        arr[index] = currentItem;
    }
}
function enlargeBuffer(typeArray, length, increase, maxSize) {
    if (increase === void 0) { increase = 1; }
    var buffer = typeArray.buffer;
    if (buffer.byteLength < typeArray.BYTES_PER_ELEMENT * length) {
        var size = Math.ceil(length * increase);
        if (!isNaN(maxSize)) {
            size = Math.min(size, maxSize);
        }
        var nbuffer = new ArrayBuffer(typeArray.BYTES_PER_ELEMENT * size);
        var nArr = new typeArray.constructor(nbuffer);
        nArr.set(typeArray);
        return nArr;
    }
    return typeArray;
}

function colorToArr$1(hex, normalized) {
    var ret = [0, 0, 0, 0];
    if (isString(hex)) {
        hex = hex.replace(/[\s\t\r\n]/g, '');
        var m = /rgba?\(([.\d]+),([.\d]+),([.\d]+),?([.\d]+)?\)/.exec(hex);
        if (m) {
            var a = +m[4];
            ret = [+m[1], +m[2], +m[3], isNaN(a) ? 255 : a * 255];
        }
        else if (/^#[a-f\d]{3}$/i.test(hex)) {
            ret = [parseInt(hex[1] + hex[1], 16), parseInt(hex[2] + hex[2], 16), parseInt(hex[3] + hex[3], 16), 255];
            // eslint-disable-next-line no-cond-assign
        }
        else if (m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)) {
            ret = [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 255] || [0, 0, 0, 255];
        }
    }
    else if (hex instanceof Array) {
        ret = [hex[0], hex[1], hex[2], isNaN(hex[3]) ? 255 : hex[3]];
    }
    if (normalized) {
        for (var i = 0; i < 4; i++) {
            ret[i] /= 255;
        }
    }
    return ret;
}
function getColorFromGradientStops(stops, key, normalize) {
    if (stops.length) {
        var color = void 0;
        for (var j = 1; j <= stops.length - 1; j++) {
            var s0 = stops[j - 1];
            var s1 = stops[j];
            if (s0.stop <= key && key <= s1.stop) {
                color = interpolateColor(s0.color, s1.color, (key - s0.stop) / (s1.stop - s0.stop));
                break;
            }
        }
        if (!color) {
            color = stops[stops.length - 1].color;
        }
        return normalize ? color.map(function (n) { return n / 255; }) : color;
    }
    return [0, 0, 0, 0];
}
function colorStopsFromGradient(gradient) {
    var stops = [];
    if (gradient instanceof Array) {
        gradient.forEach(function (val) {
            var _a = __read$1(val, 5), s = _a[0], r = _a[1], g = _a[2], b = _a[3], a = _a[4];
            stops.push({
                // TODO
                // @ts-expect-error
                stop: parsePercent$1(s),
                color: [r, g, b, a],
            });
        });
    }
    else {
        Object.keys(gradient).forEach(function (stop) {
            var colorRGB = gradient[stop];
            var color = colorToArr$1(colorRGB);
            stops.push({
                stop: parsePercent$1(stop),
                color: color,
            });
        });
    }
    stops = stops.sort(function (a, b) { return a.stop - b.stop; });
    if (stops.length) {
        if (stops[0].stop !== 0) {
            stops.unshift({ stop: 0, color: stops[0].color.slice() });
        }
        var lastStop = stops[stops.length - 1];
        if (lastStop.stop !== 1) {
            stops.push({ stop: 1, color: lastStop.color.slice() });
        }
    }
    return stops;
}
function interpolateColor(a, b, s, origin) {
    var ret = [];
    var ms = 1 - s;
    if (origin) {
        for (var i = 0; i < 4; i++) {
            ret[i] = a[i] * ms + b[i] * s;
        }
    }
    else {
        for (var i = 0; i < 3; i++) {
            ret[i] = Math.round(Math.sqrt(a[i] * a[i] * ms + b[i] * b[i] * s));
        }
        ret[3] = Math.round(a[3] * ms + b[3] * s);
    }
    return ret;
}
function parsePercent$1(c) {
    var match = /^(-)?([\d+.]+)%$/.exec(c);
    if (match) {
        return +match[2] / 100 * (match[1] ? -1 : 1);
    }
    return +c;
}

function getPixelRatio() {
    if (typeof screen === 'object' && typeof document === 'object') {
        var viewportWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        var screenWidth = screen.width;
        var viewportScale = screenWidth / viewportWidth;
        return Math.min(2 * viewportScale, 2);
    }
    return 1;
}
function isIOS() {
    // real ios device not in simulator
    return !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);
}
function isAndroid() {
    return /\b[Aa]ndroid\b/.test(navigator.userAgent);
}
function isSimulatorCellPhone() {
    return isAndroid() || /\b(iPad|iPhone|iPod)\b/.test(navigator.userAgent);
}

function imageDataFromColor(value) {
    if (isString(value)) {
        value = colorToArr$1(value);
    }
    var color = value;
    var image = {
        width: 1,
        height: 1,
        data: new Uint8Array(1 * 1 * 4),
    };
    var data = image.data;
    for (var i = 0; i < 4; i++) {
        data[i] = color[i];
    }
    return image;
}
function imageDataFromGradient(gradient) {
    var width = 128;
    var image = {
        width: width,
        height: 1,
        data: new Uint8Array(width * 1 * 4),
    };
    var data = image.data;
    var stops = colorStopsFromGradient(gradient);
    if (stops.length) {
        data.set(stops[0].color, 0);
        for (var i = 1, cursor = 0; i < width - 1; i++) {
            var index = i / width;
            var s0 = void 0;
            var s1 = void 0;
            for (var j = cursor; j < stops.length; j++) {
                s0 = stops[j];
                s1 = stops[j + 1];
                if (s0.stop <= index && s1.stop > index) {
                    break;
                }
            }
            var color = interpolateColor(s0.color, s1.color, (index - s0.stop) / (s1.stop - s0.stop));
            data.set(color, i * 4);
        }
        data.set(stops[stops.length - 1].color, (width - 1) * 4);
    }
    return image;
}

exports.OrderType = void 0;
(function (OrderType) {
    OrderType[OrderType["none"] = 1] = "none";
    OrderType[OrderType["ascending"] = 2] = "ascending";
    OrderType[OrderType["descending"] = 3] = "descending";
})(exports.OrderType || (exports.OrderType = {}));
Array.prototype.sortByOrder = function (order) {
    if (order === void 0) { order = exports.OrderType.ascending; }
    var length = this.length;
    if (length <= 1 ||
        order === exports.OrderType.none) {
        return this;
    }
    if (length <= 30) {
        for (var i = 1; i < length; i++) {
            insertionSort(this, i, order);
        }
        return this;
    }
    else {
        return fastSort(this, order);
    }
};
/**
 * @param item
 * @param order
 * @returns
 */
Array.prototype.addByOrder = function (item, order) {
    if (order === void 0) { order = exports.OrderType.ascending; }
    if (this.includes(item)) {
        return this;
    }
    this.push(item);
    if (this.length === 1) {
        return this;
    }
    if (order !== exports.OrderType.none) {
        // 单次插入排序
        insertionSort(this, this.length - 1, order);
    }
    return this;
};
function insertionSort(array, index, order) {
    var currentItem = array[index];
    if (order !== exports.OrderType.ascending) {
        while (index >= 1 && array[index - 1].priority < currentItem.priority) {
            array[index] = array[index - 1];
            index--;
            if (index === 0) {
                break;
            }
        }
    }
    else {
        while (index >= 1 && array[index - 1].priority > currentItem.priority) {
            array[index] = array[index - 1];
            index--;
            if (index === 0) {
                break;
            }
        }
    }
    array[index] = currentItem;
}
function fastSort(arr, order, start, end) {
    var _a, _b;
    if (start === void 0) { start = 0; }
    if (end === void 0) { end = arr.length - 1; }
    // 终止条件
    if (start >= end) {
        return arr;
    }
    var base = arr[start];
    var left = start;
    var right = end;
    while (left < right) {
        if (order === exports.OrderType.ascending) {
            // 从右向左，寻找第一个小于base的值
            while (arr[right].priority > base.priority && right >= left) {
                right--;
            }
            // 从左向右，寻找第一个大于base的值
            while (arr[left].priority <= base.priority && left < right) {
                left++;
            }
        }
        else {
            // 从右向左，寻找第一个大于base的值
            while (arr[right].priority < base.priority && right >= left) {
                right--;
            }
            // 从左向右，寻找第一个小于base的值
            while (arr[left].priority >= base.priority && left < right) {
                left++;
            }
        }
        // 将两个值交换位置
        _a = __read$1([arr[right], arr[left]], 2), arr[left] = _a[0], arr[right] = _a[1];
    }
    // 将最后两个游标相遇的位置的值与base值交换
    _b = __read$1([arr[left], arr[start]], 2), arr[start] = _b[0], arr[left] = _b[1];
    fastSort(arr, order, start, left - 1);
    fastSort(arr, order, right + 1, end);
    return arr;
}

function assertExist(item, msg) {
    if (msg === void 0) { msg = 'item doesn\'t exist'; }
    if (item === undefined || item === null) {
        throw new Error(msg);
    }
}
function asserts(condition, msg) {
    if (msg === void 0) { msg = 'asserts failed'; }
    if (!condition) {
        throw new Error(msg);
    }
}

exports.DestroyOptions = void 0;
(function (DestroyOptions) {
    DestroyOptions[DestroyOptions["destroy"] = 0] = "destroy";
    DestroyOptions[DestroyOptions["keep"] = 1] = "keep";
    DestroyOptions[DestroyOptions["force"] = 0] = "force";
})(exports.DestroyOptions || (exports.DestroyOptions = {}));
function noop() {
}
/**
 * 判断对象是否是`String`类型
 *
 * @static
 * @function isString
 * @param {object} obj - 要判断的对象
 * @return {boolean}
 */
function isString(obj) {
    return typeof obj === 'string';
}
/**
 * 判断对象是否是`Array`类型
 *
 * @static
 * @function isArray
 * @param {object} obj - 要判断的对象
 * @return {boolean}
 */
var isArray = (Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
});
/**
 * 判断对象是否是函数类型
 *
 * @static
 * @function isFunction
 * @param {object} obj - 要判断的对象
 * @return {boolean}
 */
function isFunction(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
}
/**
 * 判断对象是否是`Object`类型
 *
 * @static
 * @function isObject
 * @param {object} obj - 要判断的对象
 * @return {boolean}
 */
function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
}
function deepClone(obj) {
    if (isArray(obj)) {
        return obj.map(deepClone);
    }
    else if (obj && typeof obj === 'object') {
        if (ArrayBuffer.isView(obj)) {
            return obj.slice();
        }
        var ret = {};
        var kas = Object.keys(obj);
        for (var i = 0; i < kas.length; i++) {
            var key = kas[i];
            ret[key] = deepClone(obj[key]);
        }
        return ret;
    }
    return obj;
}
// TODO: 改名
function random(min, max) {
    return min + Math.random() * (max - min);
}
function throwDestroyedError$1() {
    throw Error('destroyed item cannot be used again');
}

/*!
 * Name: @ali/specification
 * Description: Mars JSON Specification
 * Author: Ant Group CO., Ltd.
 * Version: v2.0.0-alpha.4
 */

/*********************************************/
/*               元素属性参数类型               */
/*********************************************/
/**
 * 渲染等级
 */
var RenderLevel$1;
(function (RenderLevel) {
    RenderLevel["S"] = "S";
    RenderLevel["APlus"] = "A+";
    RenderLevel["A"] = "A";
    RenderLevel["BPlus"] = "B+";
    RenderLevel["B"] = "B";
})(RenderLevel$1 || (RenderLevel$1 = {}));
/**
 * 混合模式
 */
var BlendingMode$1;
(function (BlendingMode) {
    /**
     * 普通混合模式
     */
    BlendingMode[BlendingMode["ALPHA"] = 0] = "ALPHA";
    /**
     * 叠加混合模式
     */
    BlendingMode[BlendingMode["ADD"] = 1] = "ADD";
    /**
     * 相乘混合模式
     */
    BlendingMode[BlendingMode["MULTIPLY"] = 2] = "MULTIPLY";
    /**
     * 亮度混合模式
     */
    BlendingMode[BlendingMode["BRIGHTNESS"] = 3] = "BRIGHTNESS";
    /**
     * 减色混合模式
     */
    BlendingMode[BlendingMode["SUBTRACTION"] = 4] = "SUBTRACTION";
    /**
     * 强光混合模式
     */
    BlendingMode[BlendingMode["STRONG_LIGHT"] = 5] = "STRONG_LIGHT";
    /**
     * 弱光混合模式
     */
    BlendingMode[BlendingMode["WEAK_LIGHT"] = 6] = "WEAK_LIGHT";
    /**
     * 亮度叠加混合模式
     */
    BlendingMode[BlendingMode["SUPERPOSITION"] = 7] = "SUPERPOSITION";
})(BlendingMode$1 || (BlendingMode$1 = {}));
/**
 * 单双面模式
 */
var SideMode$1;
(function (SideMode) {
    /**
     * 双面模式
     */
    SideMode[SideMode["DOUBLE"] = 1032] = "DOUBLE";
    /**
     * 正面模式
     */
    SideMode[SideMode["FRONT"] = 1028] = "FRONT";
    /**
     * 背面模式
     */
    SideMode[SideMode["BACK"] = 1029] = "BACK";
})(SideMode$1 || (SideMode$1 = {}));
/**
 * 蒙版模式
 */
var MaskMode$1;
(function (MaskMode) {
    /**
     * 无蒙版
     */
    MaskMode[MaskMode["NONE"] = 0] = "NONE";
    /**
     * 蒙版
     */
    MaskMode[MaskMode["MASK"] = 1] = "MASK";
    /**
     * 被遮挡
     */
    MaskMode[MaskMode["OBSCURED"] = 2] = "OBSCURED";
    /**
     * 被反向遮挡
     */
    MaskMode[MaskMode["REVERSE_OBSCURED"] = 3] = "REVERSE_OBSCURED";
})(MaskMode$1 || (MaskMode$1 = {}));
/**
 * 发射器形状
 */
var ShapeType$1;
(function (ShapeType) {
    /**
     * 没有类型
     */
    ShapeType[ShapeType["NONE"] = 0] = "NONE";
    /**
     * 圆球
     */
    ShapeType[ShapeType["SPHERE"] = 1] = "SPHERE";
    /**
     * 圆锥
     */
    ShapeType[ShapeType["CONE"] = 2] = "CONE";
    /**
     * 半球
     */
    ShapeType[ShapeType["HEMISPHERE"] = 3] = "HEMISPHERE";
    /**
     * 圆
     */
    ShapeType[ShapeType["CIRCLE"] = 4] = "CIRCLE";
    /**
     * 圆环
     */
    ShapeType[ShapeType["DONUT"] = 5] = "DONUT";
    /**
     * 矩形
     */
    ShapeType[ShapeType["RECTANGLE"] = 6] = "RECTANGLE";
    /**
     * 矩形框
     */
    ShapeType[ShapeType["RECTANGLE_EDGE"] = 7] = "RECTANGLE_EDGE";
    /**
     * 直线
     */
    ShapeType[ShapeType["EDGE"] = 8] = "EDGE";
    /**
     * 贴图
     */
    ShapeType[ShapeType["TEXTURE"] = 9] = "TEXTURE";
})(ShapeType$1 || (ShapeType$1 = {}));
/**
 * 插件类型
 */
var PluginType$1;
(function (PluginType) {
    /**
     * 陀螺仪
     */
    PluginType[PluginType["GYROSCOPE"] = 0] = "GYROSCOPE";
    /**
     * Spine
     */
    PluginType[PluginType["SPINE"] = 1] = "SPINE";
})(PluginType$1 || (PluginType$1 = {}));
/**
 * 交互类型
 */
var InteractType$1;
(function (InteractType) {
    /**
     * 点击
     */
    InteractType[InteractType["CLICK"] = 0] = "CLICK";
    /**
     * 消息
     * 前端收到 onMessageItem 回调
     */
    InteractType[InteractType["MESSAGE"] = 1] = "MESSAGE";
    /**
     * 拖拽
     */
    InteractType[InteractType["DRAG"] = 2] = "DRAG";
})(InteractType$1 || (InteractType$1 = {}));
/**
 * 交互行为
 */
var InteractBehavior$2;
(function (InteractBehavior) {
    /**
     * 无
     */
    InteractBehavior[InteractBehavior["NONE"] = 0] = "NONE";
    /**
     * 通知
     */
    InteractBehavior[InteractBehavior["NOTIFY"] = 1] = "NOTIFY";
    /**
     * 重置播放器
     */
    InteractBehavior[InteractBehavior["RESUME_PLAYER"] = 2] = "RESUME_PLAYER";
    /**
     * 清除元素
     */
    InteractBehavior[InteractBehavior["REMOVE"] = 3] = "REMOVE";
    /**
     * 暂停播放器
     */
    InteractBehavior[InteractBehavior["PAUSE"] = 4] = "PAUSE";
})(InteractBehavior$2 || (InteractBehavior$2 = {}));
/**
 * 元素类型
 */
var ItemType$1;
(function (ItemType) {
    /**
     * 错误元素
     */
    ItemType["base"] = "0";
    /**
     * 图层元素
     */
    ItemType["sprite"] = "1";
    /**
     * 粒子元素
     */
    ItemType["particle"] = "2";
    /**
     * 空节点元素
     */
    ItemType["null"] = "3";
    /**
     * 交互元素
     */
    ItemType["interact"] = "4";
    /**
     * 插件元素
     */
    ItemType["plugin"] = "5";
    /**
     * 相机元素
     */
    ItemType["camera"] = "6";
    /**
     * 预合成元素
     */
    ItemType["composition"] = "7";
    /**
     * 滤镜图层
     */
    ItemType["filter"] = "8";
    /**
     * Spine 元素
     */
    ItemType["spine"] = "spine";
})(ItemType$1 || (ItemType$1 = {}));
/**
 * 渲染模式
 */
var RenderMode$1;
(function (RenderMode) {
    /**
     * 广告牌模式
     */
    RenderMode[RenderMode["BILLBOARD"] = 0] = "BILLBOARD";
    /**
     * 网格模式
     */
    RenderMode[RenderMode["MESH"] = 1] = "MESH";
    /**
     * 垂直广告牌模式
     */
    RenderMode[RenderMode["VERTICAL_BILLBOARD"] = 2] = "VERTICAL_BILLBOARD";
    /**
     * 水平广告牌模式
     */
    RenderMode[RenderMode["HORIZONTAL_BILLBOARD"] = 3] = "HORIZONTAL_BILLBOARD";
})(RenderMode$1 || (RenderMode$1 = {}));
/**
 * 变换中心
 */
var ParticleOrigin$1;
(function (ParticleOrigin) {
    /**
     * 水平和垂直中点
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER"] = 0] = "PARTICLE_ORIGIN_CENTER";
    /**
     * 水平左侧 垂直顶部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_TOP"] = 1] = "PARTICLE_ORIGIN_LEFT_TOP";
    /**
     * 水平左侧 垂直中间
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_CENTER"] = 2] = "PARTICLE_ORIGIN_LEFT_CENTER";
    /**
     * 水平左侧 垂直底部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_BOTTOM"] = 3] = "PARTICLE_ORIGIN_LEFT_BOTTOM";
    /**
     * 水平中间 垂直顶部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER_TOP"] = 4] = "PARTICLE_ORIGIN_CENTER_TOP";
    /**
     * 水平中间 垂直底部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER_BOTTOM"] = 5] = "PARTICLE_ORIGIN_CENTER_BOTTOM";
    /**
     * 水平右侧 垂直顶部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_TOP"] = 6] = "PARTICLE_ORIGIN_RIGHT_TOP";
    /**
     * 水平右侧 垂直中间
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_CENTER"] = 7] = "PARTICLE_ORIGIN_RIGHT_CENTER";
    /**
     * 水平右侧 垂直底部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_BOTTOM"] = 8] = "PARTICLE_ORIGIN_RIGHT_BOTTOM";
})(ParticleOrigin$1 || (ParticleOrigin$1 = {}));

var END_BEHAVIOR_DESTROY$1 = 0;
var END_BEHAVIOR_PAUSE$1 = 1;
var END_BEHAVIOR_FORWARD$1 = 2;
var END_BEHAVIOR_PAUSE_AND_DESTROY$1 = 3;
var END_BEHAVIOR_FREEZE$1 = 4;
var END_BEHAVIOR_RESTART$1 = 5;
var END_BEHAVIOR_DESTROY_CHILDREN$1 = 6;
var CAMERA_CLIP_MODE_VERTICAL$1 = 1;
var CAMERA_CLIP_MODE_NORMAL$1 = 0;
var MESSAGE_ITEM_PHRASE_BEGIN = 2;
var MESSAGE_ITEM_PHRASE_END = 1;

var CameraClipMode$1;
(function (CameraClipMode) {
    /**
     * 剪裁上下
     */
    CameraClipMode[CameraClipMode["portrait"] = CAMERA_CLIP_MODE_VERTICAL$1] = "portrait";
    /**
     * 剪裁左右
     */
    CameraClipMode[CameraClipMode["landscape"] = CAMERA_CLIP_MODE_NORMAL$1] = "landscape";
})(CameraClipMode$1 || (CameraClipMode$1 = {}));
/**
 * 结束行为
 */
var CompositionEndBehavior$1;
(function (CompositionEndBehavior) {
    /**
     * 销毁
     */
    CompositionEndBehavior[CompositionEndBehavior["destroy"] = END_BEHAVIOR_DESTROY$1] = "destroy";
    /**
     * 暂停
     */
    CompositionEndBehavior[CompositionEndBehavior["pause"] = END_BEHAVIOR_PAUSE$1] = "pause";
    /**
     * 重播
     */
    CompositionEndBehavior[CompositionEndBehavior["restart"] = END_BEHAVIOR_RESTART$1] = "restart";
    /**
     * 无限播放
     */
    CompositionEndBehavior[CompositionEndBehavior["forward"] = END_BEHAVIOR_FORWARD$1] = "forward";
    /**
     * 销毁并保留最后一帧
     */
    CompositionEndBehavior[CompositionEndBehavior["pause_destroy"] = END_BEHAVIOR_PAUSE_AND_DESTROY$1] = "pause_destroy";
})(CompositionEndBehavior$1 || (CompositionEndBehavior$1 = {}));

/*********************************************/
/*               基本数值属性参数              */
/*********************************************/
var ValueType$1;
(function (ValueType) {
    /**
     * 常数
     */
    ValueType[ValueType["CONSTANT"] = 0] = "CONSTANT";
    /**
     * 二维常数向量
     */
    ValueType[ValueType["CONSTANT_VEC2"] = 1] = "CONSTANT_VEC2";
    /**
     * 三维常数向量
     */
    ValueType[ValueType["CONSTANT_VEC3"] = 2] = "CONSTANT_VEC3";
    /**
     * 四维常数向量
     */
    ValueType[ValueType["CONSTANT_VEC4"] = 3] = "CONSTANT_VEC4";
    /**
     * 随机数
     */
    ValueType[ValueType["RANDOM"] = 4] = "RANDOM";
    /**
     * 直线
     */
    ValueType[ValueType["LINE"] = 5] = "LINE";
    /**
     * 曲线
     */
    ValueType[ValueType["CURVE"] = 6] = "CURVE";
    /**
     * 贝塞尔路径
     */
    ValueType[ValueType["BEZIER_PATH"] = 7] = "BEZIER_PATH";
    /**
     * 颜色
     */
    ValueType[ValueType["RGBA_COLOR"] = 8] = "RGBA_COLOR";
    /**
     * 渐变色
     */
    ValueType[ValueType["GRADIENT_COLOR"] = 9] = "GRADIENT_COLOR";
    /**
     * 蒙版形状点集
     */
    ValueType[ValueType["SHAPE_POINTS"] = 10] = "SHAPE_POINTS";
    /**
     * 蒙版形状切分
     */
    ValueType[ValueType["SHAPE_SPLITS"] = 11] = "SHAPE_SPLITS";
    /**
     *直线路径
     */
    ValueType[ValueType["LINEAR_PATH"] = 12] = "LINEAR_PATH";
    /**
     * 多色
     */
    ValueType[ValueType["COLORS"] = 13] = "COLORS";
    /**
     * 二进制指针
     */
    ValueType[ValueType["BINARY"] = 20] = "BINARY";
    /**
     * 贝塞尔曲线
     */
    ValueType[ValueType["BEZIER_CURVE"] = 21] = "BEZIER_CURVE";
    /**
     * 贝塞尔曲线路径
     */
    ValueType[ValueType["BEZIER_CURVE_PATH"] = 22] = "BEZIER_CURVE_PATH";
})(ValueType$1 || (ValueType$1 = {}));
/**
 * 关键帧类型
 */
var BezierKeyframeType$1;
(function (BezierKeyframeType) {
    BezierKeyframeType[BezierKeyframeType["AUTO"] = 0] = "AUTO";
    BezierKeyframeType[BezierKeyframeType["EASE"] = 1] = "EASE";
    BezierKeyframeType[BezierKeyframeType["EASE_IN"] = 2] = "EASE_IN";
    BezierKeyframeType[BezierKeyframeType["EASE_OUT"] = 3] = "EASE_OUT";
    BezierKeyframeType[BezierKeyframeType["LINE"] = 4] = "LINE";
    BezierKeyframeType[BezierKeyframeType["HOLD"] = 5] = "HOLD";
    BezierKeyframeType[BezierKeyframeType["LINE_OUT"] = 6] = "LINE_OUT";
})(BezierKeyframeType$1 || (BezierKeyframeType$1 = {}));

var ItemEndBehavior$1;
(function (ItemEndBehavior) {
    ItemEndBehavior[ItemEndBehavior["destroy"] = END_BEHAVIOR_DESTROY$1] = "destroy";
    ItemEndBehavior[ItemEndBehavior["loop"] = END_BEHAVIOR_RESTART$1] = "loop";
    ItemEndBehavior[ItemEndBehavior["forward"] = END_BEHAVIOR_FREEZE$1] = "forward";
})(ItemEndBehavior$1 || (ItemEndBehavior$1 = {}));
var ParentItemEndBehavior$1;
(function (ParentItemEndBehavior) {
    ParentItemEndBehavior[ParentItemEndBehavior["destroyChildren"] = END_BEHAVIOR_DESTROY_CHILDREN$1] = "destroyChildren";
})(ParentItemEndBehavior$1 || (ParentItemEndBehavior$1 = {}));

/**
 * 粒子交互行为
 */
var ParticleInteractionBehavior$1;
(function (ParticleInteractionBehavior) {
    /**
     * 无
     */
    ParticleInteractionBehavior[ParticleInteractionBehavior["none"] = 0] = "none";
    /**
     * 移出粒子
     */
    ParticleInteractionBehavior[ParticleInteractionBehavior["removeParticle"] = 1] = "removeParticle";
})(ParticleInteractionBehavior$1 || (ParticleInteractionBehavior$1 = {}));

var ShapeArcMode$1;
(function (ShapeArcMode) {
    /**
     * 随机
     */
    ShapeArcMode[ShapeArcMode["RANDOM"] = 0] = "RANDOM";
    /**
     * 单向循环
     */
    ShapeArcMode[ShapeArcMode["UNIDIRECTIONAL_CYCLE"] = 1] = "UNIDIRECTIONAL_CYCLE";
    /**
     * 双向循环
     */
    ShapeArcMode[ShapeArcMode["BIDIRECTIONAL_CYCLE"] = 2] = "BIDIRECTIONAL_CYCLE";
    /**
     * 均匀爆发
     */
    ShapeArcMode[ShapeArcMode["UNIFORM_BURST"] = 3] = "UNIFORM_BURST";
})(ShapeArcMode$1 || (ShapeArcMode$1 = {}));

var BloomFilterThresholdAvgColor = 0;

var ModelBoundingType$1;
(function (ModelBoundingType) {
    ModelBoundingType[ModelBoundingType["box"] = 2] = "box";
    ModelBoundingType[ModelBoundingType["sphere"] = 3] = "sphere";
})(ModelBoundingType$1 || (ModelBoundingType$1 = {}));

// 材质类型
var MaterialType$1;
(function (MaterialType) {
    MaterialType["unlit"] = "unlit";
    MaterialType["pbr"] = "pbr";
    // 头发材质，在 pbr 材质基础上扩展
    MaterialType["hair"] = "hair";
})(MaterialType$1 || (MaterialType$1 = {}));
// 混合模式
var MaterialBlending$1;
(function (MaterialBlending) {
    MaterialBlending[MaterialBlending["opaque"] = 100] = "opaque";
    MaterialBlending[MaterialBlending["masked"] = 101] = "masked";
    MaterialBlending[MaterialBlending["translucent"] = 102] = "translucent";
    MaterialBlending[MaterialBlending["additive"] = 103] = "additive";
})(MaterialBlending$1 || (MaterialBlending$1 = {}));

/**
 * 3D渲染模式：将渲染过程中的中间结果输出，主要用于排查渲染效果问题，支持 pbr 和 unlit 材质
 */
var RenderMode3D$1;
(function (RenderMode3D) {
    /**
     * 正常渲染
     */
    RenderMode3D["none"] = "none";
    /**
     * 纹理坐标
     */
    RenderMode3D["uv"] = "uv";
    /**
     * 世界坐标法线
     */
    RenderMode3D["normal"] = "normal";
    /**
     * 基础颜色
     */
    RenderMode3D["basecolor"] = "basecolor";
    /**
     * 基础颜色 Alpha
     */
    RenderMode3D["alpha"] = "alpha";
    /**
     * 金属度
     */
    RenderMode3D["metallic"] = "metallic";
    /**
     * 粗超度
     */
    RenderMode3D["roughness"] = "roughness";
    /**
     * 环境遮蔽
     */
    RenderMode3D["ao"] = "ao";
    /**
     * 自发光
     */
    RenderMode3D["emissive"] = "emissive";
})(RenderMode3D$1 || (RenderMode3D$1 = {}));

var TextOverflow$1;
(function (TextOverflow) {
    // default, display all text, it may decrease letter space size
    TextOverflow[TextOverflow["display"] = 0] = "display";
    // clip overflowed text
    TextOverflow[TextOverflow["clip"] = 1] = "clip";
    // use icon('..') to replace overflowed text
    TextOverflow[TextOverflow["ellipsis"] = 2] = "ellipsis";
})(TextOverflow$1 || (TextOverflow$1 = {}));
var TextAlignment$1;
(function (TextAlignment) {
    /**
     * text alignment starts from（x,y) to right direction
     * 从(x,y)开始第一个字符，向右边延伸
     */
    TextAlignment[TextAlignment["left"] = 0] = "left";
    /**
     * (x,y) is middle position of text, where (left + right)/2 =(x,y)
     * (x,y) 为文字中间位置，（最左位置 + 最右位置)/2 = (x,y)
     */
    TextAlignment[TextAlignment["middle"] = 1] = "middle";
    /**
     * text alignment ends with（x,y) from left direction
     * 从(x,y)结束最后一个字符，向左边延伸
     */
    TextAlignment[TextAlignment["right"] = 2] = "right";
})(TextAlignment$1 || (TextAlignment$1 = {}));
var FontStyle$1;
(function (FontStyle) {
    FontStyle[FontStyle["normal"] = 0] = "normal";
    FontStyle[FontStyle["italic"] = 1] = "italic";
    FontStyle[FontStyle["oblique"] = 2] = "oblique";
})(FontStyle$1 || (FontStyle$1 = {}));

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	get BezierKeyframeType () { return BezierKeyframeType$1; },
	get BlendingMode () { return BlendingMode$1; },
	BloomFilterThresholdAvgColor: BloomFilterThresholdAvgColor,
	CAMERA_CLIP_MODE_NORMAL: CAMERA_CLIP_MODE_NORMAL$1,
	CAMERA_CLIP_MODE_VERTICAL: CAMERA_CLIP_MODE_VERTICAL$1,
	get CameraClipMode () { return CameraClipMode$1; },
	get CompositionEndBehavior () { return CompositionEndBehavior$1; },
	END_BEHAVIOR_DESTROY: END_BEHAVIOR_DESTROY$1,
	END_BEHAVIOR_DESTROY_CHILDREN: END_BEHAVIOR_DESTROY_CHILDREN$1,
	END_BEHAVIOR_FORWARD: END_BEHAVIOR_FORWARD$1,
	END_BEHAVIOR_FREEZE: END_BEHAVIOR_FREEZE$1,
	END_BEHAVIOR_PAUSE: END_BEHAVIOR_PAUSE$1,
	END_BEHAVIOR_PAUSE_AND_DESTROY: END_BEHAVIOR_PAUSE_AND_DESTROY$1,
	END_BEHAVIOR_RESTART: END_BEHAVIOR_RESTART$1,
	get FontStyle () { return FontStyle$1; },
	get InteractBehavior () { return InteractBehavior$2; },
	get InteractType () { return InteractType$1; },
	get ItemEndBehavior () { return ItemEndBehavior$1; },
	get ItemType () { return ItemType$1; },
	MESSAGE_ITEM_PHRASE_BEGIN: MESSAGE_ITEM_PHRASE_BEGIN,
	MESSAGE_ITEM_PHRASE_END: MESSAGE_ITEM_PHRASE_END,
	get MaskMode () { return MaskMode$1; },
	get MaterialBlending () { return MaterialBlending$1; },
	get MaterialType () { return MaterialType$1; },
	get ModelBoundingType () { return ModelBoundingType$1; },
	get ParentItemEndBehavior () { return ParentItemEndBehavior$1; },
	get ParticleInteractionBehavior () { return ParticleInteractionBehavior$1; },
	get ParticleOrigin () { return ParticleOrigin$1; },
	get PluginType () { return PluginType$1; },
	get RenderLevel () { return RenderLevel$1; },
	get RenderMode () { return RenderMode$1; },
	get RenderMode3D () { return RenderMode3D$1; },
	get ShapeArcMode () { return ShapeArcMode$1; },
	get ShapeType () { return ShapeType$1; },
	get SideMode () { return SideMode$1; },
	get TextAlignment () { return TextAlignment$1; },
	get TextOverflow () { return TextOverflow$1; },
	get ValueType () { return ValueType$1; }
});

function clamp$1(v, min, max) {
    return v > max ? max : (v < min ? min : v);
}
function nearestPowerOfTwo(value) {
    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
}

var toHalf = (function () {
    var floatView = new Float32Array(1);
    var int32View = new Int32Array(floatView.buffer);
    /* This method is faster than the OpenEXR implementation (very often
     * used, eg. in Ogre), with the additional benefit of rounding, inspired
     * by James Tursa?s half-precision code. */
    return function toHalf(val) {
        floatView[0] = val;
        var x = int32View[0];
        var bits = (x >> 16) & 0x8000; /* Get the sign */
        var m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */
        var e = (x >> 23) & 0xff; /* Using int is faster here */
        /* If zero, or denormal, or exponent underflows too much for a denormal
         * half, return signed zero. */
        if (e < 103) {
            return bits;
        }
        /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
        if (e > 142) {
            bits |= 0x7c00;
            /* If exponent was 0xff and one mantissa bit was set, it means NaN,
             * not Inf, so make sure we set one mantissa bit too. */
            bits |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);
            return bits;
        }
        /* If exponent underflows but not too much, return a denormal */
        if (e < 113) {
            m |= 0x0800;
            /* Extra rounding may overflow and set mantissa to 0 and exponent
             * to 1, which is OK. */
            bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
            return bits;
        }
        bits |= ((e - 112) << 10) | (m >> 1);
        /* Extra rounding. An overflow will set mantissa to 0 and increment
         * the exponent, which is OK. */
        bits += m & 1;
        return bits;
    };
}());
var Float16ArrayWrapper = /** @class */ (function () {
    function Float16ArrayWrapper(num) {
        if (Number.isInteger(num)) {
            this.data = new Uint16Array(num);
        }
        else if (num && typeof num === 'object' && Number.isInteger(num.length)) {
            var data = this.data = new Uint16Array(num.length);
            for (var i = 0; i < data.length; i++) {
                data[i] = toHalf(num[i]);
            }
        }
    }
    Float16ArrayWrapper.prototype.set = function (number, startIndex) {
        for (var i = 0; i < number.length; i++) {
            this.data[i + startIndex] = toHalf(number[i]);
        }
    };
    return Float16ArrayWrapper;
}());

var d2r$3 = Math.PI / 180;
function mat3FromQuat(out, quat) {
    var _a = __read$1(quat, 4), x = _a[0], y = _a[1], z = _a[2], w = _a[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
}
function mat4create() {
    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
/**
 * 根据缩放、位移和旋转计算世界变换矩阵
 * @param out - 结果矩阵
 * @param q - 四元数表示的旋转量
 * @param v - 位移向量
 * @param s - 缩放向量
 * @return
 */
function mat4fromRotationTranslationScale(out, q, v, s) {
    var x = q[0];
    var y = q[1];
    var z = q[2];
    var w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
}
function mat4invert(out, a) {
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    var a30 = a[12];
    var a31 = a[13];
    var a32 = a[14];
    var a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
        for (var i = 0; i < 16; i++) {
            out[i] = NaN;
        }
        return out;
    }
    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
}
function mat4multiply(out, a, b) {
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    var a30 = a[12];
    var a31 = a[13];
    var a32 = a[14];
    var a33 = a[15];
    // Cache only the current line of the second matrix
    var b0 = b[0];
    var b1 = b[1];
    var b2 = b[2];
    var b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}
/**
 * 计算透视投影相机的投影矩阵
 * @param out - 结果矩阵
 * @param fovy - 视锥体的垂直视野角度
 * @param aspect - 视锥体的长宽比
 * @param near - 视锥体的近平面
 * @param far - 视锥体的远平面
 * @param reverse - 视锥体长宽反转
 */
function mat4perspective(out, fovy, aspect, near, far, reverse) {
    var f = 1.0 / Math.tan((fovy * d2r$3) / 2);
    var nf;
    out[0] = reverse ? f : f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = reverse ? f * aspect : f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    }
    else {
        out[10] = -1;
        out[14] = -2 * near;
    }
}
var matrixRotation = new Float32Array(9);
var quatOut = [0, 0, 0, 1];
var temps = [];
function mat4Determinate(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function getMat4TR(mat4, translate, quat, scaling) {
    var m11 = mat4[0];
    var m12 = mat4[1];
    var m13 = mat4[2];
    var m21 = mat4[4];
    var m22 = mat4[5];
    var m23 = mat4[6];
    var m31 = mat4[8];
    var m32 = mat4[9];
    var m33 = mat4[10];
    if (quat) {
        // copy from gl-matrix
        var is1 = 1 / scaling[0];
        var is2 = 1 / scaling[1];
        var is3 = 1 / scaling[2];
        matrixRotation[0] = m11 * is1;
        matrixRotation[1] = m12 * is1;
        matrixRotation[2] = m13 * is1;
        matrixRotation[3] = m21 * is2;
        matrixRotation[4] = m22 * is2;
        matrixRotation[5] = m23 * is2;
        matrixRotation[6] = m31 * is3;
        matrixRotation[7] = m32 * is3;
        matrixRotation[8] = m33 * is3;
        var fTrace = matrixRotation[0] + matrixRotation[4] + matrixRotation[8];
        var fRoot = void 0;
        if (fTrace > 0.0) {
            // |w| > 1/2, may as well choose w > 1/2
            fRoot = Math.sqrt(fTrace + 1.0); // 2w
            quatOut[3] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot; // 1/(4w)
            quatOut[0] = (matrixRotation[5] - matrixRotation[7]) * fRoot;
            quatOut[1] = (matrixRotation[6] - matrixRotation[2]) * fRoot;
            quatOut[2] = (matrixRotation[1] - matrixRotation[3]) * fRoot;
        }
        else {
            // |w| <= 1/2
            var i = 0;
            if (matrixRotation[4] > matrixRotation[0]) {
                i = 1;
            }
            if (matrixRotation[8] > matrixRotation[i * 3 + i]) {
                i = 2;
            }
            var j = (i + 1) % 3;
            var k = (i + 2) % 3;
            fRoot = Math.sqrt(matrixRotation[i * 3 + i] - matrixRotation[j * 3 + j] - matrixRotation[k * 3 + k] + 1.0);
            quatOut[i] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            quatOut[3] = (matrixRotation[j * 3 + k] - matrixRotation[k * 3 + j]) * fRoot;
            quatOut[j] = (matrixRotation[j * 3 + i] + matrixRotation[i * 3 + j]) * fRoot;
            quatOut[k] = (matrixRotation[k * 3 + i] + matrixRotation[i * 3 + k]) * fRoot;
        }
        quat[0] = quatOut[0];
        quat[1] = quatOut[1];
        quat[2] = quatOut[2];
        quat[3] = quatOut[3];
    }
    if (translate) {
        translate[0] = mat4[12];
        translate[1] = mat4[13];
        translate[2] = mat4[14];
    }
}
function getMat4TRS(mat4, translate, quat, scaling) {
    if (scaling === void 0) { scaling = temps; }
    var m11 = mat4[0];
    var m12 = mat4[1];
    var m13 = mat4[2];
    var m21 = mat4[4];
    var m22 = mat4[5];
    var m23 = mat4[6];
    var m31 = mat4[8];
    var m32 = mat4[9];
    var m33 = mat4[10];
    var det = mat4Determinate(mat4);
    scaling[0] = Math.hypot(m11, m12, m13);
    scaling[1] = Math.hypot(m21, m22, m23);
    scaling[2] = Math.hypot(m31, m32, m33);
    if (det < 0) {
        scaling[0] = -scaling[0];
    }
    return getMat4TR(mat4, translate, quat, scaling);
}
function mat4Clone(out, from) {
    for (var i = 0; i < 16; i++) {
        out[i] = from[i];
    }
    return out;
}

var d2r$2 = Math.PI / 180;
var r2d$1 = 180 / Math.PI;
var cos$2 = Math.cos;
var sin$2 = Math.sin;
function vecAdd(out, a, b) {
    for (var i = 0, len = a.length; i < len; i++) {
        out[i] = a[i] + b[i];
    }
    return out;
}
function vecFill(out, number) {
    for (var i = 0, len = out.length; i < len; i++) {
        out[i] = number;
    }
    return out;
}
var NumberEpsilon = Number.EPSILON || Math.pow(2, -32);
function isZeroVec(vec) {
    for (var i = 0, len = vec.length; i < len; i++) {
        if (Math.abs(vec[i]) > NumberEpsilon) {
            return false;
        }
    }
    return true;
}
function ensureVec3(num) {
    return isArray(num) ? [num[0], num[1], num[2]] : [0, 0, 0];
}
function vec3MulMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
}
function vecAssign(out, a, count, start) {
    if (start === void 0) { start = 0; }
    for (var i = 0; i < count; i++) {
        out[i] = a[i + start];
    }
    return out;
}
function vecMulCombine(out, a, b) {
    if (a && b) {
        for (var i = 0, len = a.length; i < len; i++) {
            out[i] = a[i] * b[i];
        }
    }
    else if (a) {
        if (out !== a) {
            for (var i = 0; i < a.length; i++) {
                out[i] = a[i];
            }
        }
    }
    else if (b) {
        if (out !== b) {
            for (var i = 0; i < b.length; i++) {
                out[i] = b[i];
            }
        }
    }
    return out;
}
function vecNormalize(out, a) {
    if (arguments.length === 1) {
        a = out;
        out = [];
    }
    var ap = a;
    var sum = Math.hypot.apply(Math, __spreadArray([], __read$1(ap), false));
    if (sum === 0) {
        return vecAssign(out, ap, ap.length);
    }
    for (var i = 0; i < ap.length; i++) {
        out[i] = ap[i] / sum;
    }
    return out;
}
function vecMulScalar(out, vec, a) {
    for (var i = 0, len = vec.length; i < len; i++) {
        out[i] = vec[i] * a;
    }
    return out;
}
function vecMinus(out, v0, v1) {
    for (var i = 0, len = v0.length; i < len; i++) {
        out[i] = v0[i] - v1[i];
    }
    return out;
}
function vecSquareDistance(v0, v1) {
    var sum = 0;
    for (var i = 0, len = v0.length; i < len; i++) {
        var d = v0[i] - v1[i];
        sum += d * d;
    }
    return sum;
}
function vecDot(out, a, b) {
    if (isNaN(b)) {
        var sum = 0;
        for (var i = 0, len = a.length; i < len; i++) {
            sum += out[i] * a[i];
        }
        return sum;
    }
    for (var i = 0, len = a.length; i < len; i++) {
        out[i] = a[i] * b;
    }
    return (out);
}
function vec3Cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
}
function vec3MulMat4(out, vec3, mat4) {
    var x = vec3[0], y = vec3[1], z = vec3[2];
    var w = mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15];
    w = w || 1.0;
    out[0] = (mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12]) / w;
    out[1] = (mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13]) / w;
    out[2] = (mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14]) / w;
    return out;
}
function vec3RotateByMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
    return out;
}
var tempMat3FromRotationZ = [0, 0, 0, 0, 0, 0, 0, 0, 0];
function mat3FromRotationZ(out, rad) {
    if (!out) {
        out = tempMat3FromRotationZ;
    }
    var s = sin$2(rad);
    var c = cos$2(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function mat3FromRotationZYX(ret, x, y, z) {
    var cosX = cos$2(x * d2r$2);
    var cosY = cos$2(y * d2r$2);
    var cosZ = cos$2(z * d2r$2);
    var sinX = sin$2(x * d2r$2);
    var sinY = sin$2(y * d2r$2);
    var sinZ = sin$2(z * d2r$2);
    ret[0] = cosY * cosZ;
    ret[1] = cosY * sinZ;
    ret[2] = -sinY;
    ret[3] = -cosX * sinZ + sinX * sinY * cosZ;
    ret[4] = cosX * cosZ + sinX * sinY * sinZ;
    ret[5] = sinX * cosY;
    ret[6] = sinZ * sinX + cosX * sinY * cosZ;
    ret[7] = -sinX * cosZ + cosX * sinY * sinZ;
    ret[8] = cosX * cosY;
    return ret;
}
function mat3FromRotation(ret, rotation) {
    return mat3FromRotationZYX(ret, -rotation[0], -rotation[1], -rotation[2]);
}
function rotationZYXFromMat3(out, mat3) {
    var te = mat3;
    var m11 = te[0], m12 = te[3]; te[6];
    var m21 = te[1], m22 = te[4]; te[7];
    var m31 = te[2], m32 = te[5], m33 = te[8];
    out[1] = Math.asin(clamp$1(-m31, -1, 1)) * r2d$1;
    if (Math.abs(m31) < 0.9999999) {
        out[0] = Math.atan2(m32, m33) * r2d$1;
        out[2] = Math.atan2(m21, m11) * r2d$1;
    }
    else {
        out[0] = 0;
        out[2] = Math.atan2(-m12, m22) * r2d$1;
    }
    return out;
}
function rotationFromMat3(out, mat3) {
    rotationZYXFromMat3(out, mat3);
    return out;
}

var d2r$1 = Math.PI / 180;
var cos$1 = Math.cos;
var sin$1 = Math.sin;
/**
 * 按照 ZYX 的旋转顺序把旋转角转换成四元数
 * @param out - 结果向量
 * @param x - 沿x轴旋转角度
 * @param y - 沿y轴旋转角度
 * @param z - 沿z轴旋转角度
 */
function quatFromRotation(out, x, y, z) {
    var c1 = cos$1((x * d2r$1) / 2);
    var c2 = cos$1((y * d2r$1) / 2);
    var c3 = cos$1((z * d2r$1) / 2);
    var s1 = sin$1((x * d2r$1) / 2);
    var s2 = sin$1((y * d2r$1) / 2);
    var s3 = sin$1((z * d2r$1) / 2);
    out[0] = s1 * c2 * c3 - c1 * s2 * s3;
    out[1] = c1 * s2 * c3 + s1 * c2 * s3;
    out[2] = c1 * c2 * s3 - s1 * s2 * c3;
    out[3] = c1 * c2 * c3 + s1 * s2 * s3;
}
/**
 * 取四元数的共轭
 * @param out - 结果四元数
 * @param quat - 原始四元数
 */
function quatStar(out, quat) {
    var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
    out[0] = -x;
    out[1] = -y;
    out[2] = -z;
    out[3] = w;
}
/**
 * 根据指定四元数计算向量旋转后的结果
 * @param out - 结果向量
 * @param a - 原始向量
 * @param quat - 四元数
 */
function rotateByQuat(out, a, quat) {
    var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
    var qvec = [x, y, z];
    var uv = vec3Cross([], qvec, a);
    var uuv = vec3Cross([], qvec, uv);
    vecDot(uuv, uuv, 2);
    vecDot(uv, uv, 2 * w);
    vecAdd(uuv, uuv, uv);
    vecAdd(out, a, uuv);
}

var tmp = [0, 0, 0];
function setRayFromCamera(x, y, camera) {
    var _a;
    var origin = (_a = camera.position) !== null && _a !== void 0 ? _a : [0, 0, 0];
    var direction = [x, y, 0];
    var dir = [0, 0, 0];
    vec3MulMat4(dir, direction, camera.getInverseViewProjectionMatrix());
    vecMinus(dir, dir, origin);
    return {
        center: origin,
        direction: vecNormalize([], dir),
    };
}
function intersectRaySphere(out, origin, direction, center, radius) {
    vecMinus(tmp, center, origin);
    var len = vecDot(direction, tmp);
    if (len < 0) { // sphere is behind ray
        return null;
    }
    vecMulScalar(tmp, direction, len);
    vecAdd(tmp, origin, tmp);
    var dSq = vecSquareDistance(center, tmp);
    var rSq = radius * radius;
    if (dSq > rSq) {
        return null;
    }
    vecMulScalar(out, direction, len - Math.sqrt(rSq - dSq));
    return vecAdd(out, out, origin);
}
function intersectRayBox(out, origin, direction, center, size) {
    var _a = __read$1(direction, 3), dx = _a[0], dy = _a[1], dz = _a[2];
    var _b = __read$1(origin, 3), ox = _b[0], oy = _b[1], oz = _b[2];
    var bxmin = center[0] - size[0] / 2, bxmax = center[0] + size[0] / 2, bymin = center[1] - size[1] / 2, bymax = center[1] + size[1] / 2, bzmin = center[2] - size[2] / 2, bzmax = center[2] + size[2] / 2;
    var tmin, tmax, tymin, tymax, tzmin, tzmax;
    var invdirx = 1 / dx, invdiry = 1 / dy, invdirz = 1 / dz;
    if (invdirx >= 0) {
        tmin = (bxmin - ox) * invdirx;
        tmax = (bxmax - ox) * invdirx;
    }
    else {
        tmin = (bxmax - ox) * invdirx;
        tmax = (bxmin - ox) * invdirx;
    }
    if (invdiry >= 0) {
        tymin = (bymin - oy) * invdiry;
        tymax = (bymax - oy) * invdiry;
    }
    else {
        tymin = (bymax - oy) * invdiry;
        tymax = (bymin - oy) * invdiry;
    }
    if ((tmin > tymax) || (tymin > tmax)) {
        return null;
    }
    if (tymin > tmin || tmin !== tmin) {
        tmin = tymin;
    }
    if (tymax < tmax || tmax !== tmax) {
        tmax = tymax;
    }
    if (tymin > tmin || tmin !== tmin) {
        tmin = tymin;
    }
    if (tymax < tmax || tmax !== tmax) {
        tmax = tymax;
    }
    if (invdirz >= 0) {
        tzmin = (bzmin - oz) * invdirz;
        tzmax = (bzmax - oz) * invdirz;
    }
    else {
        tzmin = (bzmax - oz) * invdirz;
        tzmax = (bzmin - oz) * invdirz;
    }
    if ((tmin > tzmax) || (tzmin > tmax)) {
        return null;
    }
    if (tzmin > tmin || tmin !== tmin) {
        tmin = tzmin;
    }
    if (tzmax < tmax || tmax !== tmax) {
        tmax = tzmax;
    }
    if (tmax < 0) {
        return null;
    }
    tmin >= 0 ? vecMulScalar(out, origin, tmin) : vecMulScalar(out, origin, tmax);
    return vecAdd(out, out, origin);
}
var edge1 = [0, 0, 0], edge2 = [0, 0, 0], normal = [0, 0, 0], diff = [0, 0, 0];
function trianglesFromRect(position, halfWidth, halfHeight) {
    var _a = __read$1(position, 3), x = _a[0], y = _a[1], z = _a[2];
    var p0 = [x - halfWidth, y + halfHeight, z];
    var p1 = [x - halfWidth, y - halfHeight, z];
    var p2 = [x + halfWidth, y - halfHeight, z];
    var p3 = [x + halfWidth, y + halfHeight, z];
    return [
        [p0, p1, p2],
        [p0.slice(), p2.slice(), p3],
    ];
}
function intersectRayTriangle(out, origin, direction, triangle, backfaceCulling) {
    var sign, DdN, DdQxE2, DdE1xQ, QdN;
    var temp = direction;
    vecMinus(edge1, triangle[1], triangle[0]);
    vecMinus(edge2, triangle[2], triangle[0]);
    vecMinus(diff, origin, triangle[0]);
    vec3Cross(normal, edge1, edge2);
    DdN = vecDot(temp, normal);
    if (DdN > 0) {
        if (backfaceCulling) {
            return null;
        }
        sign = 1;
    }
    else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
    }
    else {
        return null;
    }
    vec3Cross(edge2, diff, edge2);
    temp = direction;
    DdQxE2 = vecDot(temp, edge2);
    DdQxE2 = sign * DdQxE2;
    if (DdQxE2 < 0) {
        return null;
    }
    vec3Cross(edge1, edge1, diff);
    temp = direction;
    DdE1xQ = vecDot(temp, edge1);
    DdE1xQ = sign * DdE1xQ;
    if (DdE1xQ < 0) {
        return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
        return null;
    }
    QdN = vecDot(diff, normal);
    QdN = -sign * QdN;
    if (QdN < 0) {
        return null;
    }
    vecMulScalar(out, direction, QdN / DdN);
    return vecAdd(out, out, origin);
}
var e0 = [0, 0], e1 = [0, 0], e2 = [0, 0];
function dotInTriangle(out, dot, triangle) {
    var _a = __read$1(triangle, 3), p0 = _a[0], p1 = _a[1], p2 = _a[2];
    var a = [p0[0], p0[1]], b = [p1[0], p1[1]], c = [p2[0], p2[1]];
    vecMinus(e0, c, a);
    vecMinus(e1, b, a);
    vecMinus(e2, dot, a);
    var dot00 = vecDot(e0, e0);
    var dot01 = vecDot(e0, e1);
    var dot02 = vecDot(e0, e2);
    var dot11 = vecDot(e1, e1);
    var dot12 = vecDot(e1, e2);
    var denom = (dot00 * dot11 - dot01 * dot01);
    if (denom === 0) {
        out = false;
        return out;
    }
    var invDenom = 1 / denom;
    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    out = (1 - u - v >= 0) && (v >= 0) && ((1 - u) <= 1);
    return out;
}

function translatePoint(x, y) {
    var origin = [-.5, .5, -.5, -.5, .5, .5, .5, -.5];
    for (var i = 0; i < 8; i += 2) {
        origin[i] += x;
        origin[i + 1] += y;
    }
    return origin;
}
var tempRot$2 = [];
function calculateTranslation(out, target, acc, time, duration, posData, velData, posStartIndex, velStartIndex) {
    var ret = out;
    var lifetime = time / duration;
    var speedIntegrate = time;
    var speedOverLifetime = target.speedOverLifetime;
    if (speedOverLifetime) {
        speedIntegrate = speedOverLifetime.getIntegrateValue(0, time, duration);
    }
    var d = target.gravityModifier ? target.gravityModifier.getIntegrateByTime(0, time) : 0;
    posStartIndex = posStartIndex || 0;
    velStartIndex = velStartIndex || 0;
    for (var i = 0; i < 3; i++) {
        ret[i] = posData[posStartIndex + i] + velData[velStartIndex + i] * speedIntegrate + acc[i] * d;
    }
    var linearVelocityOverLifetime = target.linearVelOverLifetime || {};
    var orbVelOverLifetime = target.orbitalVelOverLifetime || {};
    var map = ['x', 'y', 'z'];
    if (orbVelOverLifetime.enabled) {
        var center = orbVelOverLifetime.center || [0, 0, 0];
        var pos = [ret[0] - center[0], ret[1] - center[1], ret[2] - center[2]];
        var asRotation_1 = orbVelOverLifetime.asRotation;
        var rot = vec3MulMat3(pos, pos, mat3FromRotation(tempRot$2, map.map(function (pro) {
            var value = orbVelOverLifetime[pro];
            if (value) {
                return (asRotation_1 ? value.getValue(lifetime) : value.getIntegrateValue(0, time, duration));
            }
            return 0;
        })));
        ret = vecAdd(ret, center, rot);
    }
    if (linearVelocityOverLifetime.enabled) {
        var asMovement = linearVelocityOverLifetime.asMovement;
        for (var i = 0; i < 3; i++) {
            var pro = linearVelocityOverLifetime[map[i]];
            if (pro) {
                ret[i] += asMovement ? pro.getValue(lifetime) : pro.getIntegrateValue(0, time, duration);
            }
        }
    }
    return ret;
}

var _a$a;
var NOT_IMPLEMENT = 'not_implement';
var ValueGetter = /** @class */ (function () {
    function ValueGetter(arg) {
        this.onCreate(arg);
    }
    ValueGetter.prototype.onCreate = function (props) {
        throw Error(NOT_IMPLEMENT);
    };
    ValueGetter.prototype.getIntegrateValue = function (t0, t1, timeScale) {
        throw Error(NOT_IMPLEMENT);
    };
    ValueGetter.prototype.getIntegrateByTime = function (t0, time) {
        throw Error(NOT_IMPLEMENT);
    };
    ValueGetter.prototype.getValue = function (time) {
        throw Error(NOT_IMPLEMENT);
    };
    ValueGetter.prototype.toUniform = function (meta) {
        throw Error(NOT_IMPLEMENT);
    };
    ValueGetter.prototype.map = function (func) {
        throw Error(NOT_IMPLEMENT);
    };
    ValueGetter.prototype.scaleXCoord = function (scale) {
        return this;
    };
    return ValueGetter;
}());
var StaticValue = /** @class */ (function (_super) {
    __extends(StaticValue, _super);
    function StaticValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StaticValue.prototype.onCreate = function (arg) {
        this.value = arg;
    };
    StaticValue.prototype.getIntegrateValue = function (t0, t1, ts) {
        return this.value * (t1 - t0);
    };
    StaticValue.prototype.getIntegrateByTime = function (t0, t1) {
        return 0.5 * this.value * (t1 * t1 - t0 * t0);
    };
    StaticValue.prototype.getValue = function (time) {
        return this.value;
    };
    StaticValue.prototype.toUniform = function () {
        return new Float32Array([0, this.value, 0, 0]);
    };
    StaticValue.prototype.map = function (func) {
        var val = this.value;
        this.value = func(val);
        return this;
    };
    return StaticValue;
}(ValueGetter));
var RandomSetValue = /** @class */ (function (_super) {
    __extends(RandomSetValue, _super);
    function RandomSetValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RandomSetValue.prototype.onCreate = function (arg) {
        this.items = arg;
    };
    RandomSetValue.prototype.getValue = function (t) {
        var items = this.items;
        return items[Math.floor(Math.random() * items.length)];
    };
    RandomSetValue.prototype.map = function (func) {
        this.items = this.items.map(func);
        return this;
    };
    return RandomSetValue;
}(ValueGetter));
var RandomValue = /** @class */ (function (_super) {
    __extends(RandomValue, _super);
    function RandomValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RandomValue.prototype.onCreate = function (props) {
        this.min = props[0];
        this.max = props[1];
    };
    RandomValue.prototype.getValue = function (time) {
        return random(this.min, this.max);
    };
    RandomValue.prototype.toUniform = function () {
        return new Float32Array([4, this.min, this.max, 0]);
    };
    RandomValue.prototype.map = function (func) {
        this.min = func(this.min);
        this.max = func(this.max);
        return this;
    };
    return RandomValue;
}(ValueGetter));
var RandomVectorValue = /** @class */ (function (_super) {
    __extends(RandomVectorValue, _super);
    function RandomVectorValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RandomVectorValue.prototype.onCreate = function (props) {
        this.min = props[0];
        this.max = props[1];
    };
    RandomVectorValue.prototype.getValue = function (time) {
        var min = this.min;
        var max = this.max;
        var ret = [];
        for (var i = 0; i < min.length; i++) {
            var t = Math.random();
            ret[i] = min[i] * (1 - t) + max[i] * t;
        }
        return ret;
    };
    // TODO:
    RandomVectorValue.prototype.map = function (func) {
        this.min = this.min.map(func);
        this.max = this.max.map(func);
        return this;
    };
    return RandomVectorValue;
}(ValueGetter));
var LinearValue = /** @class */ (function (_super) {
    __extends(LinearValue, _super);
    function LinearValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LinearValue.prototype.onCreate = function (props) {
        this.min = props[0];
        this.max = props[1];
        this.xCoord = 1;
    };
    LinearValue.prototype.getValue = function (t) {
        t /= this.xCoord;
        return this.min * (1 - t) + this.max * t;
    };
    LinearValue.prototype.toUniform = function () {
        return new Float32Array([1, this.min, this.max, this.xCoord]);
    };
    LinearValue.prototype.getIntegrateValue = function (t0, t1, timeScale) {
        if (timeScale === void 0) { timeScale = 1; }
        var min = this.min;
        var max = this.max;
        var ts = this.xCoord * timeScale;
        var v1 = min + (max - min) * (t1 / ts);
        var v0 = min + (max - min) * (t0 / ts);
        return ((v1 + min) * t1 - (v0 + min) * t0) / 2;
    };
    LinearValue.prototype.getIntegrateByTime = function (t0, t1) {
        return lineSegIntegrateByTime(t1, 0, this.xCoord, this.min, this.max) - lineSegIntegrateByTime(t0, 0, this.xCoord, this.min, this.max);
    };
    LinearValue.prototype.map = function (func) {
        this.min = func(this.min);
        this.max = func(this.max);
        return this;
    };
    LinearValue.prototype.scaleXCoord = function (scale) {
        this.xCoord = scale;
        return this;
    };
    return LinearValue;
}(ValueGetter));
var GradientValue = /** @class */ (function (_super) {
    __extends(GradientValue, _super);
    function GradientValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GradientValue.prototype.onCreate = function (props) {
        this.stops = colorStopsFromGradient(props);
    };
    GradientValue.prototype.getStops = function () {
        return this.stops;
    };
    GradientValue.prototype.getValue = function (time) {
        var stops = this.stops;
        var last = stops.length - 1;
        for (var i = 0; i < last; i++) {
            var a = stops[i];
            var b = stops[i + 1];
            if (a.stop <= time && b.stop > time) {
                var t = (time - a.stop) / (b.stop - a.stop);
                return interpolateColor(a.color, b.color, t, true);
            }
        }
        return stops[last].color.slice();
    };
    return GradientValue;
}(ValueGetter));
var CURVE_PRO_TIME = 0;
var CURVE_PRO_VALUE = 1;
var CURVE_PRO_IN_TANGENT = 2;
var CURVE_PRO_OUT_TANGENT = 3;
var CurveValue = /** @class */ (function (_super) {
    __extends(CurveValue, _super);
    function CurveValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CurveValue.getAllData = function (meta, halfFloat) {
        var ret = new (halfFloat ? Float16ArrayWrapper : Float32Array)(meta.index * 4);
        for (var i = 0, cursor = 0, curves = meta.curves; i < curves.length; i++) {
            var data = curves[i].toData();
            ret.set(data, cursor);
            cursor += data.length;
        }
        return halfFloat ? ret.data : ret;
    };
    CurveValue.prototype.onCreate = function (props) {
        var min = Infinity;
        var max = -Infinity;
        //formatted number
        if (Number.isFinite(props[0]) && Number.isFinite(props[1])) {
            var keys = [];
            for (var i = 2; i < props.length; i++) {
                // FIXME
                keys.push(props[i].slice(0, 4));
            }
            this.keys = keys;
            this.min = props[0];
            this.dist = props[1] - props[0];
        }
        else {
            var keys = props.map(function (item) {
                if (isArray(item)) {
                    min = Math.min(min, item[1]);
                    max = Math.max(max, item[1]);
                    return item.slice(0, 4);
                }
                else if (typeof item === 'object' && item) {
                    var _a = item, time = _a.time, value = _a.value, _b = _a.inTangent, inTangent = _b === void 0 ? 0 : _b, _c = _a.outTangent, outTangent = _c === void 0 ? 0 : _c;
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                    return [time, value, inTangent, outTangent];
                }
                throw new Error('invalid keyframe');
            });
            var dist = max - min;
            this.keys = keys;
            if (dist !== 0) {
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    key[1] = (key[1] - min) / dist;
                }
            }
            var key0 = keys[0];
            if (key0[0] > 0) {
                key0[2] = 0;
                keys.unshift([0, key0[1], 0, 0]);
            }
            var key1 = keys[keys.length - 1];
            if (key1[0] < 1) {
                key1[3] = 0;
                keys.push([1, key1[1], 0, 0]);
            }
            this.min = min;
            this.dist = dist;
        }
        this.isCurveValue = true;
    };
    CurveValue.prototype.getValue = function (time) {
        var _a = this, keys = _a.keys, min = _a.min, dist = _a.dist;
        var keysNumerArray = keys;
        if (time <= keysNumerArray[0][CURVE_PRO_TIME]) {
            return keysNumerArray[0][CURVE_PRO_VALUE] * dist + min;
        }
        var end = keysNumerArray.length - 1;
        for (var i = 0; i < end; i++) {
            var key = keysNumerArray[i];
            var k2 = keysNumerArray[i + 1];
            if (time > key[CURVE_PRO_TIME] && time <= k2[CURVE_PRO_TIME]) {
                return curveValueEvaluate(time, key, k2) * dist + min;
            }
        }
        return keysNumerArray[end][CURVE_PRO_VALUE] * dist + min;
    };
    CurveValue.prototype.getIntegrateByTime = function (t0, t1) {
        var d = this.integrate(t1, true) - this.integrate(t0, true);
        return this.min * 0.5 * (t1 - t0) * (t1 - t0) + d * this.dist;
    };
    CurveValue.prototype.getIntegrateValue = function (t0, t1, ts) {
        ts = ts || 1;
        var d = (this.integrate(t1 / ts, false) - this.integrate(t0 / ts, false)) * ts;
        var dt = (t1 - t0) / ts;
        return this.min * dt + d * this.dist;
    };
    CurveValue.prototype.integrate = function (time, byTime) {
        var keys = this.keys;
        if (time <= keys[0][CURVE_PRO_TIME]) {
            return 0;
        }
        var ret = 0;
        var end = keys.length - 1;
        var func = byTime ? curveValueIntegrateByTime : curveValueIntegrate;
        for (var i = 0; i < end; i++) {
            var key = keys[i];
            var k2 = keys[i + 1];
            var t1 = key[CURVE_PRO_TIME];
            var t2 = k2[CURVE_PRO_TIME];
            if (time > t1 && time <= t2) {
                return ret + func(time, key, k2);
            }
            else {
                ret += func(t2, key, k2);
            }
        }
        return ret;
    };
    CurveValue.prototype.toData = function () {
        var keys = this.keys;
        var data = new Float32Array(keys.length * 4);
        for (var i = 0, cursor = 0; i < keys.length; i++, cursor += 4) {
            data.set(keys[i], cursor);
        }
        return data;
    };
    CurveValue.prototype.toUniform = function (meta) {
        var index = meta.index;
        var keys = this.keys;
        meta.curves.push(this);
        meta.index += keys.length;
        meta.max = Math.max(meta.max, keys.length);
        meta.curveCount += keys.length;
        return new Float32Array([2, index + 1 / keys.length, this.min, this.dist]);
    };
    CurveValue.prototype.map = function (func) {
        this.keys.forEach(function (k) {
            k[CURVE_PRO_VALUE] = func(k[CURVE_PRO_VALUE]);
        });
        return this;
    };
    CurveValue.prototype.scaleXCoord = function (scale) {
        this.keys.forEach(function (k) { return k[CURVE_PRO_TIME] = scale * k[CURVE_PRO_TIME]; });
        return this;
    };
    return CurveValue;
}(ValueGetter));
var LineSegments = /** @class */ (function (_super) {
    __extends(LineSegments, _super);
    function LineSegments() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LineSegments.prototype.onCreate = function (props) {
        this.keys = props
            .map(function (p) {
            if (p.slice) {
                return p.slice(0, 2);
            }
            return [p.time, p.value];
        })
            .sort(function (a, b) { return a[0] - b[0]; });
        var last = this.keys[this.keys.length - 1];
        if (last[0] < 1) {
            this.keys.push([1, last[1]]);
        }
        var first = this.keys[0];
        if (first[0] > 0) {
            this.keys.unshift([0, first[1]]);
        }
        this.isLineSeg = true;
    };
    LineSegments.prototype.getValue = function (time) {
        var keys = this.keys;
        if (time < keys[0][0]) {
            return keys[0][1];
        }
        var end = keys.length - 1;
        for (var i = 0; i < end; i++) {
            var key = keys[i];
            var k2 = keys[i + 1];
            var x0 = key[0];
            var x1 = k2[0];
            if (time >= x0 && time <= x1) {
                var p = (time - x0) / (x1 - x0);
                var y0 = key[1];
                return y0 + p * (k2[1] - y0);
            }
        }
        return keys[end][1];
    };
    LineSegments.prototype.getIntegrateValue = function (t0, t1, ts) {
        if (ts === void 0) { ts = 1; }
        return (this.integrate(t1, false) - this.integrate(t0, false)) * ts;
    };
    LineSegments.prototype.getIntegrateByTime = function (t0, t1) {
        return this.integrate(t1, true) - this.integrate(t0, true);
    };
    LineSegments.prototype.integrate = function (time, byTime) {
        var keys = this.keys;
        if (time <= keys[0][0]) {
            return 0;
        }
        var ret = 0;
        var end = keys.length - 1;
        var func = byTime ? lineSegIntegrateByTime : lineSegIntegrate;
        for (var i = 0; i < end; i++) {
            var k1 = keys[i];
            var k2 = keys[i + 1];
            var t0 = k1[0];
            var t1 = k2[0];
            if (time > t0 && time <= t1) {
                return ret + func(time, t0, t1, k1[1], k2[1]);
            }
            else {
                ret += func(t1, t0, t1, k1[1], k2[1]);
            }
        }
        return ret;
    };
    LineSegments.prototype.toData = function () {
        var keys = this.keys;
        var data = new Float32Array(Math.ceil(keys.length / 2) * 4);
        for (var i = 0, cursor = 0; i < keys.length; i++, cursor += 2) {
            data.set(keys[i], cursor);
        }
        data.set(keys[keys.length - 1], data.length - 2);
        return data;
    };
    LineSegments.prototype.toUniform = function (meta) {
        var index = meta.index;
        var keys = this.keys;
        var uniformCount = Math.ceil(keys.length / 2);
        meta.lineSegCount += uniformCount;
        meta.curves.push(this);
        meta.index += uniformCount;
        meta.max = Math.max(meta.max, uniformCount);
        return new Float32Array([3, index, uniformCount, 0]);
    };
    LineSegments.prototype.map = function (func) {
        this.keys.forEach(function (k) { return k[1] = func(k[1]); });
        return this;
    };
    LineSegments.prototype.scaleXCoord = function (scale) {
        this.keys.forEach(function (k) { return k[0] = scale * k[0]; });
        return this;
    };
    return LineSegments;
}(ValueGetter));
var PathSegments = /** @class */ (function (_super) {
    __extends(PathSegments, _super);
    function PathSegments() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PathSegments.prototype.onCreate = function (props) {
        this.keys = props[0];
        this.values = props[1];
    };
    PathSegments.prototype.getValue = function (time) {
        var keys = this.keys;
        var values = this.values;
        for (var i = 0; i < keys.length - 1; i++) {
            var k0 = keys[i];
            var k1 = keys[i + 1];
            if (k0[0] <= time && k1[0] >= time) {
                var dis = k1[1] - k0[1];
                var dt = void 0;
                if (dis === 0) {
                    dt = (time - k0[0]) / (k1[0] - k0[0]);
                }
                else {
                    var val = curveValueEvaluate(time, k0, k1);
                    dt = (val - k0[1]) / dis;
                }
                return this.calculateVec(i, dt);
            }
        }
        if (time <= keys[0][0]) {
            return values[0].slice();
        }
        return values[values.length - 1].slice();
    };
    PathSegments.prototype.calculateVec = function (i, dt) {
        var vec0 = this.values[i];
        var vec1 = this.values[i + 1];
        var ret = [0, 0, 0];
        for (var j = 0; j < vec0.length; j++) {
            ret[j] = vec0[j] * (1 - dt) + vec1[j] * dt;
        }
        return ret;
    };
    return PathSegments;
}(ValueGetter));
var BezierSegments = /** @class */ (function (_super) {
    __extends(BezierSegments, _super);
    function BezierSegments() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BezierSegments.prototype.onCreate = function (props) {
        _super.prototype.onCreate.call(this, props);
        this.cps = props[2];
    };
    BezierSegments.prototype.calculateVec = function (i, t) {
        var vec0 = this.values[i];
        var vec1 = this.values[i + 1];
        var outCp = this.cps[i + i];
        var inCp = this.cps[i + i + 1];
        var ret = [0, 0, 0];
        var ddt = 1 - t;
        var a = ddt * ddt * ddt;
        var b = 3 * t * ddt * ddt;
        var c = 3 * t * t * ddt;
        var d = t * t * t;
        for (var j = 0; j < vec0.length; j++) {
            ret[j] = a * vec0[j] + b * outCp[j] + c * inCp[j] + d * vec1[j];
        }
        return ret;
    };
    return BezierSegments;
}(PathSegments));
var map$2 = (_a$a = {},
    _a$a[ValueType$1.RANDOM] = function (props) {
        if (props[0] instanceof Array) {
            return new RandomVectorValue(props);
        }
        return new RandomValue(props);
    },
    _a$a[ValueType$1.CONSTANT] = function (props) {
        return new StaticValue(props);
    },
    _a$a[ValueType$1.CONSTANT_VEC2] = function (props) {
        return new StaticValue(props);
    },
    _a$a[ValueType$1.CONSTANT_VEC3] = function (props) {
        return new StaticValue(props);
    },
    _a$a[ValueType$1.CONSTANT_VEC4] = function (props) {
        return new StaticValue(props);
    },
    _a$a[ValueType$1.CURVE] = function (props) {
        return new CurveValue(props);
    },
    _a$a[ValueType$1.RGBA_COLOR] = function (props) {
        return new StaticValue(props);
    },
    _a$a[ValueType$1.COLORS] = function (props) {
        return new RandomSetValue(props.map(function (c) { return colorToArr$1(c, false); }));
    },
    _a$a[ValueType$1.LINE] = function (props) {
        if (props.length === 2 && props[0][0] === 0 && props[1][0] === 1) {
            return new LinearValue([props[0][1], props[1][1]]);
        }
        return new LineSegments(props);
    },
    _a$a[ValueType$1.GRADIENT_COLOR] = function (props) {
        return new GradientValue(props);
    },
    _a$a[ValueType$1.LINEAR_PATH] = function (pros) {
        return new PathSegments(pros);
    },
    _a$a[ValueType$1.BEZIER_PATH] = function (pros) {
        return new BezierSegments(pros);
    },
    _a$a);
function createValueGetter(args) {
    if (!args || !isNaN(+args)) {
        return new StaticValue(args || 0);
    }
    if (args instanceof ValueGetter) {
        return args;
    }
    return map$2[args[0]](args[1]);
}
function lineSegIntegrate(t, t0, t1, y0, y1) {
    var h = t - t0;
    return (y0 + y0 + (y1 - y0) * h / (t1 - t0)) * h / 2;
}
function lineSegIntegrateByTime(t, t0, t1, y0, y1) {
    var t2 = t * t;
    var t3 = t2 * t;
    var t02 = t0 * t0;
    var t03 = t02 * t0;
    return (2 * t3 * (y0 - y1) + 3 * t2 * (t0 * y1 - t1 * y0) - t03 * (2 * y0 + y1) + 3 * t02 * t1 * y0) / (6 * (t0 - t1));
}
function curveValueEvaluate(time, keyframe0, keyframe1) {
    var dt = keyframe1[CURVE_PRO_TIME] - keyframe0[CURVE_PRO_TIME];
    var m0 = keyframe0[CURVE_PRO_OUT_TANGENT] * dt;
    var m1 = keyframe1[CURVE_PRO_IN_TANGENT] * dt;
    var t = (time - keyframe0[CURVE_PRO_TIME]) / dt;
    var t2 = t * t;
    var t3 = t2 * t;
    var a = 2 * t3 - 3 * t2 + 1;
    var b = t3 - 2 * t2 + t;
    var c = t3 - t2;
    var d = -2 * t3 + 3 * t2;
    //(2*v0+m0+m1-2*v1)*(t-t0)^3/k^3+(3*v1-3*v0-2*m0-m1)*(t-t0)^2/k^2+m0 *(t-t0)/k+v0
    return a * keyframe0[CURVE_PRO_VALUE] + b * m0 + c * m1 + d * keyframe1[CURVE_PRO_VALUE];
}
function curveValueIntegrate(time, keyframe0, keyframe1) {
    var k = keyframe1[CURVE_PRO_TIME] - keyframe0[CURVE_PRO_TIME];
    var m0 = keyframe0[CURVE_PRO_OUT_TANGENT] * k;
    var m1 = keyframe1[CURVE_PRO_IN_TANGENT] * k;
    var t0 = keyframe0[CURVE_PRO_TIME];
    var v0 = keyframe0[CURVE_PRO_VALUE];
    var v1 = keyframe1[CURVE_PRO_VALUE];
    var dt = t0 - time;
    var dt2 = dt * dt;
    var dt3 = dt2 * dt;
    return (m0 + m1 + 2 * v0 - 2 * v1) * dt3 * dt / (4 * k * k * k) +
        (2 * m0 + m1 + 3 * v0 - 3 * v1) * dt3 / (3 * k * k) +
        m0 * dt2 / 2 / k - v0 * dt;
}
function curveValueIntegrateByTime(t1, keyframe0, keyframe1) {
    var k = keyframe1[CURVE_PRO_TIME] - keyframe0[CURVE_PRO_TIME];
    var m0 = keyframe0[CURVE_PRO_OUT_TANGENT] * k;
    var m1 = keyframe1[CURVE_PRO_IN_TANGENT] * k;
    var t0 = keyframe0[CURVE_PRO_TIME];
    var v0 = keyframe0[CURVE_PRO_VALUE];
    var v1 = keyframe1[CURVE_PRO_VALUE];
    var dt = t0 - t1;
    var dt2 = dt * dt;
    var dt3 = dt2 * dt;
    var k2 = k * k;
    var k3 = k2 * k;
    //(30 k^3 v0 (t1^2 - t0^2) + 10 k^2 m0 (t0 + 2 t1) (t0 - t1)^2 + 5 k (t0 + 3 t1) (t0 - t1)^3 (2 m0 + m1 + 3 v0 - 3 v1) + 3 (t0 + 4 t1) (t0 - t1)^4 (m0 + m1 + 2 v0 - 2 v1))/(60 k^3)
    var ret = -30 * k3 * v0 * (t0 + t1) * dt +
        10 * k2 * m0 * (t0 + 2 * t1) * dt2 +
        5 * k * (t0 + 3 * t1) * (2 * m0 + m1 + 3 * v0 - 3 * v1) * dt3 +
        3 * (t0 + 4 * t1) * (m0 + m1 + 2 * v0 - 2 * v1) * dt3 * dt;
    return ret / 60 / k3;
}
function getKeyFrameMetaByRawValue(meta, value) {
    if (value) {
        var type = value[0];
        var keys = value[1];
        if (type === ValueType$1.CURVE) {
            meta.curves.push(keys);
            var keyLen = keys.length;
            if (keys[0][0] > 0) {
                keyLen++;
            }
            if (keys[keys.length - 1][0] < 1) {
                keyLen++;
            }
            meta.index += keyLen;
            meta.max = Math.max(meta.max, keyLen);
            meta.curveCount += keyLen;
        }
        else if (type === ValueType$1.LINE) {
            var keyLen = keys.length;
            if (keyLen === 2 && keys[0][0] === 0 && keys[1][0] === 1) {
                return;
            }
            if (keys[0][0] > 0) {
                keyLen++;
            }
            if (keys[keys.length - 1][0] < 1) {
                keyLen++;
            }
            var uniformCount = Math.ceil(keyLen / 2);
            meta.lineSegCount += uniformCount;
            meta.curves.push(keys);
            meta.index += uniformCount;
            meta.max = Math.max(meta.max, uniformCount);
        }
    }
}
function createKeyFrameMeta() {
    return {
        curves: [],
        index: 0,
        max: 0,
        lineSegCount: 0,
        curveCount: 0,
    };
}

var tempMat3$3 = [];
var tempMat4 = [];
var tempQuat$1 = [];
var seed$e = 1;
var Transform = /** @class */ (function () {
    function Transform(opts, parent) {
        if (opts === void 0) { opts = {}; }
        this.position = [0, 0, 0];
        this.quat = [0, 0, 0, 1];
        this.scale = [1, 1, 1];
        this.worldTRSCache = { dirty: true, position: [0, 0, 0], quat: [0, 0, 0, 1] };
        this.children = [];
        this.worldMat = mat4create();
        this.matrix = mat4create();
        this.dirty = true;
        var _a = opts.name, name = _a === void 0 ? "transform_".concat(seed$e++) : _a;
        this.name = name;
        if (opts) {
            this.setTransform(opts);
        }
        if (parent) {
            this.parentTransform = parent;
        }
    }
    Transform.getRotation = function (out, quat) {
        quatStar(tempQuat$1, quat);
        var m3 = mat3FromQuat(tempMat3$3, tempQuat$1);
        return rotationFromMat3(out, m3);
    };
    Object.defineProperty(Transform.prototype, "parentTransform", {
        get: function () {
            // @ts-expect-error
            return this.pt;
        },
        set: function (transform) {
            if (this.pt) {
                removeItem(this.pt.children, this);
            }
            this.pt = transform;
            if (transform) {
                addItem(transform.children, this);
            }
            if (transform === this) {
                throw Error('set self to parent transform');
            }
            this.dispose();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "rotation", {
        get: function () {
            return Transform.getRotation([], this.quat);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "traceDirty", {
        get: function () {
            var parent = this.parentTransform;
            if (parent && parent.traceDirty) {
                return true;
            }
            return this.dirty;
        },
        enumerable: false,
        configurable: true
    });
    Transform.prototype.update = function () {
        mat4fromRotationTranslationScale(this.matrix, this.quat, this.position, this.scale);
        this.dirty = false;
        this.worldTRSCache.dirty = true;
    };
    Transform.prototype.setTransform = function (opts, reverseEuler) {
        var position = opts.position, rotation = opts.rotation, scale = opts.scale, quat = opts.quat, name = opts.name;
        if (position) {
            this.setPosition(position[0], position[1], position[2]);
        }
        if (quat) {
            this.setQuat(quat[0], quat[1], quat[2], quat[3]);
        }
        else if (rotation) {
            var mul = reverseEuler ? -1 : 1;
            this.setRotation(rotation[0] * mul, rotation[1] * mul, rotation[2] * mul);
        }
        if (scale) {
            this.setScale(scale[0], scale[1], scale[2]);
        }
        if (name) {
            this.name = name;
        }
    };
    Transform.prototype.setQuat = function (x, y, z, w) {
        this.dirty = true;
        this.quat[0] = x;
        this.quat[1] = y;
        this.quat[2] = z;
        this.quat[3] = w;
    };
    Transform.prototype.setPosition = function (x, y, z) {
        this.position[0] = x;
        this.position[1] = y;
        this.position[2] = z;
        this.dispose();
    };
    Transform.prototype.setRotation = function (x, y, z) {
        quatFromRotation(this.quat, x, y, z);
        quatStar(this.quat, this.quat);
        this.dispose();
    };
    Transform.prototype.setScale = function (x, y, z) {
        this.scale[0] = x;
        this.scale[1] = y;
        this.scale[2] = z;
        this.dispose();
    };
    Transform.prototype.getMatrix = function () {
        if (this.dirty) {
            this.update();
        }
        return this.matrix;
    };
    Transform.prototype.getWorldMatrix = function (out) {
        var parent = this.parentTransform;
        var worldMat;
        if (parent && (!this.parentMat || parent.traceDirty)) {
            this.parentMat = parent.getWorldMatrix(parent.worldMat);
            this.worldScale = this.getWorldScale();
            this.dirty = true;
        }
        if (this.parentMat) {
            if (this.traceDirty) {
                this.worldMat = mat4multiply(this.worldMat, this.parentMat, this.getMatrix());
                this.worldTRSCache.dirty = true;
            }
            worldMat = this.worldMat;
        }
        else {
            worldMat = this.getMatrix();
        }
        return worldMat === out ? worldMat : mat4Clone(out || tempMat4, worldMat);
    };
    Transform.prototype.assignWorldTRS = function (position, quat, scale) {
        var matrix = this.getWorldMatrix(this.worldMat);
        var scaling = this.worldScale || this.scale;
        var cache = this.worldTRSCache;
        if (cache.dirty) {
            getMat4TR(matrix, cache.position, cache.quat, scaling);
            cache.dirty = false;
        }
        if (position) {
            vecAssign(position, cache.position, 3);
        }
        if (quat) {
            vecAssign(quat, cache.quat, 4);
        }
        if (scale) {
            vecAssign(scale, scaling, 3);
        }
    };
    Transform.prototype.getWorldScale = function (out) {
        var _a;
        if (out === void 0) { out = [1, 1, 1]; }
        return vecMulCombine(out, this.scale, (_a = this.parentTransform) === null || _a === void 0 ? void 0 : _a.getWorldScale(out));
    };
    Transform.prototype.fromMat4 = function (m4, scale) {
        if (scale) {
            getMat4TR(m4, this.position, this.quat, scale);
            vecAssign(this.scale, scale, 3);
        }
        else {
            getMat4TRS(m4, this.position, this.quat, this.scale);
        }
        this.dirty = true;
        return this;
    };
    Transform.prototype.dispose = function () {
        this.dirty = true;
        this.parentMat = undefined;
        this.children.forEach(function (c) { return c.dispose(); });
    };
    return Transform;
}());

/**
 * 所有元素的继承的抽象类
 */
var VFXItem = /** @class */ (function () {
    function VFXItem(props, composition) {
        /**
         * 元素优先级
         */
        this._v_priority = 0;
        /**
         * 元素可见性，该值的改变会触发 `handleVisibleChanged` 回调
         * @protected
         */
        this.visible = true;
        /**
         * 是否允许渲染，元素生命周期开始后为 true，结束时为 false
         * @protected
         */
        this._contentVisible = false;
        /**
         * 合成元素当前的时间，单位毫秒
         * @protected
         */
        this.timeInms = 0;
        /**
         * 元素冻结属性，冻结后停止计算/更新数据
         */
        this._frozen = false;
        var id = props.id, name = props.name, delay = props.delay, parentId = props.parentId, endBehavior = props.endBehavior, transform = props.transform, _a = props.listIndex, listIndex = _a === void 0 ? 0 : _a, _b = props.duration, duration = _b === void 0 ? 0 : _b;
        var reusable = composition.reusable, rootTransform = composition.rootTransform;
        this.composition = composition;
        this.id = id;
        this.name = name;
        this.reusable = reusable;
        this.delay = delay;
        this.transform = new Transform(transform);
        this.parentId = parentId;
        this.duration = duration;
        this.delayInms = (delay || 0) * 1000;
        this.durInms = this.duration * 1000;
        this.endBehavior = endBehavior;
        this.lifetime = -(this.delayInms / this.durInms);
        this.listIndex = listIndex;
        this.transform.parentTransform = rootTransform;
        this.onConstructed(props);
        this.transform.name = this.name;
        if (duration <= 0) {
            throw Error("Item duration can't be less than 0, see ".concat(HELP_LINK$1['Item duration can\'t be less than 0']));
        }
    }
    Object.defineProperty(VFXItem.prototype, "contentVisible", {
        /**
         * 元素内容可见性
         */
        get: function () {
            return this._contentVisible && this.visible;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VFXItem.prototype, "content", {
        /**
         * 返回元素创建的数据
         */
        get: function () {
            // @ts-expect-error
            return this._content;
        },
        /**
         * 设置元素数据
         */
        set: function (t) {
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VFXItem.prototype, "type", {
        /**
         * 获取元素类型
         */
        get: function () {
            return ItemType$1.base;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VFXItem.prototype, "frozen", {
        /**
         * 获取元素冻结属性
         */
        get: function () {
            return this._frozen;
        },
        /**
         * 设置元素冻结属性
         */
        set: function (v) {
            this.handleFrozenChanged(this._frozen = !!v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VFXItem.prototype, "lifetimeStarted", {
        /**
         * 获取元素生命周期是否开始
         */
        get: function () {
            return this.started && !this.delaying;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 重置元素状态属性
     */
    VFXItem.prototype.start = function () {
        if (!this.started || this.ended) {
            this.started = true;
            this.delaying = true;
            this.timeInms = 0;
            this.callEnd = false;
            this.ended = false;
        }
    };
    /**
     * 停止播放元素动画
     */
    VFXItem.prototype.stop = function () {
        this.doStop();
        this.started = false;
    };
    VFXItem.prototype.doStop = function () {
        if (this._content && this._content.stop) {
            this._content.stop();
        }
    };
    /**
     * 创建元素内容，此函数可以在任何时间被调用
     * 第一帧渲染前会被调用
     * @returns
     */
    VFXItem.prototype.createContent = function () {
        if (!this._content) {
            this._content = this.doCreateContent(this.composition);
        }
        return this._content;
    };
    /**
     * 创建元素的内容
     * @override
     * @param composition
     * @returns
     */
    VFXItem.prototype.doCreateContent = function (composition) {
        return undefined;
    };
    /**
     * 元素构造函数调用时将调用该函数
     * @param options
     * @override
     */
    VFXItem.prototype.onConstructed = function (options) {
        // OVERRIDE
    };
    /**
     * 内部使用的更新回调，请不要重写此方法，重写 `onItemUpdate` 方法
     * @param dt
     */
    VFXItem.prototype.onUpdate = function (dt) {
        var _a, _b;
        if (this.started && !this.frozen && this.composition) {
            var time = (this.timeInms += dt);
            var now = time - this.delayInms;
            this.transform.dispose();
            if (this.delaying && now >= 0) {
                this.delaying = false;
                this.createContent();
                this.onLifetimeBegin(this.composition, this.content);
                this.composition.itemLifetimeEvent(this, true);
            }
            if (!this.delaying) {
                var endBehavior = this.endBehavior;
                var lifetime = now / this.durInms;
                var ended = this.isEnded(now);
                var shouldUpdate = true;
                if (ended) {
                    shouldUpdate = false;
                    if (!this.callEnd) {
                        this.callEnd = true;
                        this.composition.itemLifetimeEvent(this, false);
                        this.onEnd();
                    }
                    if (endBehavior !== END_BEHAVIOR_FORWARD$1 && endBehavior !== END_BEHAVIOR_RESTART$1) {
                        this.ended = true;
                        if (endBehavior === END_BEHAVIOR_PAUSE$1 ||
                            endBehavior === END_BEHAVIOR_PAUSE_AND_DESTROY$1) {
                            (_b = (_a = this.composition).handlePlayerPause) === null || _b === void 0 ? void 0 : _b.call(_a, this);
                        }
                        else if (endBehavior === END_BEHAVIOR_FREEZE$1) {
                            shouldUpdate = true;
                            lifetime = 1;
                        }
                        if (!this.reusable) {
                            if (endBehavior === END_BEHAVIOR_DESTROY$1 ||
                                endBehavior === END_BEHAVIOR_PAUSE_AND_DESTROY$1 ||
                                endBehavior === END_BEHAVIOR_DESTROY_CHILDREN$1) {
                                return this.dispose();
                            }
                            else if (endBehavior === END_BEHAVIOR_PAUSE$1) {
                                this.endBehavior = END_BEHAVIOR_FORWARD$1;
                            }
                        }
                        else if (endBehavior === END_BEHAVIOR_DESTROY$1) {
                            this.setVisible(false);
                        }
                        lifetime = Math.min(lifetime, 1);
                    }
                    else {
                        shouldUpdate = true;
                        if (endBehavior === END_BEHAVIOR_RESTART$1) {
                            this.ended = true;
                            lifetime = lifetime % 1;
                        }
                    }
                }
                else if (this.callEnd && this.reusable) {
                    this.setVisible(true);
                    this.callEnd = false;
                }
                this.lifetime = lifetime;
                shouldUpdate && this.onItemUpdate(dt, lifetime);
            }
        }
    };
    /**
     * 元素结束时的回调
     * @override
     * @param composition
     * @param content
     */
    VFXItem.prototype.onItemRemoved = function (composition, content) {
        // OVERRIDE
    };
    /**
     * 元素更新函数，在 Composition 对象的 tick 函数中被调用
     * @override
     * @param dt
     * @param lifetime
     */
    VFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        // OVERRIDE
    };
    /**
     * 元素 doCreateContent 函数调用后会立即调用该函数用于初始化数据
     * @override
     * @param composition
     * @param content
     */
    VFXItem.prototype.onLifetimeBegin = function (composition, content) {
        // OVERRIDE
    };
    /**
     * 元素动画结束播放时回调函数
     * @override
     */
    VFXItem.prototype.onEnd = function () {
        // OVERRIDE
    };
    /**
     * 获取元素显隐属性
     */
    VFXItem.prototype.getVisible = function () {
        return this.visible;
    };
    /**
     * 设置元素显隐属性 会触发 `handleVisibleChanged` 回调
     */
    VFXItem.prototype.setVisible = function (visible) {
        if (this.visible !== visible) {
            this.visible = !!visible;
            this.handleVisibleChanged(this.visible);
        }
    };
    /**
     * 元素显隐属性改变时调用的函数，当 visible 为 true 时，务必显示元素
     * @param visible
     * @override
     */
    VFXItem.prototype.handleVisibleChanged = function (visible) {
        // OVERRIDE
    };
    /**
     * 元素冻结属性改变时调用的函数
     * @param frozen
     * @override
     */
    VFXItem.prototype.handleFrozenChanged = function (frozen) {
        // OVERRIDE
    };
    /**
     * 获取元素变换包括位置、旋转、缩放
     * @param transform 将元素变换拷贝到该对象，并将其作为返回值
     * @returns 元素变换的拷贝
     */
    VFXItem.prototype.getWorldTransform = function (transform) {
        return (transform !== null && transform !== void 0 ? transform : new Transform()).fromMat4(this.transform.getWorldMatrix());
    };
    /**
     * 获取元素用于计算光线投射的面片类型和参数
     * @override
     * @param force 元素没有开启交互也返回参数
     */
    VFXItem.prototype.getHitTestParams = function (force) {
        // OVERRIDE
    };
    /**
     * 获取元素当前世界坐标
     */
    VFXItem.prototype.getCurrentPosition = function () {
        var pos = [0, 0, 0];
        this.transform.assignWorldTRS(pos);
        return pos;
    };
    /**
     * 是否到达元素的结束时间
     * @param now
     * @returns
     */
    VFXItem.prototype.isEnded = function (now) {
        // at least 1 ms
        return now - this.durInms > 0.001;
    };
    /**
     * 重置元素，元素创建的内容将会被销毁
     */
    VFXItem.prototype.reset = function () {
        if (this.composition) {
            this.onItemRemoved(this.composition, this._content);
            this._content = undefined;
        }
        this.started = false;
    };
    /**
     * 销毁元素
     */
    VFXItem.prototype.dispose = function () {
        if (this.composition) {
            this.composition.destroyItem(this);
            this.reset();
            this.onUpdate = function () { return -1; };
            this.composition = null;
            this.transform = new Transform();
        }
    };
    return VFXItem;
}());
/**
 * 根据元素的类型创建对应的 `VFXItem` 实例
 * @param props
 * @param composition
 */
function createVFXItem(props, composition) {
    var type = props.type;
    var pluginName = props.pluginName;
    if (!pluginName) {
        switch (type) {
            case ItemType$1.null || type === ItemType$1.base:
                pluginName = 'cal';
                break;
            case ItemType$1.sprite:
                pluginName = 'sprite';
                break;
            case ItemType$1.particle:
                pluginName = 'particle';
                break;
            case ItemType$1.interact:
                pluginName = 'interact';
                break;
            case ItemType$1.camera:
                pluginName = 'camera';
                break;
            case ItemType$1.filter:
                pluginName = 'filter';
                break;
            case VFX_ITEM_TYPE_TREE:
                pluginName = VFX_ITEM_TYPE_TREE;
                break;
            default:
                throw new Error('invalid vfx item type');
        }
    }
    return composition.pluginSystem.createPluginItem(pluginName, props, composition);
}

var pluginLoaderMap = {};
var defaultPlugins = [];
var pluginCtrlMap = {};
/**
 * 注册 plugin
 * @param name
 * @param pluginClass class of plugin
 * @param itemClass class of item
 * @param isDefault load
 */
function registerPlugin(name, pluginClass, itemClass, isDefault) {
    pluginCtrlMap[name] = itemClass;
    pluginLoaderMap[name] = pluginClass;
    if (isDefault) {
        addItem(defaultPlugins, name);
    }
}
function unregisterPlugin(name) {
    delete pluginCtrlMap[name];
    delete pluginLoaderMap[name];
    removeItem(defaultPlugins, name);
}
var PluginSystem = /** @class */ (function () {
    function PluginSystem(pluginNames) {
        var loaders = {};
        var loaded = [];
        var addLoader = function (name) {
            var loader = pluginLoaderMap[name];
            if (!loaded.includes(loader)) {
                loaded.push(loader);
                loaders[name] = loader;
            }
        };
        defaultPlugins.forEach(addLoader);
        pluginNames.forEach(addLoader);
        this.plugins = Object.keys(loaders)
            .map(function (name) {
            var CTRL = pluginLoaderMap[name];
            if (!CTRL) {
                throw new Error("plugin '".concat(name, "' not found"));
            }
            var loader = new CTRL();
            loader.name = name;
            return loader;
        })
            .sort(function (a, b) { return a.order - b.order; });
    }
    PluginSystem.prototype.initializeComposition = function (composition, scene) {
        this.plugins.forEach(function (loader) { return loader.onCompositionConstructed(composition, scene); });
    };
    PluginSystem.prototype.destroyComposition = function (comp) {
        this.plugins.forEach(function (loader) { return loader.onCompositionDestroyed(comp); });
    };
    PluginSystem.prototype.resetComposition = function (comp, renderFrame) {
        this.plugins.forEach(function (loader) { return loader.onCompositionReset(comp, renderFrame); });
    };
    PluginSystem.prototype.createPluginItem = function (name, props, composition) {
        var CTRL = pluginCtrlMap[name];
        if (!CTRL) {
            throw new Error("plugin ".concat(name, " no registered constructor"));
        }
        var item = new CTRL(props, composition);
        if (!(item instanceof VFXItem)) {
            throw new Error("plugin ".concat(name, " invalid constructor type"));
        }
        return item;
    };
    PluginSystem.prototype.processRawJSON = function (json, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.callStatic('processRawJSON', json, options)];
            });
        });
    };
    PluginSystem.prototype.callStatic = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var pendings, plugins, i, plugin, ctrl;
            return __generator(this, function (_a) {
                pendings = [];
                plugins = this.plugins;
                for (i = 0; i < plugins.length; i++) {
                    plugin = plugins[i];
                    ctrl = pluginLoaderMap[plugin.name];
                    if (name in ctrl) {
                        pendings.push(Promise.resolve(ctrl[name].apply(ctrl, __spreadArray([], __read$1(args), false))));
                    }
                }
                return [2 /*return*/, Promise.all(pendings)];
            });
        });
    };
    PluginSystem.prototype.precompile = function (compositions, shaderLibrary) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.callStatic('precompile', compositions, shaderLibrary)];
            });
        });
    };
    PluginSystem.prototype.loadResources = function (scene, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.callStatic('prepareResource', scene, options)];
            });
        });
    };
    return PluginSystem;
}());

/**
 * 抽象插件类
 * 注册合成不同生命周期的回调函数
 */
var AbstractPlugin = /** @class */ (function () {
    function AbstractPlugin() {
        this.order = 100;
        this.name = '';
    }
    /**
     * 在加载到 JSON 后，就可以进行提前编译
     * @param json
     * @param player
     */
    AbstractPlugin.precompile = function (compositions, shaderLibrary) {
        return Promise.resolve();
    };
    AbstractPlugin.prototype.onCompositionConstructed = function (composition, scene) { };
    AbstractPlugin.prototype.onCompositionItemLifeBegin = function (composition, item) { };
    AbstractPlugin.prototype.onCompositionItemLifeEnd = function (composition, item) { };
    AbstractPlugin.prototype.onCompositionItemRemoved = function (composition, item) { };
    AbstractPlugin.prototype.onCompositionReset = function (composition, frame) { };
    AbstractPlugin.prototype.onCompositionWillReset = function (composition, frame) { };
    AbstractPlugin.prototype.onCompositionDestroyed = function (composition) { };
    AbstractPlugin.prototype.onCompositionUpdate = function (composition, dt) { };
    AbstractPlugin.prototype.prepareRenderFrame = function (composition, frame) {
        return false;
    };
    AbstractPlugin.prototype.postProcessFrame = function (composition, frame) { };
    return AbstractPlugin;
}());

var CameraController = /** @class */ (function () {
    function CameraController(transform, model) {
        this.transform = transform;
        var _a = transform.position, position = _a === void 0 ? [0, 0, 0] : _a, _b = transform.rotation, rotation = _b === void 0 ? [0, 0, 0] : _b;
        var _c = model.options, near = _c.near, far = _c.far, fov = _c.fov, clipMode = _c.clipMode;
        this.clipMode = clipMode;
        this.options = {
            position: vecAssign([0, 0, 0], position, 3),
            rotation: vecAssign([0, 0, 0], rotation, 3),
            near: createValueGetter(near),
            far: createValueGetter(far),
            fov: createValueGetter(fov),
        };
        if (model.positionOverLifetime) {
            var _d = model.positionOverLifetime, path = _d.path, _e = _d.linearX, linearX = _e === void 0 ? 0 : _e, _f = _d.linearY, linearY = _f === void 0 ? 0 : _f, _g = _d.linearZ, linearZ = _g === void 0 ? 0 : _g;
            this.translateOverLifetime = {
                path: path && createValueGetter(path),
                x: createValueGetter(linearX),
                y: createValueGetter(linearY),
                z: createValueGetter(linearZ),
            };
        }
        if (model.rotationOverLifetime) {
            var _h = model.rotationOverLifetime, separateAxes = _h.separateAxes, _j = _h.x, x = _j === void 0 ? 0 : _j, _k = _h.y, y = _k === void 0 ? 0 : _k, _l = _h.z, z = _l === void 0 ? 0 : _l;
            this.rotationOverLifetime = {
                separateAxes: separateAxes,
                x: createValueGetter(x),
                y: createValueGetter(y),
                z: createValueGetter(z),
            };
        }
    }
    CameraController.prototype.update = function (lifetime) {
        var quat = [0, 0, 0, 1], position = [0, 0, 0], rotation = [0, 0, 0];
        vecAssign(position, this.options.position, 3);
        vecAssign(rotation, this.options.rotation, 3);
        var translateOverLifetime = this.translateOverLifetime;
        var rotationOverLifetime = this.rotationOverLifetime;
        lifetime = clamp$1(lifetime, 0, 1);
        if (translateOverLifetime) {
            position[0] += translateOverLifetime.x.getValue(lifetime);
            position[1] += translateOverLifetime.y.getValue(lifetime);
            position[2] += translateOverLifetime.z.getValue(lifetime);
            if (translateOverLifetime.path) {
                vecAdd(position, position, translateOverLifetime.path.getValue(lifetime));
            }
        }
        if (rotationOverLifetime) {
            var z = rotationOverLifetime.z.getValue(lifetime);
            rotation[2] += z;
            if (rotationOverLifetime.separateAxes) {
                rotation[0] += rotationOverLifetime.x.getValue(lifetime);
                rotation[1] += rotationOverLifetime.y.getValue(lifetime);
            }
            else {
                rotation[0] += z;
                rotation[1] += z;
            }
        }
        this.far = this.options.far.getValue(lifetime);
        this.near = this.options.near.getValue(lifetime);
        this.fov = this.options.fov.getValue(lifetime);
        this.transform.setPosition(position[0], position[1], position[2]);
        this.transform.setRotation(rotation[0], rotation[1], rotation[2]);
        this.transform.assignWorldTRS(position, quat);
        this.position = position;
        this.rotation = Transform.getRotation(rotation, quat);
    };
    return CameraController;
}());

var CameraVFXItemLoader = /** @class */ (function (_super) {
    __extends(CameraVFXItemLoader, _super);
    function CameraVFXItemLoader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CameraVFXItemLoader;
}(AbstractPlugin));

var CameraVFXItem = /** @class */ (function (_super) {
    __extends(CameraVFXItem, _super);
    function CameraVFXItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CameraVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.camera;
        },
        enumerable: false,
        configurable: true
    });
    CameraVFXItem.prototype.onConstructed = function (props) {
        this.model = props.content;
    };
    CameraVFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        var _a;
        (_a = this.controller) === null || _a === void 0 ? void 0 : _a.update(lifetime);
        this.updateCamera();
    };
    // override onEnd () {
    //   this.controller?.update(1);
    //   this.updateCamera();
    // }
    CameraVFXItem.prototype.updateCamera = function () {
        if (this.controller && this.composition) {
            var camera = this.composition.camera;
            camera.near = this.controller.near;
            camera.far = this.controller.far;
            camera.fov = this.controller.fov;
            camera.clipMode = this.controller.clipMode;
            camera.position = this.controller.position;
            camera.rotation = this.controller.rotation;
        }
    };
    CameraVFXItem.prototype.getCurrentPosition = function () {
        return this.controller.position;
    };
    CameraVFXItem.prototype.doCreateContent = function () {
        if (!this.controller) {
            this.controller = new CameraController(this.transform, this.model);
        }
        return this.controller;
    };
    return CameraVFXItem;
}(VFXItem));

exports.HitTestType = void 0;
(function (HitTestType) {
    HitTestType[HitTestType["triangle"] = 1] = "triangle";
    HitTestType[HitTestType["box"] = 2] = "box";
    HitTestType[HitTestType["sphere"] = 3] = "sphere";
    HitTestType[HitTestType["custom"] = 4] = "custom";
})(exports.HitTestType || (exports.HitTestType = {}));

var EVENT_TYPE_CLICK = 'click';
var EVENT_TYPE_TOUCH_START = 'touchstart';
var EVENT_TYPE_TOUCH_MOVE = 'touchmove';
var EVENT_TYPE_TOUCH_END = 'touchend';
var InteractBehavior$1 = InteractBehavior$2;
var EventSystem = /** @class */ (function () {
    function EventSystem(target) {
        this.enabled = true;
        this.handlers = {};
        this.nativeHandlers = {};
        this.target = target;
    }
    EventSystem.prototype.bindListeners = function () {
        var _a;
        var _this = this;
        var x;
        var y;
        var currentTouch;
        var lastTouch;
        var getTouch;
        getTouch = function (event) {
            return event;
        };
        var touchstart = 'mousedown';
        var touchmove = 'mousemove';
        var touchend = 'mouseup';
        var getTouchEventValue = function (event, x, y, dx, dy) {
            if (dx === void 0) { dx = 0; }
            if (dy === void 0) { dy = 0; }
            var _a = _this.target, width = _a.width, height = _a.height;
            var ts = performance.now();
            var vx = 0;
            var vy = 0;
            if (lastTouch) {
                var dt = ts - lastTouch.ts;
                vx = ((dx - lastTouch.dx) / dt) || 0;
                vy = ((dy - lastTouch.dy) / dt) || 0;
                lastTouch = { dx: dx, dy: dy, ts: ts };
            }
            return { x: x, y: y, vx: vx, vy: vy, dx: dx, dy: dy, ts: ts, width: width, height: height, origin: event };
        };
        if (isSimulatorCellPhone()) {
            getTouch = function (event) {
                var _a = event, touches = _a.touches, changedTouches = _a.changedTouches;
                return touches[0] || changedTouches[0];
            };
            touchstart = 'touchstart';
            touchmove = 'touchmove';
            touchend = 'touchend';
        }
        this.nativeHandlers = (_a = {},
            _a[touchstart] = function (event) {
                if (_this.enabled) {
                    var touch = getTouch(event);
                    var cood = getCoord(touch);
                    x = cood.x;
                    y = cood.y;
                    lastTouch = currentTouch = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        ts: performance.now(),
                        x: x,
                        y: y,
                    };
                    _this.dispatchEvent(EVENT_TYPE_TOUCH_START, getTouchEventValue(event, x, y));
                }
            },
            _a[touchmove] = function (event) {
                if (currentTouch && _this.enabled) {
                    var cood = getCoord(getTouch(event));
                    x = cood.x;
                    y = cood.y;
                    _this.dispatchEvent(EVENT_TYPE_TOUCH_MOVE, getTouchEventValue(event, x, y, x - currentTouch.x, y - currentTouch.y));
                }
            },
            _a[touchend] = function (event) {
                if (currentTouch && _this.enabled) {
                    if (event.cancelable) {
                        // if player is interactive, all events will be handled in side
                        event.preventDefault();
                        event.stopPropagation();
                    }
                    var touch = getTouch(event);
                    var cood = getCoord(touch);
                    var dt = Math.abs(currentTouch.clientX - touch.clientX) + Math.abs(currentTouch.clientY - touch.clientY);
                    x = cood.x;
                    y = cood.y;
                    if (dt < 4) {
                        _this.dispatchEvent(EVENT_TYPE_CLICK, getTouchEventValue(event, x, y));
                    }
                    _this.dispatchEvent(EVENT_TYPE_TOUCH_END, getTouchEventValue(event, x, y, x - currentTouch.x, y - currentTouch.y));
                }
                currentTouch = 0;
            },
            _a);
        Object.keys(this.nativeHandlers).forEach(function (name) {
            var _a;
            (_a = _this.target) === null || _a === void 0 ? void 0 : _a.addEventListener(String(name), _this.nativeHandlers[name]);
        });
    };
    EventSystem.prototype.dispatchEvent = function (type, event) {
        var handlers = this.handlers[type];
        handlers === null || handlers === void 0 ? void 0 : handlers.forEach(function (fn) { return fn(event); });
    };
    EventSystem.prototype.addEventListener = function (type, callback) {
        var handlers = this.handlers[type];
        if (!handlers) {
            handlers = this.handlers[type] = [];
        }
        addItem(handlers, callback);
        return function () {
            removeItem(handlers, callback);
        };
    };
    EventSystem.prototype.removeEventListener = function (type, callback) {
        var handlers = this.handlers[type];
        if (handlers) {
            removeItem(handlers, callback);
        }
    };
    EventSystem.prototype.dispose = function () {
        var _this = this;
        if (this.target) {
            this.handlers = {};
            Object.keys(this.nativeHandlers).forEach(function (name) {
                var _a;
                (_a = _this.target) === null || _a === void 0 ? void 0 : _a.removeEventListener(String(name), _this.nativeHandlers[name]);
            });
            this.nativeHandlers = {};
            this.target = null;
        }
    };
    return EventSystem;
}());
function getCoord(event) {
    var ele = event.target;
    var clientX = event.clientX, clientY = event.clientY;
    var _a = ele.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;
    var x = ((clientX - left) / width) * 2 - 1;
    var y = 1 - ((clientY - top) / height) * 2;
    return { x: x, y: y };
}

var RUNTIME_ENV = 'runtime_env';
var RENDER_PREFER_LOOKUP_TEXTURE = 'lookup_texture';
// 数据模板使用 offscreen canvas 绘制
var TEMPLATE_USE_OFFSCREEN_CANVAS = 'offscreen_canvas';
if (typeof __CONFIG__ === 'undefined') {
    if (typeof window === 'object') {
        //@ts-expect-error
        window.__CONFIG__ = {};
    }
    else {
        //@ts-expect-error
        global.__CONFIG__ = {};
    }
}
var config = __CONFIG__;
function getConfig(name) {
    return config[name];
}
function setConfig(name, value) {
    return config[name] = value;
}

exports.ShaderType = void 0;
(function (ShaderType) {
    ShaderType[ShaderType["vertex"] = 0] = "vertex";
    ShaderType[ShaderType["fragment"] = 1] = "fragment";
})(exports.ShaderType || (exports.ShaderType = {}));

var copyFrag = "uniform vec2 uFilterSourceSize;uniform sampler2D uFilterSource;\n#define INTERPOLATION 1\nvec4 filterMain(vec2 texCoord,sampler2D tex){\n#ifdef INTERPOLATION\nvec2 texInPixel=texCoord*uFilterSourceSize;vec2 coordMin=floor(texInPixel);vec2 pp=texInPixel-coordMin;vec4 fCoord=vec4(coordMin/uFilterSourceSize,(coordMin+vec2(1.))/uFilterSourceSize);vec4 cLT=texture2D(uFilterSource,vec2(fCoord.x,fCoord.w));vec4 cLB=texture2D(uFilterSource,vec2(fCoord.x,fCoord.y));vec4 cRT=texture2D(uFilterSource,vec2(fCoord.z,fCoord.w));vec4 cRB=texture2D(uFilterSource,vec2(fCoord.z,fCoord.y));return mix(mix(cLB,cRB,pp.x),mix(cLT,cRT,pp.x),pp.y);\n#else\nreturn texture2D(uFilterSource,texCoord);\n#endif\n}";

exports.ShaderCompileResultStatus = void 0;
(function (ShaderCompileResultStatus) {
    ShaderCompileResultStatus[ShaderCompileResultStatus["noShader"] = 0] = "noShader";
    ShaderCompileResultStatus[ShaderCompileResultStatus["success"] = 1] = "success";
    ShaderCompileResultStatus[ShaderCompileResultStatus["fail"] = 2] = "fail";
    ShaderCompileResultStatus[ShaderCompileResultStatus["compiling"] = 3] = "compiling";
})(exports.ShaderCompileResultStatus || (exports.ShaderCompileResultStatus = {}));
exports.GLSLVersion = void 0;
(function (GLSLVersion) {
    GLSLVersion["GLSL1"] = "100";
    GLSLVersion["GLSL3"] = "300 es";
})(exports.GLSLVersion || (exports.GLSLVersion = {}));
var Shader = /** @class */ (function () {
    function Shader(source) {
        this.source = source;
    }
    return Shader;
}());

var MARS_COPY_MESH_NAME = 'mars-internal-copy';
var COPY_MESH_SHADER_ID = 'mars-internal-copy-mesh';
var COPY_VERTEX_SHADER = "\n#ifdef WEBGL2\n#define vsIn in\n#define vsOut out\n#else\n#define vsIn attribute\n#define vsOut varying\n#endif\nprecision highp float;\nvsIn vec2 aPos;\nvsOut vec2 vTex;\nvoid main(){\n    gl_Position = vec4(aPos,0.,1.0);\n    vTex = (aPos + vec2(1.0))/2.;\n}";
var COPY_FRAGMENT_SHADER = "precision mediump float;\n#ifdef WEBGL2\n#define fsIn in\n#define fsOut out\n#define texture2D texture\n#else\n#define fsIn varying\n#endif\n".concat(copyFrag, "\nfsIn vec2 vTex;\n#ifdef WEBGL2\nlayout (location = 0) out vec4 fragColor;\n#else\n#define fragColor gl_FragColor\n#endif\n\n#ifdef DEPTH_TEXTURE\nuniform sampler2D uDepth;\n#ifndef WEBGL2\n#extension GL_EXT_frag_depth : enable\n#define gl_FragDepth gl_FragDepthEXT\n#endif\n#endif\nvoid main(){\n    fragColor = filterMain(vTex,uFilterSource);\n    #ifdef DEPTH_TEXTURE\n    gl_FragDepth = texture2D(uDepth,vTex).r;\n    #endif\n}\n");
function createCopyShader(webgl2, writeDepth) {
    var version = webgl2 ? '#version 300 es' : '';
    return {
        name: MARS_COPY_MESH_NAME,
        vertex: createShaderWithMarcos([], version + '\n' + COPY_VERTEX_SHADER, exports.ShaderType.vertex),
        fragment: createShaderWithMarcos([], version + '\n' + COPY_FRAGMENT_SHADER, exports.ShaderType.fragment),
        glslVersion: webgl2 ? exports.GLSLVersion.GLSL3 : exports.GLSLVersion.GLSL1,
        marcos: [
            ['WEBGL2', !!webgl2],
            ['DEPTH_TEXTURE', !!writeDepth],
        ],
        // @ts-expect-error
        cacheId: COPY_MESH_SHADER_ID + (+writeDepth),
    };
}

exports.TextureLoadAction = void 0;
(function (TextureLoadAction) {
    TextureLoadAction[TextureLoadAction["whatever"] = 0] = "whatever";
    //preserve previous attachment
    //load = 1,
    //clear attachment
    TextureLoadAction[TextureLoadAction["clear"] = 2] = "clear";
})(exports.TextureLoadAction || (exports.TextureLoadAction = {}));
exports.TextureSourceType = void 0;
(function (TextureSourceType) {
    TextureSourceType[TextureSourceType["none"] = 0] = "none";
    TextureSourceType[TextureSourceType["data"] = 1] = "data";
    TextureSourceType[TextureSourceType["image"] = 2] = "image";
    TextureSourceType[TextureSourceType["compressed"] = 3] = "compressed";
    TextureSourceType[TextureSourceType["video"] = 4] = "video";
    TextureSourceType[TextureSourceType["canvas"] = 5] = "canvas";
    TextureSourceType[TextureSourceType["framebuffer"] = 6] = "framebuffer";
    TextureSourceType[TextureSourceType["mipmaps"] = 7] = "mipmaps";
})(exports.TextureSourceType || (exports.TextureSourceType = {}));

/**
 * 负责下载 Mars 中的各种资源，并提供了一些异步加载和缓存管理的功能
 */
var Downloader = /** @class */ (function () {
    function Downloader() {
        /**
         * 存储多个回调函数的对象
         */
        this.callbacks = {};
    }
    /**
     * 下载一个 JSON 文件
     * @param url - 要下载的 JSON 文件的 URL
     * @param onSuccess - 下载成功后的回调函数
     * @param onError - 下载失败后的回调函数
     */
    Downloader.prototype.downloadJSON = function (url, onSuccess, onError) {
        this.download(url, 'json', onSuccess, onError);
    };
    /**
     * 下载一个二进制文件
     * @param url - 要下载的二进制文件的 URL
     * @param onSuccess - 下载成功后的回调函数
     * @param onError - 下载失败后的回调函数
     */
    Downloader.prototype.downloadBinary = function (url, onSuccess, onError) {
        this.download(url, 'arraybuffer', onSuccess, onError);
    };
    /**
     * 下载一个 Blob 文件
     * @param url - 要下载的 Blob 文件的 URL
     * @param onSuccess - 下载成功后的回调函数
     * @param onError - 下载失败后的回调函数
     */
    Downloader.prototype.downloadBlob = function (url, onSuccess, onError) {
        this.download(url, 'blob', onSuccess, onError);
    };
    Downloader.prototype.download = function (url, responseType, onSuccess, onError) {
        var _this = this;
        if (responseType === void 0) { responseType = 'json'; }
        if (this.start(url, onSuccess, onError)) {
            return;
        }
        var xhr = new XMLHttpRequest();
        var handleError = function () {
            _this.finish(url, xhr.status, xhr.response);
        };
        var handleLoad = function () {
            if (xhr.status == 200 || xhr.status == 0) {
                _this.finish(url, 200, xhr.response);
            }
            else {
                handleError();
            }
        };
        xhr.responseType = responseType;
        xhr.addEventListener('load', handleLoad);
        xhr.addEventListener('error', handleError);
        xhr.open('GET', url, true);
        xhr.send();
    };
    Downloader.prototype.start = function (url, onSuccess, onError) {
        var callbacks = this.callbacks[url];
        try {
            if (callbacks) {
                return true;
            }
            this.callbacks[url] = callbacks = [];
        }
        finally {
            callbacks.push(onSuccess, onError);
        }
    };
    Downloader.prototype.finish = function (url, status, data) {
        var callbacks = this.callbacks[url];
        delete this.callbacks[url];
        var args = status == 200 || status == 0 ? [data] : [status, data];
        for (var i = args.length - 1, n = callbacks.length; i < n; i += 2) {
            callbacks[i].apply(null, args);
        }
    };
    return Downloader;
}());
var webPFailed = false;
/**
 * 异步加载一个 WebP 图片文件，如果不支持 WebP，则加载 PNG 图片文件
 * @param png - PNG 图片文件的 URL
 * @param webp - WebP 图片文件的 URL
 */
function loadWebPOptional(png, webp) {
    return __awaiter(this, void 0, void 0, function () {
        var image, image, image;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(webPFailed || !webp)) return [3 /*break*/, 2];
                    return [4 /*yield*/, loadImage(png)];
                case 1:
                    image = _a.sent();
                    return [2 /*return*/, { image: image, url: png }];
                case 2:
                    _a.trys.push([2, 4, , 6]);
                    return [4 /*yield*/, loadImage(webp)];
                case 3:
                    image = _a.sent();
                    return [2 /*return*/, { image: image, url: webp }];
                case 4:
                    _a.sent();
                    webPFailed = true;
                    return [4 /*yield*/, loadImage(png)];
                case 5:
                    image = _a.sent();
                    return [2 /*return*/, { image: image, url: png }];
                case 6: return [2 /*return*/];
            }
        });
    });
}
/**
 * 异步加载一个图片文件
 * @param source - 图片文件的 URL、Blob 或 HTMLImageElement 对象
 */
function loadImage(source) {
    return __awaiter(this, void 0, void 0, function () {
        var url, revokeURL;
        return __generator(this, function (_a) {
            url = '';
            // 1. string | Blob | HTMLImageElement 处理逻辑
            if (source instanceof HTMLImageElement) {
                if (source.complete) {
                    return [2 /*return*/, source];
                }
                url = source.src;
            }
            else if (source instanceof Blob) {
                url = URL.createObjectURL(source);
                revokeURL = true;
            }
            else if (typeof source === 'string') {
                url = source;
            }
            // 2. 非法类型
            if (!url) {
                throw new Error("Invalid url type: ".concat(source));
            }
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var img = new Image();
                    if (!/^data:/.test(url)) {
                        img.crossOrigin = '*';
                    }
                    img.onload = function () {
                        img.onload = null;
                        if (revokeURL) {
                            URL.revokeObjectURL(url);
                        }
                        return resolve(img);
                    };
                    img.onerror = function (e) {
                        img.onerror = null;
                        if (revokeURL) {
                            URL.revokeObjectURL(url);
                        }
                        return reject("Load image fail: ".concat(e));
                    };
                    img.src = url;
                })];
        });
    });
}
/**
 * 异步加载一个二进制文件
 * @param url - 二进制文件的 URL
 */
function loadBinary(url) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    new Downloader().downloadBinary(url, resolve, function (status, responseText) {
                        reject("Couldn't load bins ".concat(url, ": status ").concat(status, ", ").concat(responseText));
                    });
                })];
        });
    });
}
/**
 * 异步加载一个 Blob 文件
 * @param url - Blob 文件的 URL
 */
function loadBlob(url) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    new Downloader().downloadBlob(url, resolve, function (status, responseText) {
                        reject("Couldn't load blob ".concat(url, ": status ").concat(status, ", ").concat(responseText));
                    });
                })];
        });
    });
}
/**
 * 异步加载一个视频文件
 * @param url - 视频文件的 URL 或 MediaProvider 对象
 * @param options - 加载参数
 */
function loadVideo(url, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var video;
        return __generator(this, function (_a) {
            video = document.createElement('video');
            if (typeof url === 'string') {
                video.src = url;
            }
            else {
                video.srcObject = url;
            }
            video.crossOrigin = 'anonymous';
            video.muted = true;
            if (options.loop) {
                video.addEventListener('ended', function () { return video.play(); });
            }
            if (isAndroid()) {
                video.setAttribute('renderer', 'standard');
            }
            video.setAttribute('playsinline', 'playsinline');
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var pending = video.play();
                    if (pending) {
                        void pending.then(function () { return resolve(video); });
                    }
                    else {
                        video.addEventListener('loadeddata', function listener() {
                            resolve(video);
                            video.removeEventListener('loadeddata', listener);
                        }, true);
                    }
                    video.addEventListener('error', function (e) {
                        reject(e);
                    });
                })];
        });
    });
}

function deserializeMipmapTexture(texOpts, bins, files) {
    if (files === void 0) { files = []; }
    return __awaiter(this, void 0, void 0, function () {
        var _a, mipmaps, target, jobs, loadedMipmaps, bin, _b, mipmaps, target, jobs, loadedMipmaps, bin;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!(texOpts.target === 34067)) return [3 /*break*/, 2];
                    _a = texOpts, mipmaps = _a.mipmaps, target = _a.target;
                    jobs = mipmaps.map(function (mipmap) { return Promise.all(mipmap.map(function (pointer) { return loadMipmapImage(pointer, bins); })); });
                    return [4 /*yield*/, Promise.all(jobs)];
                case 1:
                    loadedMipmaps = _c.sent();
                    bin = files[mipmaps[0][0][1][0]].url;
                    return [2 /*return*/, __assign$1(__assign$1({ keepImageSource: false }, texOpts), {
                            mipmaps: loadedMipmaps,
                            sourceFrom: {
                                target: target,
                                bin: bin,
                                type: exports.TextureSourceType.mipmaps,
                                mipmaps: mipmaps.map(function (mipmap) { return mipmap.map(function (pointer) { return [pointer[1][1], pointer[1][2]]; }); }),
                            },
                        })];
                case 2:
                    _b = texOpts, mipmaps = _b.mipmaps, target = _b.target;
                    jobs = mipmaps.map(function (pointer) { return loadMipmapImage(pointer, bins); });
                    return [4 /*yield*/, Promise.all(jobs)];
                case 3:
                    loadedMipmaps = _c.sent();
                    bin = files[mipmaps[0][1][0]].url;
                    return [2 /*return*/, __assign$1(__assign$1({ keepImageSource: false }, texOpts), {
                            mipmaps: loadedMipmaps,
                            sourceType: exports.TextureSourceType.mipmaps,
                            sourceFrom: {
                                target: target,
                                bin: bin,
                                type: exports.TextureSourceType.mipmaps,
                                mipmaps: mipmaps.map(function (pointer) { return [pointer[1][1], pointer[1][2]]; }),
                            },
                        })];
            }
        });
    });
}
function loadMipmapImage(pointer, bins) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, index, start, length, bin;
        return __generator(this, function (_b) {
            _a = __read$1(pointer[1], 3), index = _a[0], start = _a[1], length = _a[2];
            bin = bins[index];
            if (!bin) {
                throw new Error("invalid bin pointer: ".concat(JSON.stringify(pointer)));
            }
            return [2 /*return*/, loadImage(new Blob([new Uint8Array(bin, start, length)]))];
        });
    });
}

var seed$d = 1;
/**
 * Texture 抽象类
 */
var Texture = /** @class */ (function () {
    function Texture() {
        this.destroyed = false;
        this.id = 'Tex' + seed$d++;
    }
    Object.defineProperty(Texture.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取 Texture 的宽度。
     */
    Texture.prototype.getWidth = function () {
        return this.width || 0;
    };
    /**
     * 获取 Texture 的高度。
     */
    Texture.prototype.getHeight = function () {
        return this.height || 0;
    };
    Texture.prototype.uploadCurrentVideoFrame = function () {
        // OVERRIDE
    };
    /**
     * 释放 Texture GPU 资源。
     * 注意：该方法只释放资源，并不销毁 GPU textureBuffer 对象。
     * @override
     */
    Texture.prototype.offloadData = function () {
        // OVERRIDE
    };
    /**
     * 重新加载 Texture  GPU 资源。
     * @override
     */
    Texture.prototype.reloadData = function () {
        // OVERRIDE
    };
    /**
     * 初始化 GPU 资源
     * @override
     * @param engine - 引擎对象
     */
    Texture.prototype.initialize = function (engine) {
        // OVERRIDE
    };
    Texture.prototype.assembleOptions = function (options) {
        var _a = options.target, target = _a === void 0 ? glContext.TEXTURE_2D : _a, _b = options.format, internalFormat = _b === void 0 ? glContext.RGBA : _b;
        if (!options.sourceType) {
            if ('image' in options) {
                options.sourceType = exports.TextureSourceType.image;
            }
            else if ('data' in options) {
                options.sourceType = exports.TextureSourceType.data;
            }
            else if ('video' in options) {
                options.sourceType = exports.TextureSourceType.video;
            }
            else {
                options.sourceType = 0; // TextureSourceType.none
            }
        }
        return __assign$1({ minFilter: glContext.NEAREST, magFilter: glContext.NEAREST, wrapS: glContext.CLAMP_TO_EDGE, wrapT: glContext.CLAMP_TO_EDGE, target: target, format: glContext.RGBA, internalFormat: internalFormat, type: glContext.UNSIGNED_BYTE }, options);
    };
    return Texture;
}());
function generateHalfFloatTexture(data, width, height) {
    var channel = data.length / width / height;
    var format;
    var internalFormat;
    if (channel === 4 || channel === 0) {
        internalFormat = format = glContext.RGBA;
    }
    else if (channel === 3) {
        internalFormat = format = glContext.RGB;
    }
    else if (channel === 2) {
        internalFormat = format = glContext.LUMINANCE_ALPHA;
    }
    else {
        internalFormat = format = glContext.LUMINANCE;
    }
    return Texture.createWithData({
        data: data,
        width: width,
        height: height,
    }, {
        type: glContext.HALF_FLOAT,
        format: format,
        internalFormat: internalFormat,
        wrapS: glContext.CLAMP_TO_EDGE,
        wrapT: glContext.CLAMP_TO_EDGE,
    });
}

var HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)
var COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()
//const COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()
var TEX_2D = 2; // uses a gl.texImage2D()
//const TEX_3D = 3; // uses a gl.texImage3D()
var KTXTexture = /** @class */ (function () {
    function KTXTexture(arrayBuffer, facesExpected, baseOffset) {
        if (baseOffset === void 0) { baseOffset = 0; }
        this.arrayBuffer = arrayBuffer;
        this.baseOffset = baseOffset;
        // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:
        // '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\r', '\n', '\x1A', '\n'
        // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A
        var identifier = new Uint8Array(this.arrayBuffer, this.baseOffset, 12);
        if (identifier[0] !== 0xab ||
            identifier[1] !== 0x4b ||
            identifier[2] !== 0x54 ||
            identifier[3] !== 0x58 ||
            identifier[4] !== 0x20 ||
            identifier[5] !== 0x31 ||
            identifier[6] !== 0x31 ||
            identifier[7] !== 0xbb ||
            identifier[8] !== 0x0d ||
            identifier[9] !== 0x0a ||
            identifier[10] !== 0x1a ||
            identifier[11] !== 0x0a) {
            throw Error('texture missing KTX identifier');
        }
        // load the reset of the header in native 32 bit uint
        var dataSize = Uint32Array.BYTES_PER_ELEMENT;
        var headerDataView = new DataView(this.arrayBuffer, this.baseOffset + 12, 13 * dataSize);
        var endianness = headerDataView.getUint32(0, true);
        var littleEndian = endianness === 0x04030201;
        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures
        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures
        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures
        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays
        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6
        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures
        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data
        // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
        this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
            console.warn('only 2D textures currently supported');
            return;
        }
        if (this.numberOfArrayElements !== 0) {
            console.warn('texture arrays not currently supported');
            return;
        }
        if (this.numberOfFaces !== facesExpected) {
            console.warn('number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces);
            return;
        }
        // we now have a completely validated file, so could use existence of loadType as success
        // would need to make this more elaborate & adjust checks above to support more than one load type
        if (this.glType === 0) {
            this.loadType = COMPRESSED_2D;
        }
        else {
            this.loadType = TEX_2D;
        }
    }
    KTXTexture.prototype.mipmaps = function (loadMipmaps) {
        var mipmaps = [];
        // initialize width & height for level 1
        var dataOffset = HEADER_LEN + this.bytesOfKeyValueData;
        var width = this.pixelWidth;
        var height = this.pixelHeight;
        var mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;
        for (var level = 0; level < mipmapCount; level++) {
            var imageSize = new Int32Array(this.arrayBuffer, this.baseOffset + dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
            for (var face = 0; face < this.numberOfFaces; face++) {
                var data = new Uint8Array(this.arrayBuffer, this.baseOffset + dataOffset + 4, imageSize);
                mipmaps.push({
                    data: data,
                    width: width,
                    height: height,
                });
                dataOffset += imageSize + 4; // size of the image + 4 for the imageSize field
                dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image
            }
            width = Math.max(1.0, width * 0.5);
            height = Math.max(1.0, height * 0.5);
        }
        return mipmaps;
    };
    return KTXTexture;
}());
function getKTXTextureOptions(data) {
    var tex = new KTXTexture(data, 1);
    var numberOfMipmapLevels = tex.numberOfMipmapLevels, pixelWidth = tex.pixelWidth, pixelHeight = tex.pixelHeight, glType = tex.glType, numberOfFaces = tex.numberOfFaces, glInternalFormat = tex.glInternalFormat, glFormat = tex.glFormat;
    var useMipmaps = numberOfMipmapLevels >= Math.floor(Math.log2(Math.max(pixelWidth, pixelHeight)) + 1);
    return {
        sourceType: exports.TextureSourceType.compressed,
        type: glType,
        target: numberOfFaces === 6 ? glContext.TEXTURE_CUBE_MAP : glContext.TEXTURE_2D,
        internalFormat: glInternalFormat,
        format: glFormat,
        mipmaps: tex.mipmaps(useMipmaps),
    };
}

var TextureFactory = /** @class */ (function () {
    function TextureFactory() {
        this.reloadPending = {};
    }
    TextureFactory.prototype.reload = function (texture) {
        return __awaiter(this, void 0, void 0, function () {
            var id, sourceOpts;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        id = texture.id;
                        if (this.reloadPending[id]) {
                            return [2 /*return*/];
                        }
                        if (!texture.sourceFrom) return [3 /*break*/, 2];
                        this.reloadPending[id] = true;
                        return [4 /*yield*/, this.loadSource(texture.sourceFrom)];
                    case 1:
                        sourceOpts = _a.sent();
                        texture.updateSource(sourceOpts);
                        this.reloadPending[id] = false;
                        return [3 /*break*/, 3];
                    case 2: throw new Error('No source from');
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    TextureFactory.prototype.canOffloadTexture = function (sourceFrom) {
        if (sourceFrom) {
            var type = sourceFrom.type;
            if (type === exports.TextureSourceType.compressed ||
                type === exports.TextureSourceType.image) {
                var _a = sourceFrom, target = _a.target, map = _a.map;
                var url = sourceFrom.url;
                if (target === glContext.TEXTURE_CUBE_MAP) {
                    return typeof map === 'object' && !!map;
                }
                return isString(url) && url.length > 0;
            }
            if (type === exports.TextureSourceType.mipmaps) {
                var _b = sourceFrom, bin = _b.bin, mipmaps = _b.mipmaps;
                var _c = sourceFrom, target = _c.target, maps = _c.maps;
                var urls = sourceFrom.urls;
                if (bin) {
                    return mipmaps.length > 0;
                }
                if (target === glContext.TEXTURE_CUBE_MAP) {
                    return maps.every(function (map) { return typeof map === 'object' && map; });
                }
                return urls.every(function (url) { return isString(url) && url.length > 0; });
            }
        }
        return false;
    };
    TextureFactory.prototype.loadSource = function (sourceFrom, config) {
        return __awaiter(this, void 0, void 0, function () {
            var type, target, map, url, _a, bin, mipmaps, urls, maps, cube, image, video, buffer, data_1, newTarget, newMipmaps, loadedMipmaps, loadedMipmaps, loadedMipmaps;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        type = sourceFrom.type, target = sourceFrom.target;
                        map = sourceFrom.map;
                        url = sourceFrom.url;
                        _a = sourceFrom, bin = _a.bin, mipmaps = _a.mipmaps;
                        urls = sourceFrom.urls;
                        maps = sourceFrom.maps;
                        if (!(target === glContext.TEXTURE_CUBE_MAP && type !== exports.TextureSourceType.mipmaps)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.loadCubeMap(map)];
                    case 1:
                        cube = _b.sent();
                        return [2 /*return*/, __assign$1(__assign$1({}, config), { cube: cube, target: glContext.TEXTURE_CUBE_MAP, sourceType: exports.TextureSourceType.image, sourceFrom: { type: exports.TextureSourceType.image, map: __assign$1({}, map), target: glContext.TEXTURE_CUBE_MAP } })];
                    case 2:
                        if (!(type === exports.TextureSourceType.image)) return [3 /*break*/, 4];
                        return [4 /*yield*/, loadImage(url)];
                    case 3:
                        image = _b.sent();
                        return [2 /*return*/, __assign$1(__assign$1({}, config), { image: image, sourceType: exports.TextureSourceType.image, sourceFrom: { type: type, url: url, target: glContext.TEXTURE_2D } })];
                    case 4:
                        if (!(type === exports.TextureSourceType.video)) return [3 /*break*/, 6];
                        return [4 /*yield*/, loadVideo(url)];
                    case 5:
                        video = _b.sent();
                        return [2 /*return*/, __assign$1(__assign$1({}, config), { video: video, sourceType: exports.TextureSourceType.video })];
                    case 6:
                        if (!(type === exports.TextureSourceType.compressed)) return [3 /*break*/, 8];
                        return [4 /*yield*/, loadBinary(url)];
                    case 7:
                        buffer = _b.sent();
                        return [2 /*return*/, __assign$1(__assign$1(__assign$1({}, getKTXTextureOptions(buffer)), config), { sourceFrom: { url: url, type: exports.TextureSourceType.compressed } })];
                    case 8:
                        if (!(type === exports.TextureSourceType.mipmaps)) return [3 /*break*/, 17];
                        if (!bin) return [3 /*break*/, 13];
                        return [4 /*yield*/, loadBinary(bin)];
                    case 9:
                        data_1 = _b.sent();
                        newTarget = target !== null && target !== void 0 ? target : glContext.TEXTURE_2D;
                        newMipmaps = newTarget === glContext.TEXTURE_2D ? mipmaps.slice() : mipmaps.map(function (s) { return s.slice(); });
                        loadedMipmaps = void 0;
                        if (!(target === glContext.TEXTURE_CUBE_MAP)) return [3 /*break*/, 11];
                        return [4 /*yield*/, Promise.all(mipmaps.map(function (mipmap) { return _this.loadMipmapImages(mipmap, data_1); }))];
                    case 10:
                        loadedMipmaps = _b.sent();
                        return [3 /*break*/, 12];
                    case 11:
                        loadedMipmaps = this.loadMipmapImages(mipmaps, data_1);
                        _b.label = 12;
                    case 12: return [2 /*return*/, __assign$1(__assign$1({}, config), { mipmaps: loadedMipmaps, target: newTarget, sourceType: exports.TextureSourceType.mipmaps, sourceFrom: { bin: bin, mipmaps: newMipmaps, target: newTarget, type: exports.TextureSourceType.mipmaps } })];
                    case 13:
                        if (!(target === glContext.TEXTURE_2D || !target)) return [3 /*break*/, 15];
                        return [4 /*yield*/, Promise.all(urls.map(function (url) { return loadImage(url); }))];
                    case 14:
                        loadedMipmaps = _b.sent();
                        return [2 /*return*/, __assign$1(__assign$1({}, config), { mipmaps: loadedMipmaps, target: glContext.TEXTURE_2D, sourceType: exports.TextureSourceType.mipmaps, sourceFrom: { type: type, urls: urls.slice(), target: glContext.TEXTURE_2D } })];
                    case 15:
                        if (!(target === glContext.TEXTURE_CUBE_MAP)) return [3 /*break*/, 17];
                        return [4 /*yield*/, Promise.all(maps.map(function (map) { return _this.loadCubeMap(map); }))];
                    case 16:
                        loadedMipmaps = _b.sent();
                        return [2 /*return*/, __assign$1(__assign$1({}, config), { mipmaps: loadedMipmaps, target: glContext.TEXTURE_CUBE_MAP, sourceType: exports.TextureSourceType.mipmaps, sourceFrom: { type: type, maps: maps.map(function (map) { return (__assign$1({}, map)); }), target: glContext.TEXTURE_CUBE_MAP } })];
                    case 17: throw new Error("Invalid resource type: ".concat(type));
                }
            });
        });
    };
    TextureFactory.prototype.loadMipmapImages = function (pointers, bin) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.all(pointers.map(function (pointer) {
                        var blob = new Blob([new Uint8Array(bin, pointer[0], pointer[1])]);
                        return loadImage(blob);
                    }))];
            });
        });
    };
    TextureFactory.prototype.loadCubeMap = function (cubemap) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.all(cubemap.map(function (key) { return loadImage(key); }))];
            });
        });
    };
    return TextureFactory;
}());
var g;
function getDefaultTextureFactory() {
    if (!g) {
        g = new TextureFactory();
    }
    return g;
}
function setDefaultTextureFactory(factory) {
    g = factory;
}

var def = {
    format: glContext.RGBA,
    type: glContext.UNSIGNED_BYTE,
    minFilter: glContext.LINEAR,
    magFilter: glContext.LINEAR,
    wrapS: glContext.CLAMP_TO_EDGE,
    wrapT: glContext.CLAMP_TO_EDGE,
};
var disposeSymbol = Symbol('dispose');
var PassTextureCache = /** @class */ (function () {
    // TODO 解决core的pipeline引用问题
    // 05.30 https://code.alipay.com/vvfx/mars-runtime/pull_requests/183?tab=diff 已经解决？
    function PassTextureCache() {
        this.textureCache = {};
        this.textureRef = {};
    }
    PassTextureCache.prototype.requestColorAttachmentTexture = function (request) {
        var _this = this;
        var width = request.width, height = request.height, name = request.name;
        var options = {
            sourceType: exports.TextureSourceType.framebuffer,
            data: {
                width: width,
                height: height,
            },
            name: name,
        };
        var keys = [name];
        Object.getOwnPropertyNames(def).forEach(function (name) {
            var _a;
            var value = (_a = request[name]) !== null && _a !== void 0 ? _a : def[name];
            options[name] = value;
            keys.push(name, value);
        });
        var cacheId = keys.join(':');
        var tex = this.textureCache[cacheId];
        if (tex) {
            this.textureRef[cacheId]++;
        }
        else {
            tex = Texture.create(options);
            this.textureCache[cacheId] = tex;
            this.textureRef[cacheId] = 1;
            // @ts-expect-error
            tex[disposeSymbol] = tex.dispose;
            tex.dispose = function () { return _this.removeTexture(cacheId); };
        }
        return tex;
    };
    PassTextureCache.prototype.removeTexture = function (id) {
        var refCount = this.textureRef[id];
        if (refCount <= 1) {
            if (refCount < 0) {
                console.error('ref count < 0');
            }
            var tex = this.textureCache[id];
            if (tex) {
                // @ts-expect-error
                tex[disposeSymbol]();
                // @ts-expect-error
                tex.dispose = tex[disposeSymbol];
            }
            delete this.textureCache[id];
            delete this.textureRef[id];
        }
        else {
            this.textureRef[id] = refCount - 1;
        }
    };
    PassTextureCache.prototype.dispose = function () {
        Object.values(this.textureCache).forEach(function (tex) {
            // @ts-expect-error
            tex[disposeSymbol]();
            // @ts-expect-error
            tex.dispose = tex[disposeSymbol];
        });
        this.textureCache = {};
        this.textureRef = {};
    };
    return PassTextureCache;
}());

var SemanticMap = /** @class */ (function () {
    function SemanticMap(semantics) {
        if (semantics === void 0) { semantics = {}; }
        this.semantics = __assign$1({}, semantics);
    }
    SemanticMap.prototype.toObject = function () {
        return __assign$1({}, this.semantics);
    };
    SemanticMap.prototype.setSemantic = function (name, value) {
        if (value === undefined) {
            delete this.semantics[name];
        }
        else {
            this.semantics[name] = value;
        }
    };
    SemanticMap.prototype.getSemanticValue = function (name, state) {
        var ret = this.semantics[name];
        if (isFunction(ret)) {
            return ret(state);
        }
        return ret;
    };
    SemanticMap.prototype.hasSemanticValue = function (name) {
        return name in this.semantics;
    };
    SemanticMap.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.semantics).forEach(function (name) {
            delete _this.semantics[name];
        });
    };
    return SemanticMap;
}());

var _a$9;
var BYTES_TYPE_MAP = (_a$9 = {},
    _a$9[glContext.FLOAT] = Float32Array.BYTES_PER_ELEMENT,
    _a$9[glContext.INT] = Int32Array.BYTES_PER_ELEMENT,
    _a$9[glContext.SHORT] = Int16Array.BYTES_PER_ELEMENT,
    _a$9[glContext.BYTE] = Int8Array.BYTES_PER_ELEMENT,
    _a$9);
/**
 * Geometry 抽象类
 */
var Geometry = /** @class */ (function () {
    function Geometry(name) {
        this.name = name;
    }
    /**
     * 初始化 GPU 资源
     * @override
     * @param engine - 引擎对象
     */
    Geometry.prototype.initialize = function (engine) {
        // OVERRIDE
    };
    return Geometry;
}());
function generateEmptyTypedArray(type) {
    if (type === glContext.INT) {
        return new Int32Array(0);
    }
    if (type === glContext.SHORT) {
        return new Int16Array(0);
    }
    return new Float32Array(0);
}

var isWebGL2Available = typeof WebGL2RenderingContext === 'function';
var gpuCapability;
var GPUCapability = /** @class */ (function () {
    function GPUCapability(gl) {
        this.setupCapability(gl);
    }
    /**
     * GPUCapability 静态实例初始化函数，在程序初始化时调用。
     * @param gl - 可选的 gl 对象参数，如果没有传递会自动创建一个 canvas 获取 gl。
     */
    GPUCapability.initialize = function (gl) {
        gpuCapability = new GPUCapability(gl);
    };
    /**
     * GPUCapability 静态实例获取函数。在调用前需要先初始化。
     */
    GPUCapability.getInstance = function () {
        if (!gpuCapability) {
            console.warn('GLGPUCapability 未初始化');
        }
        return gpuCapability;
    };
    GPUCapability.prototype.setupCapability = function (gl) {
        var _a;
        var level = isWebGL2Available && gl instanceof WebGL2RenderingContext ? 2 : 1;
        var level2 = level === 2;
        var textureAnisotropicExt = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        var depthTextureExtension = gl.getExtension('WEBGL_depth_texture');
        var halfFloatLinear = !!gl.getExtension('OES_texture_half_float_linear');
        var floatLinear = !!gl.getExtension('OES_texture_float_linear');
        this.level = level;
        this.type = level2 ? 'webgl2' : 'webgl';
        this.UNSIGNED_INT_24_8 = gl.UNSIGNED_INT_24_8;
        this.drawBufferExtension = gl.getExtension('WEBGL_draw_buffers');
        if (depthTextureExtension) {
            this.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
        }
        if (level2 && !halfFloatLinear) {
            halfFloatLinear = checkLinearTextureFilter(gl, gl.HALF_FLOAT);
        }
        if (level2 && !floatLinear) {
            floatLinear = checkLinearTextureFilter(gl, gl.FLOAT);
        }
        this.internalFormatDepth16 = level2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT;
        this.internalFormatDepth24_stencil8 = level2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL;
        var floatTexture = (level2 || gl.getExtension('OES_texture_float')) ? gl.FLOAT : 0;
        var halfFloatTexture = level2 ? WebGL2RenderingContext.HALF_FLOAT : (((_a = gl.getExtension('OES_texture_half_float')) === null || _a === void 0 ? void 0 : _a.HALF_FLOAT_OES) || 0);
        var detail = {
            floatTexture: floatTexture,
            halfFloatTexture: halfFloatTexture,
            maxSample: level2 ? gl.getParameter(gl.MAX_SAMPLES) : 1,
            maxVertexUniforms: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
            maxVertexTextures: gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            maxFragmentUniforms: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
            maxFragmentTextures: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
            floatColorAttachment: level2 ? !!gl.getExtension('EXT_color_buffer_float') : (floatTexture > 0 && !!gl.getExtension('WEBGL_color_buffer_float')),
            halfFloatColorAttachment: level2 ? !!gl.getExtension('EXT_color_buffer_float') : (halfFloatTexture > 0 && !!gl.getExtension('EXT_color_buffer_half_float')),
            maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
            maxShaderTexCount: gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
            compressedTexture: registerCompressedTexture(gl),
            halfFloatLinear: halfFloatLinear,
            floatLinear: floatLinear,
            maxTextureAnisotropy: textureAnisotropicExt ? gl.getParameter(textureAnisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
            shaderTextureLod: level2 || !!gl.getExtension('EXT_shader_texture_lod'),
            instanceDraw: level2 || !!gl.getExtension('ANGLE_instanced_arrays'),
            drawBuffers: level2 || !!this.drawBufferExtension,
            asyncShaderCompile: !!gl.getExtension('KHR_parallel_shader_compile'),
            intIndexElementBuffer: !!gl.getExtension('OES_element_index_uint'),
            standardDerivatives: level2 || !!gl.getExtension('OES_standard_derivatives'),
            readableDepthStencilTextures: level2 || !!depthTextureExtension,
            writableFragDepth: level2 || !!gl.getExtension('EXT_frag_depth'),
        };
        this['detail'] = detail;
        if (textureAnisotropicExt) {
            this.textureMaxAnisotropyExt = textureAnisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT;
        }
    };
    GPUCapability.prototype.framebufferTexture2D = function (gl, target, index, textarget, texture) {
        var ext = this.drawBufferExtension;
        if (this.level === 1 && !ext && index > 0) {
            throw new Error('draw multiple color buffers not available');
        }
        var attachment = ext ?
            ext["COLOR_ATTACHMENT".concat(index, "_WEBGL")] :
            gl["COLOR_ATTACHMENT".concat(index)];
        if (attachment) {
            gl.framebufferTexture2D(target, attachment, textarget, texture, 0);
        }
        else {
            console.error('invalid color attachment index: ' + index);
        }
    };
    GPUCapability.prototype.drawBuffers = function (gl, bufferStates) {
        var ext = this.drawBufferExtension;
        if (this.level === 1 && !ext) {
            if (bufferStates.length > 1) {
                throw Error('draw buffers not available');
            }
            else {
                return;
            }
        }
        var buffers = bufferStates.map(function (enabled, index) {
            if (enabled) {
                return ext ?
                    ext["COLOR_ATTACHMENT".concat(index, "_WEBGL")] :
                    gl["COLOR_ATTACHMENT".concat(index)];
            }
            return gl.NONE;
        });
        if (ext) {
            ext.drawBuffersWEBGL(buffers);
        }
        else {
            gl.drawBuffers(buffers);
        }
    };
    GPUCapability.prototype.setTextureAnisotropic = function (gl, target, level) {
        var maxTextureAnisotropy = this.detail.maxTextureAnisotropy;
        if (maxTextureAnisotropy) {
            gl.texParameterf(target, this.textureMaxAnisotropyExt, Math.min(maxTextureAnisotropy, level || 4));
        }
    };
    return GPUCapability;
}());
function checkLinearTextureFilter(gl, type) {
    var tex = gl.createTexture();
    var ret = false;
    gl.getError();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.R16F, 1, 1, 0, gl.RED, type, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    if (!gl.getError()) {
        ret = true;
    }
    gl.deleteTexture(tex);
    return ret;
}
var COMPRESSED_TEXTURE = {
    NONE: 0,
    PVRTC: 1,
    ASTC: 2,
};
function registerCompressedTexture(gl) {
    if (gl.getExtension('WEBGL_compressed_texture_astc')) {
        return COMPRESSED_TEXTURE.ASTC;
    }
    if (gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')) {
        return COMPRESSED_TEXTURE.PVRTC;
    }
    return COMPRESSED_TEXTURE.NONE;
}

var seed$c = 1;
/**
 * Mesh 抽象类
 */
var Mesh = /** @class */ (function () {
    function Mesh(name) {
        /**
         * Mesh 的 Geometry 对象数组
         */
        this.geometries = [];
        this.destroyed = false;
        this.id = 'Mesh' + seed$c++;
        this.name = name;
    }
    Object.defineProperty(Mesh.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化 GPU 资源
     * @override
     * @param engine - 引擎对象
     */
    Mesh.prototype.initialize = function (engine) {
        // OVERRIDE
    };
    return Mesh;
}());

var RenderPassPriorityPrepare = 0;
var RenderPassPriorityNormal = 1000;
var RenderPassPriorityPostprocess = 3000;
/**
 * RenderPass Attachment 存储类型
 */
exports.RenderPassAttachmentStorageType = void 0;
(function (RenderPassAttachmentStorageType) {
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["none"] = 0] = "none";
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["color"] = 1] = "color";
    //stencil 8 render buffer
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["stencil_8_opaque"] = 2] = "stencil_8_opaque";
    //stencil 16 render buffer
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["depth_16_opaque"] = 3] = "depth_16_opaque";
    //depth 16 & stencil 8 render buffer
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["depth_stencil_opaque"] = 4] = "depth_stencil_opaque";
    //depth 16 texture, need gpu.capability.readableDepthStencilTextures
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["depth_16_texture"] = 5] = "depth_16_texture";
    //depth 24 texture, need gpu.capability.readableDepthStencilTextures
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["depth_24_stencil_8_texture"] = 6] = "depth_24_stencil_8_texture";
})(exports.RenderPassAttachmentStorageType || (exports.RenderPassAttachmentStorageType = {}));
/**
 * Attachment 结束后清除行为
 */
exports.TextureStoreAction = void 0;
(function (TextureStoreAction) {
    /**
     * 不清除 Attachment
     */
    TextureStoreAction[TextureStoreAction["store"] = 0] = "store";
    /**
     * 清除 Attachment
     */
    TextureStoreAction[TextureStoreAction["clear"] = 2] = "clear";
})(exports.TextureStoreAction || (exports.TextureStoreAction = {}));
var RenderTargetHandle = /** @class */ (function () {
    function RenderTargetHandle(options) {
        this.destroyed = false;
        if (!options) {
            return;
        }
        var texture = options.texture, size = options.size;
        if (texture instanceof Texture) {
            this.texture = texture;
            this.externalTexture = true;
        }
        else if (texture) {
            var wrapT = texture.wrapT, wrapS = texture.wrapS, minFilter = texture.minFilter, magFilter = texture.magFilter, internalFormat = texture.internalFormat, _a = texture.format, format = _a === void 0 ? glContext.RGBA : _a, _b = texture.type, type = _b === void 0 ? glContext.UNSIGNED_BYTE : _b;
            this.externalTexture = false;
            this.textureOptions = {
                size: size,
                format: format,
                type: type,
                internalFormat: internalFormat || format,
                wrapT: wrapT,
                wrapS: wrapS,
                minFilter: minFilter,
                magFilter: magFilter,
                name: options.name,
            };
            this.texture = Texture.create(__assign$1(__assign$1({}, this.textureOptions), { sourceType: exports.TextureSourceType.framebuffer, data: { width: size[0], height: size[1] } }));
        }
        else ;
    }
    RenderTargetHandle.prototype.dispose = function () {
        if (this.destroyed) {
            return;
        }
        this.texture.dispose();
        this.destroyed = true;
    };
    Object.defineProperty(RenderTargetHandle.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTargetHandle.prototype, "storageType", {
        get: function () {
            return exports.RenderPassAttachmentStorageType.color;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTargetHandle.prototype, "size", {
        get: function () {
            var tex = this.texture;
            return tex ? [tex.getWidth(), tex.getHeight()] : [0, 0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTargetHandle.prototype, "width", {
        get: function () {
            return this.texture.getWidth() || 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTargetHandle.prototype, "height", {
        get: function () {
            return this.texture.getHeight() || 0;
        },
        enumerable: false,
        configurable: true
    });
    return RenderTargetHandle;
}());
/**
 * RenderPass Attachment 销毁类型
 */
exports.RenderPassDestroyAttachmentType = void 0;
(function (RenderPassDestroyAttachmentType) {
    /**
     * 强制销毁
     */
    RenderPassDestroyAttachmentType[RenderPassDestroyAttachmentType["force"] = 0] = "force";
    /**
     * 保留，不销毁
     */
    RenderPassDestroyAttachmentType[RenderPassDestroyAttachmentType["keep"] = 1] = "keep";
    /**
     * 如果是外部传入的 Attachment，就不销毁
     */
    RenderPassDestroyAttachmentType[RenderPassDestroyAttachmentType["keepExternal"] = 2] = "keepExternal";
    /**
     * 强制销毁
     */
    RenderPassDestroyAttachmentType[RenderPassDestroyAttachmentType["destroy"] = 0] = "destroy";
})(exports.RenderPassDestroyAttachmentType || (exports.RenderPassDestroyAttachmentType = {}));
var seed$b = 1;
/**
 * RenderPass 抽象类
 */
var RenderPass = /** @class */ (function () {
    function RenderPass(options) {
        /**
         * ColorAttachment 数组
         */
        this.attachments = [];
        this.destroyed = false;
        var _a = options.name, name = _a === void 0 ? 'RenderPass_' + seed$b++ : _a, camera = options.camera, clearAction = options.clearAction, semantics = options.semantics, depthStencilAttachment = options.depthStencilAttachment, storeAction = options.storeAction, _b = options.priority, priority = _b === void 0 ? 0 : _b, _c = options.meshOrder, meshOrder = _c === void 0 ? exports.OrderType.ascending : _c, _d = options.meshes, meshes = _d === void 0 ? [] : _d, _e = options.delegate, delegate = _e === void 0 ? {} : _e;
        this.name = name;
        this.priority = priority;
        this.meshOrder = meshOrder;
        this.meshes = meshes.slice().sortByOrder(this.meshOrder);
        this.camera = camera;
        this.depthStencilType = (depthStencilAttachment === null || depthStencilAttachment === void 0 ? void 0 : depthStencilAttachment.storageType) || exports.RenderPassAttachmentStorageType.none;
        this.clearAction = __assign$1({}, clearAction);
        this.storeAction = __assign$1({ colorAction: exports.TextureStoreAction.store, depthAction: exports.TextureStoreAction.store, stencilAction: exports.TextureStoreAction.store }, storeAction);
        this.semantics = new SemanticMap(semantics);
        this.options = options;
        this.delegate = delegate;
        this.setViewportOptions(options);
    }
    Object.defineProperty(RenderPass.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderPass.prototype, "viewport", {
        get: function () {
            return this.getViewport();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderPass.prototype, "stencilAttachment", {
        get: function () {
            return this.getStencilAttachment();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderPass.prototype, "depthAttachment", {
        get: function () {
            return this.getDepthAttachment();
        },
        enumerable: false,
        configurable: true
    });
    RenderPass.prototype.addMesh = function (mesh) {
        this.meshes.addByOrder(mesh, this.meshOrder);
    };
    RenderPass.prototype.removeMesh = function (mesh) {
        removeItem(this.meshes, mesh);
    };
    RenderPass.prototype.setMeshes = function (meshes) {
        var _a;
        this.meshes.length = 0;
        (_a = this.meshes).splice.apply(_a, __spreadArray([0, 0], __read$1(meshes), false));
        this.meshes.sortByOrder(this.meshOrder);
        return this.meshes;
    };
    /**
     * 获取当前 Attachment 数组，注意 RenderPass 可能没有创建完成
     */
    RenderPass.prototype.getInitAttachments = function () {
        if (this.attachments.length > 0) {
            return this.attachments;
        }
        else {
            return this.options.attachments;
        }
    };
    // TODO 所有pass在子类配置
    /**
     * 配置当前pass的RT，在每帧渲染前调用
     */
    RenderPass.prototype.configure = function (renderer) {
        if (this.frameBuffer) {
            renderer.setFrameBuffer(this.frameBuffer);
        }
        else {
            var _a = __read$1(this.getViewport(), 4), x = _a[0], y = _a[1], width = _a[2], height = _a[3];
            renderer.setViewport(x, y, width, height);
        }
    };
    /**
     * 执行当前pass，每帧调用一次
     */
    RenderPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        renderer.renderMeshes(this.meshes);
        renderer.clear(this.storeAction);
    };
    /**
     * 每帧所有的pass渲染完后调用，通常用于清空临时的RT资源
     */
    RenderPass.prototype.frameCleanup = function (renderer) {
    };
    /**
     * 重置 ColorAttachment 数组，会直接替换掉
     * @param colors - 纹理数组，作为新的 ColorAttachment
     */
    RenderPass.prototype.resetColorAttachments = function (colors) {
        if (!colors.length) {
            this.resetAttachments({ attachments: [] });
        }
        if (!this.attachments.length) {
            this.resetAttachments({ attachments: colors.map(function (t) { return ({ texture: t }); }) });
        }
        else {
            var attachments = colors.map(function (texture) {
                texture.updateSource({ sourceType: exports.TextureSourceType.framebuffer });
                return new RenderTargetHandle({ texture: texture });
            });
            this.attachments.forEach(function (att) { return !att.externalTexture && att.dispose(); });
            this.attachments = attachments;
            if (this.frameBuffer) {
                this.frameBuffer.bind();
                this.frameBuffer.resetColorTextures(colors.map(function (color) { return color; }));
            }
        }
    };
    /**
     * 重置所有 Attachment，会替换掉所有 Attachment
     * @param options - Attachment 和视口数据
     */
    RenderPass.prototype.resetAttachments = function (options) {
        this.options = options;
        this.setViewportOptions(options);
        if (this.renderer) {
            this._resetAttachments();
        }
    };
    RenderPass.prototype.setViewportOptions = function (options) {
        if (options.viewport) {
            this.isCustomViewport = true;
            this.viewportScale = 1;
            this.customViewport = options.viewport.slice(0, 4);
            if (this.frameBuffer) {
                var vp = this.customViewport;
                // TODO 为什么framebuffer和renderpass的isCustomViewport不一样？
                this.frameBuffer.isCustomViewport = false;
                this.frameBuffer.resize(vp[0], vp[1], vp[2], vp[3]);
            }
        }
        else {
            this.isCustomViewport = false;
            this.viewportScale = options.viewportScale || 1;
            if (this.frameBuffer) {
                this.frameBuffer.isCustomViewport = true;
                this.frameBuffer.viewportScale = this.viewportScale;
            }
        }
    };
    RenderPass.prototype._resetAttachments = function () {
        var _a, _b;
        var renderer = this.renderer;
        var options = this.options;
        if (this.attachments.length) {
            this.attachments.forEach(function (att) { return !att.externalTexture && att.dispose(); });
            this.attachments.length = 0;
            (_a = this.frameBuffer) === null || _a === void 0 ? void 0 : _a.dispose({ depthStencilAttachment: exports.RenderPassDestroyAttachmentType.keepExternal });
            // @ts-expect-error safe to assign
            this.frameBuffer = null;
        }
        var vs = this.viewportScale;
        // renderpass 的 viewport 相关参数都需要动态的修改
        var viewport = (this.isCustomViewport ? this.customViewport : [0, 0, renderer.getWidth() * vs, renderer.getHeight() * vs]);
        var size = [viewport[2], viewport[3]];
        var name = this.name;
        if ((_b = options.attachments) === null || _b === void 0 ? void 0 : _b.length) {
            var attachments = options.attachments.map(function (attr, index) {
                var _a;
                var attachment = new RenderTargetHandle(__assign$1({ size: size, name: ((_a = attr.texture) === null || _a === void 0 ? void 0 : _a.name) || "".concat(name, "##color_").concat(index) }, attr));
                return attachment;
            });
            this.attachments = attachments;
            var framebuffer = FrameBuffer.create({
                storeAction: this.storeAction,
                name: name,
                viewport: viewport,
                viewportScale: this.viewportScale,
                isCustomViewport: this.isCustomViewport,
                attachments: attachments.map(function (att) { return att.texture; }),
                depthStencilAttachment: options.depthStencilAttachment || { storageType: exports.RenderPassAttachmentStorageType.none },
            }, renderer);
            framebuffer.bind();
            framebuffer.unbind();
            this.frameBuffer = framebuffer;
        }
        else {
            this.attachments.length = 0;
        }
    };
    /**
     * 获取当前视口大小，格式：[x偏移，y偏移，宽度，高度]
     */
    RenderPass.prototype.getViewport = function () {
        var _a;
        var ret = ((_a = this.frameBuffer) === null || _a === void 0 ? void 0 : _a.viewport) || this.customViewport;
        if (ret) {
            return ret;
        }
        var renderer = this.renderer;
        var vs = this.viewportScale;
        return renderer ? [0, 0, renderer.getWidth() * vs, renderer.getHeight() * vs] : [0, 0, 0, 0];
    };
    /**
     * 获取深度 Attachment，可能没有
     */
    RenderPass.prototype.getDepthAttachment = function () {
        var frameBuffer = this.frameBuffer;
        if (frameBuffer) {
            return {
                storageType: frameBuffer.depthStencilStorageType,
                storage: frameBuffer.depthStorage,
                texture: frameBuffer.getDepthTexture() ? this.getDepthTexture(frameBuffer.getDepthTexture(), frameBuffer.externalStorage) : undefined,
            };
        }
    };
    /**
     * 获取蒙版 Attachment，可能没有
     */
    RenderPass.prototype.getStencilAttachment = function () {
        var frameBuffer = this.frameBuffer;
        if (frameBuffer) {
            return {
                storageType: frameBuffer.depthStencilStorageType,
                storage: frameBuffer.stencilStorage,
                texture: frameBuffer.getStencilTexture() ? this.getStencilTexture(frameBuffer.getStencilTexture(), frameBuffer.externalStorage) : undefined,
            };
        }
    };
    RenderPass.prototype.getDepthTexture = function (texture, external) {
        var _a;
        if (!this.depthTexture) {
            var outTex = (_a = this.options.depthStencilAttachment) === null || _a === void 0 ? void 0 : _a.texture;
            var tex = texture === outTex ? outTex : texture;
            // TODO 为什么要initialize？
            //tex.initialize(this.renderer.glRenderer.pipelineContext);
            if (!external) {
                this.depthTexture = tex;
            }
            return tex;
        }
        return this.depthTexture;
    };
    RenderPass.prototype.getStencilTexture = function (texture, external) {
        var _a;
        if (!this.stencilTexture) {
            var outTex = (_a = this.options.depthStencilAttachment) === null || _a === void 0 ? void 0 : _a.texture;
            var tex = texture === outTex ? outTex : texture;
            if (!external) {
                this.stencilTexture = tex;
            }
            return tex;
        }
        return this.stencilTexture;
    };
    // 生成并初始化帧缓冲
    RenderPass.prototype.initialize = function (renderer) {
        if (!this.renderer) {
            this.renderer = renderer;
            this._resetAttachments();
        }
        return this;
    };
    /**
     * 销毁 RenderPass
     * @param options - 有选择销毁内部对象
     */
    RenderPass.prototype.dispose = function (options) {
        var _a, _b;
        if (this.destroyed) {
            return;
        }
        var destroyMeshOption = (options === null || options === void 0 ? void 0 : options.meshes) || undefined;
        if (destroyMeshOption !== exports.DestroyOptions.keep) {
            this.meshes.forEach(function (mesh) {
                mesh.dispose(destroyMeshOption);
            });
        }
        this.meshes.length = 0;
        var colorOpt = (options === null || options === void 0 ? void 0 : options.colorAttachment) ? options.colorAttachment : exports.RenderPassDestroyAttachmentType.force;
        this.attachments.forEach(function (att) {
            var keep = (att.externalTexture && colorOpt === exports.RenderPassDestroyAttachmentType.keepExternal) || colorOpt === exports.RenderPassDestroyAttachmentType.keep;
            if (!keep) {
                att.dispose();
            }
        });
        this.attachments.length = 0;
        if ((options === null || options === void 0 ? void 0 : options.semantics) !== exports.DestroyOptions.keep) {
            this.semantics.dispose();
        }
        this.destroyed = true;
        var depthStencilOpt = (options === null || options === void 0 ? void 0 : options.depthStencilAttachment) ? options.depthStencilAttachment : exports.RenderPassDestroyAttachmentType.force;
        var fbo = this.frameBuffer;
        if (fbo) {
            fbo.dispose({ depthStencilAttachment: depthStencilOpt });
            var keep = (fbo.externalStorage && depthStencilOpt === exports.RenderPassDestroyAttachmentType.keepExternal) || depthStencilOpt === exports.RenderPassDestroyAttachmentType.keep;
            if (!keep) {
                (_a = this.stencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();
                (_b = this.depthTexture) === null || _b === void 0 ? void 0 : _b.dispose();
            }
        }
        // @ts-expect-error safe to assign
        this.options = this.renderer = null;
        this.initialize = throwDestroyedError$1;
    };
    return RenderPass;
}());

var RENDER_PASS_NAME_PREFIX = '_mars_default_';
var seed$a = 1;
/**
 * RenderFrame 抽象类
 */
var RenderFrame = /** @class */ (function () {
    function RenderFrame(options) {
        var _a;
        this.destroyed = false;
        this.renderPassInfoMap = new WeakMap();
        var camera = options.camera, keepColorBuffer = options.keepColorBuffer, _b = options.editorTransform, editorTransform = _b === void 0 ? [1, 1, 0, 0] : _b, _c = options.clearAction, clearAction = _c === void 0 ? {
            colorAction: exports.TextureLoadAction.whatever,
            stencilAction: exports.TextureLoadAction.clear,
            depthAction: exports.TextureLoadAction.whatever,
        } : _c;
        this.renderer = options.renderer;
        var renderPasses = [
            new RenderPass({
                name: RENDER_PASS_NAME_PREFIX,
                priority: RenderPassPriorityNormal,
                camera: camera,
                meshOrder: exports.OrderType.ascending,
            }),
        ];
        this.setRenderPasses(renderPasses);
        this.semantics = new SemanticMap(options.semantics);
        this.clearAction = clearAction;
        this.name = "RenderFrame".concat(seed$a++);
        var firstRP = renderPasses[0];
        var sourceOpts = {
            type: glContext.UNSIGNED_BYTE,
            format: glContext.RGBA,
            internalFormat: glContext.RGBA,
            wrapS: glContext.MIRRORED_REPEAT,
            wrapT: glContext.MIRRORED_REPEAT,
            minFilter: glContext.NEAREST,
            magFilter: glContext.NEAREST,
        };
        this.emptyTexture = Texture.create(__assign$1({ data: {
                width: 1,
                height: 1,
                data: new Uint8Array([255, 255, 255, 255]),
            }, sourceType: exports.TextureSourceType.data }, sourceOpts));
        this.transparentTexture = Texture.create(__assign$1({ data: {
                width: 1,
                height: 1,
                data: new Uint8Array([0, 0, 0, 0]),
            }, sourceType: exports.TextureSourceType.data }, sourceOpts));
        this.camera = camera;
        this.keepColorBuffer = keepColorBuffer;
        this.renderPassInfoMap.set(firstRP, { listStart: 0, listEnd: 0, renderPass: firstRP, intermedia: false });
        this.editorTransform = editorTransform;
        if (!options.clearAction) {
            this.resetClearActions();
        }
        this.passTextureCache = new PassTextureCache();
        // FIXME: addShader是为了性能考虑，如果影响不大，下面代码可以删除
        var _d = GPUCapability.getInstance(), detail = _d.detail, level = _d.level;
        var writeDepth = detail.readableDepthStencilTextures && detail.writableFragDepth;
        var shader = createCopyShader(level === 2, writeDepth);
        (_a = this.renderer.getShaderLibrary()) === null || _a === void 0 ? void 0 : _a.addShader(shader);
    }
    Object.defineProperty(RenderFrame.prototype, "editorTransform", {
        get: function () {
            return this._editorTransform;
        },
        set: function (v) {
            this._editorTransform = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderFrame.prototype, "renderPasses", {
        get: function () {
            return this._renderPasses.slice();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderFrame.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 根据 Mesh 优先级添加到 RenderPass
     * @param mesh - 要添加的 Mesh 对象
     */
    RenderFrame.prototype.addMeshToDefaultRenderPass = function (mesh) {
        var renderPasses = this.renderPasses;
        var infoMap = this.renderPassInfoMap;
        var priority = mesh.priority;
        for (var i = 1; i < renderPasses.length; i++) {
            var renderPass = renderPasses[i - 1];
            var info = infoMap.get(renderPasses[i]);
            if (info && info.listStart > priority && (priority > infoMap.get(renderPass).listEnd || i === 1)) {
                return this.addToRenderPass(renderPass, mesh);
            }
        }
        // TODO diff逻辑待优化，有时会添加进找不到的元素
        var last = renderPasses[renderPasses.length - 1];
        if (last.name === 'mars-final-copy') {
            last = renderPasses[renderPasses.length - 2];
        }
        else {
            last = renderPasses[renderPasses.length - 1];
        }
        return this.addToRenderPass(last, mesh);
    };
    /**
     * 把 Mesh 从 RenderPass 中移除，
     * 如果 renderPass 中没有 mesh，此 renderPass 会被删除
     * @param mesh - 要删除的 Mesh 对象
     */
    RenderFrame.prototype.removeMeshFromDefaultRenderPass = function (mesh) {
        var _this = this;
        var _a, _b, _c;
        var renderPasses = this.renderPasses;
        var infoMap = this.renderPassInfoMap;
        for (var i = renderPasses.length - 1; i >= 0; i--) {
            var renderPass = renderPasses[i];
            var info = infoMap.get(renderPass);
            if (!info) {
                continue;
            }
            if (info.listStart <= mesh.priority && info.listEnd >= mesh.priority) {
                var idx = renderPass.meshes.indexOf(mesh);
                if (idx === -1) {
                    return;
                }
                // TODO hack: 现在的除了rp1和finalcopy pass，所有renderpass的meshes是一个copy加上一个filter mesh，这里的判断当filter mesh被删除后当前pass需不需要删除，
                // 判断需要更鲁棒。
                var shouldRestoreRenderPass = idx === 1 && renderPass.meshes[0].name === MARS_COPY_MESH_NAME;
                renderPass.removeMesh(mesh);
                if (shouldRestoreRenderPass) {
                    var nextRenderPass = renderPasses[i + 1];
                    var meshes = renderPass.meshes;
                    if (!info.intermedia) {
                        (_a = info.preRenderPass) === null || _a === void 0 ? void 0 : _a.resetColorAttachments([]);
                        //this.renderer.extension.resetColorAttachments?.(info.preRenderPass, []);
                    }
                    for (var j = 1; j < meshes.length; j++) {
                        (_b = info.preRenderPass) === null || _b === void 0 ? void 0 : _b.addMesh(meshes[j]);
                    }
                    var cp = (_c = renderPass.attachments[0]) === null || _c === void 0 ? void 0 : _c.texture;
                    var keepColor = cp === this.resource.color_a || cp === this.resource.color_b;
                    renderPass.dispose({
                        meshes: exports.DestroyOptions.keep,
                        colorAttachment: keepColor ? exports.RenderPassDestroyAttachmentType.keep : exports.RenderPassDestroyAttachmentType.destroy,
                        depthStencilAttachment: exports.RenderPassDestroyAttachmentType.keep,
                    });
                    removeItem(renderPasses, renderPass);
                    this.removeRenderPass(renderPass);
                    infoMap.delete(renderPass);
                    if (nextRenderPass) {
                        this.updateRenderInfo(nextRenderPass);
                    }
                    if (info.preRenderPass) {
                        this.updateRenderInfo(info.preRenderPass);
                    }
                    if (info.prePasses) {
                        info.prePasses.forEach(function (rp) {
                            _this.removeRenderPass(rp.pass);
                            if ((rp === null || rp === void 0 ? void 0 : rp.destroyOptions) !== false) {
                                rp.pass.attachments.forEach(function (c) {
                                    if (c.texture !== _this.resource.color_b || c.texture !== _this.resource.color_a) {
                                        c.texture.dispose();
                                    }
                                });
                                var options = __assign$1(__assign$1({}, ((rp === null || rp === void 0 ? void 0 : rp.destroyOptions) ? rp.destroyOptions : {})), { depthStencilAttachment: exports.RenderPassDestroyAttachmentType.keep });
                                rp.pass.dispose(options);
                            }
                        });
                    }
                    this.resetRenderPassDefaultAttachment(renderPasses, Math.max(i - 1, 0));
                    if (renderPasses.length === 1) {
                        renderPasses[0].resetColorAttachments([]);
                        //this.renderer.extension.resetColorAttachments?.(renderPasses[0], []);
                        this.removeRenderPass(this.resource.finalCopyRP);
                    }
                }
                return this.resetClearActions();
            }
        }
    };
    /**
     * 将 Mesh 所有在 RenderPass 进行切分
     * @param mesh - 目标 Mesh 对象
     * @param options - 切分选项，包含 RenderPass 相关的 Attachment 等数据
     */
    RenderFrame.prototype.splitDefaultRenderPassByMesh = function (mesh, options) {
        var _a, _b, _c;
        var index = this.findMeshRenderPassIndex(mesh);
        var renderPass = this.renderPasses[index];
        this.createResource();
        var meshIndex = renderPass.meshes.indexOf(mesh);
        var ms0 = renderPass.meshes.slice(0, meshIndex);
        var ms1 = renderPass.meshes.slice(meshIndex);
        var infoMap = this.renderPassInfoMap;
        if (renderPass.attachments[0] && this.renderPasses[index + 1] !== this.resource.finalCopyRP) {
            throw Error('not implement');
        }
        else {
            if (!((_a = options.attachments) === null || _a === void 0 ? void 0 : _a.length)) {
                throw Error('should include at least one color attachment');
            }
            var defRPS = this.renderPasses;
            var defIndex = defRPS.indexOf(renderPass);
            var lastDefRP = defRPS[defIndex - 1];
            removeItem(defRPS, renderPass);
            var lastInfo = infoMap.get(renderPass);
            infoMap.delete(renderPass);
            var rp0 = new RenderPass({
                name: RENDER_PASS_NAME_PREFIX + defIndex,
                priority: renderPass.priority,
                attachments: this.getRPAttachments(options.attachments, lastDefRP),
                clearAction: renderPass.clearAction || { colorAction: exports.TextureLoadAction.clear },
                storeAction: renderPass.storeAction,
                depthStencilAttachment: this.resource.depthStencil,
                meshes: ms0,
                meshOrder: exports.OrderType.ascending,
            });
            ms1.unshift(this.createCopyMesh());
            var renderPasses = this.renderPasses;
            renderPasses[index] = rp0;
            var prePasses_1 = [];
            var restMeshes = ms1.slice();
            if (options.prePasses) {
                options.prePasses.forEach(function (pass, i) {
                    pass.priority = renderPass.priority + 1 + i;
                    pass.setMeshes(ms1);
                    prePasses_1.push(pass);
                });
                renderPasses.splice.apply(renderPasses, __spreadArray([index + 1, 0], __read$1(prePasses_1), false));
                restMeshes.splice(0, 2);
            }
            var copyRP = this.resource.finalCopyRP;
            if (!renderPasses.includes(copyRP)) {
                renderPasses.push(copyRP);
            }
            // let sourcePass = (prePasses.length && !options.useLastDefaultPassColor) ? prePasses[prePasses.length - 1] : rp0;
            var finalFilterPass = prePasses_1[prePasses_1.length - 1];
            finalFilterPass.initialize(this.renderer);
            // 不切RT，接着上一个pass的渲染结果渲染
            var rp1 = new RenderPass({
                name: RENDER_PASS_NAME_PREFIX + (defIndex + 1),
                priority: renderPass.priority + 1 + (((_b = options.prePasses) === null || _b === void 0 ? void 0 : _b.length) || 0),
                meshes: restMeshes,
                meshOrder: exports.OrderType.ascending,
                depthStencilAttachment: this.resource.depthStencil,
                storeAction: options.storeAction,
                clearAction: {
                    depthAction: exports.TextureLoadAction.whatever,
                    stencilAction: exports.TextureLoadAction.whatever,
                    colorAction: exports.TextureLoadAction.whatever,
                },
            });
            renderPasses.splice(index + 1 + (((_c = options.prePasses) === null || _c === void 0 ? void 0 : _c.length) || 0), 0, rp1);
            this.setRenderPasses(renderPasses);
            this.updateRenderInfo(finalFilterPass);
            this.updateRenderInfo(rp0);
            this.updateRenderInfo(rp1);
            // 目的是删除滤镜元素后，把之前滤镜用到的prePass给删除，逻辑有些复杂，考虑优化
            infoMap.get(rp0).prePasses = lastInfo.prePasses;
            prePasses_1.pop();
            infoMap.get(finalFilterPass).prePasses = prePasses_1.map(function (pass, i) {
                return { pass: pass, destroyOptions: false };
            });
            this.resetClearActions();
            return finalFilterPass;
        }
    };
    /**
     * 销毁 RenderFrame
     * @param options - 可以有选择销毁一些对象
     */
    RenderFrame.prototype.dispose = function (options) {
        var _a, _b;
        if ((options === null || options === void 0 ? void 0 : options.semantics) !== exports.DestroyOptions.keep) {
            this.semantics.dispose();
        }
        var pass = (options === null || options === void 0 ? void 0 : options.passes) ? options.passes : undefined;
        if (pass !== exports.DestroyOptions.keep) {
            this._renderPasses.forEach(function (renderPass) {
                renderPass.dispose(pass);
            });
        }
        this.passTextureCache.dispose();
        this._renderPasses.length = 0;
        this.emptyTexture.dispose();
        this.transparentTexture.dispose();
        if (this.resource) {
            this.resource.color_a.dispose();
            this.resource.color_b.dispose();
            (_b = (_a = this.resource.depthStencil) === null || _a === void 0 ? void 0 : _a.texture) === null || _b === void 0 ? void 0 : _b.dispose();
            this.resource.finalCopyRP.dispose();
            this.resource.resRP.dispose();
            // @ts-expect-error
            this.resource = null;
        }
        this.destroyed = true;
    };
    /**
     * 重置 RenderPass ColorAttachment，解决 FrameBuffer 即读又写的问题
     * @param renderPasses - RenderPass 对象数组
     * @param startIndex - 开始重置的索引
     */
    RenderFrame.prototype.resetRenderPassDefaultAttachment = function (renderPasses, startIndex) {
        var _a, _b;
        var pre;
        var _c = this.resource, color_a = _c.color_a, color_b = _c.color_b;
        for (var i = startIndex; i < renderPasses.length; i++) {
            var rp = renderPasses[i];
            var tex = (_a = rp.attachments[0]) === null || _a === void 0 ? void 0 : _a.texture;
            // @ts-expect-error
            if (tex && pre === tex) {
                var next = tex === color_a ? color_b : color_a;
                rp.resetColorAttachments([next]);
                //this.renderer.extension.resetColorAttachments?.(rp as GLRenderPass, [next as GLTexture]);
            }
            tex = (_b = rp.attachments[0]) === null || _b === void 0 ? void 0 : _b.texture;
            if (tex) {
                pre = tex;
            }
        }
    };
    /**
     * 查找 Mesh 所在的 RenderPass 索引，没找到是-1
     * @param mesh - 需要查找的 Mesh
     */
    RenderFrame.prototype.findMeshRenderPassIndex = function (mesh) {
        var index = -1;
        this.renderPasses.every(function (rp, idx) {
            if (rp.name.startsWith(RENDER_PASS_NAME_PREFIX) && rp.meshes.includes(mesh)) {
                index = idx;
                return false;
            }
            return true;
        });
        return index;
    };
    RenderFrame.prototype.addToRenderPass = function (renderPass, mesh) {
        var info = this.renderPassInfoMap.get(renderPass);
        var priority = mesh.priority;
        if (renderPass.meshes.length === 0) {
            info.listStart = info.listEnd = priority;
        }
        else {
            if (priority < info.listStart) {
                info.listStart = priority;
            }
            else if (priority > info.listEnd) {
                info.listEnd = priority;
            }
        }
        renderPass.addMesh(mesh);
    };
    RenderFrame.prototype.getRPAttachments = function (attachments, preRP) {
        var _a;
        if ((attachments === null || attachments === void 0 ? void 0 : attachments.length) === 1) {
            var _b = attachments[0], texture = _b.texture, persistent = _b.persistent;
            var format = texture.format;
            var previousAttachmens = (_a = preRP === null || preRP === void 0 ? void 0 : preRP.getInitAttachments()) !== null && _a !== void 0 ? _a : [];
            if (format === glContext.RGBA && !persistent) {
                var texA = this.resource.color_a;
                if (previousAttachmens.length === 0) {
                    return [{ texture: texA }];
                }
                var texture_1 = previousAttachmens[0].texture === texA ? this.resource.color_b : texA;
                return [{ texture: texture_1 }];
            }
        }
        return attachments;
    };
    RenderFrame.prototype.resetClearActions = function () {
        var action = this.renderPasses.length > 1 ? exports.TextureLoadAction.clear : exports.TextureLoadAction.whatever;
        this.clearAction.stencilAction = action;
        this.clearAction.depthAction = action;
        this.clearAction.colorAction = action;
        if (this.keepColorBuffer) {
            this.clearAction.colorAction = exports.TextureLoadAction.whatever;
        }
    };
    RenderFrame.prototype.updateRenderInfo = function (renderPass) {
        var _this = this;
        var map = this.renderPassInfoMap;
        var passes = this.renderPasses;
        var info;
        if (!map.has(renderPass)) {
            info = {
                intermedia: false,
                renderPass: renderPass,
                listStart: 0,
                listEnd: 0,
            };
            map.set(renderPass, info);
        }
        else {
            info = map.get(renderPass);
        }
        info.intermedia = renderPass.attachments.length > 0;
        var meshes = renderPass.meshes;
        if (meshes[0]) {
            info.listStart = (meshes[0].name === MARS_COPY_MESH_NAME ? meshes[1] : meshes[0]).priority;
            info.listEnd = meshes[meshes.length - 1].priority;
        }
        else {
            info.listStart = 0;
            info.listEnd = 0;
        }
        var index = passes.indexOf(renderPass);
        var depthStencilActon = index === 0 ? exports.TextureLoadAction.clear : exports.TextureLoadAction.whatever;
        if (index === 0) {
            renderPass.clearAction.colorAction = exports.TextureLoadAction.clear;
        }
        renderPass.clearAction.depthAction = depthStencilActon;
        renderPass.clearAction.stencilAction = depthStencilActon;
        if (index > -1) {
            renderPass.semantics.setSemantic('EDITOR_TRANSFORM', function () { return _this.editorTransform; });
        }
        else {
            renderPass.semantics.setSemantic('EDITOR_TRANSFORM', undefined);
        }
        info.preRenderPass = passes[index - 1];
        return info;
    };
    /**
     * 设置 RenderPass 数组，直接修改内部的 RenderPass 数组
     * @param passes - RenderPass 数组
     */
    RenderFrame.prototype.setRenderPasses = function (passes) {
        var _this = this;
        if (this.renderer !== undefined) {
            passes.forEach(function (pass) { return pass.initialize(_this.renderer); });
        }
        this._renderPasses = passes.slice();
    };
    /**
     * 添加 RenderPass
     * @param pass - 需要添加的 RenderPass
     */
    RenderFrame.prototype.addRenderPass = function (pass) {
        if (this.renderer !== undefined) {
            pass.initialize(this.renderer);
        }
        this._renderPasses.push(pass);
    };
    /**
     * 创建 RenderPass 切分时需要的 GPU 资源
     */
    RenderFrame.prototype.createResource = function () {
        var _a;
        if (!this.resource) {
            var _b = GPUCapability.getInstance(), detail = _b.detail, level = _b.level;
            var width = this.renderer.getWidth();
            var height = this.renderer.getHeight();
            var filter = level === 2 ? glContext.LINEAR : glContext.NEAREST;
            var texA = Texture.create({
                sourceType: exports.TextureSourceType.framebuffer,
                format: glContext.RGBA,
                name: 'frame_a',
                minFilter: filter,
                magFilter: filter,
            });
            var texB = Texture.create({
                sourceType: exports.TextureSourceType.framebuffer,
                format: glContext.RGBA,
                data: {
                    width: width,
                    height: height,
                },
                minFilter: filter,
                magFilter: filter,
                name: 'frame_b',
            });
            var depthStencilType = detail.readableDepthStencilTextures && detail.writableFragDepth ?
                exports.RenderPassAttachmentStorageType.depth_24_stencil_8_texture :
                exports.RenderPassAttachmentStorageType.depth_stencil_opaque;
            var resRP = new RenderPass({
                depthStencilAttachment: { storageType: depthStencilType },
                attachments: [{ texture: texA }],
            }).initialize(this.renderer);
            var finalCopyRP = new FinalCopyRP({
                name: 'mars-final-copy',
                priority: RenderPassPriorityNormal + 600,
                clearAction: {
                    depthAction: exports.TextureLoadAction.clear,
                    stencilAction: exports.TextureLoadAction.clear,
                    colorAction: exports.TextureLoadAction.whatever,
                },
                camera: this.camera,
                meshOrder: exports.OrderType.ascending,
                meshes: [this.createCopyMesh({ blend: true, depthTexture: (_a = resRP.getDepthAttachment()) === null || _a === void 0 ? void 0 : _a.texture })],
            });
            this.resource = {
                color_a: resRP.attachments[0].texture,
                color_b: texB,
                finalCopyRP: finalCopyRP,
                depthStencil: resRP.depthAttachment,
                resRP: resRP,
            };
        }
    };
    // TODO tex和size没有地方用到。
    /**
     * 创建拷贝 RenderPass 用到的 Mesh 对象
     * @param semantics - RenderPass 渲染时 FrameBuffer 的颜色和深度纹理、大小和是否混合
     */
    RenderFrame.prototype.createCopyMesh = function (semantics) {
        var name = MARS_COPY_MESH_NAME;
        var geometry = Geometry.create({
            name: name,
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([-1, 1, -1, -1, 1, 1, 1, -1]),
                },
            },
            drawCount: 4,
        });
        var shader = createCopyShader(GPUCapability.getInstance().type === 'webgl2', !!(semantics === null || semantics === void 0 ? void 0 : semantics.depthTexture));
        // FIXME: 如果不把shader添加进shaderLibrary，这里可以移到core中，有性能上的考虑
        this.renderer.getShaderLibrary().addShader(shader);
        var material = Material.create({
            uniformValues: {
                // @ts-expect-error
                uDepth: semantics === null || semantics === void 0 ? void 0 : semantics.depthTexture,
            },
            name: name,
            shader: shader,
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        if (semantics === null || semantics === void 0 ? void 0 : semantics.blend) {
            material.blending = true;
            material.blendFunction = [glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA, glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA];
        }
        return Mesh.create({
            name: name,
            geometry: geometry,
            material: material,
            priority: 0,
        });
    };
    /**
     * 移除 RenderPass
     * @param pass - 需要移除的 RenderPass
     */
    RenderFrame.prototype.removeRenderPass = function (pass) {
        removeItem(this._renderPasses, pass);
    };
    return RenderFrame;
}());
function getTextureSize(tex) {
    return tex ? [tex.getWidth(), tex.getHeight()] : [0, 0];
}
function findPreviousRenderPass(renderPasses, renderPass) {
    var index = renderPasses.indexOf(renderPass);
    return renderPasses[index - 1];
}
var FinalCopyRP = /** @class */ (function (_super) {
    __extends(FinalCopyRP, _super);
    function FinalCopyRP() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FinalCopyRP.prototype.configure = function (renderer) {
        this.prePassTexture = renderer.getFrameBuffer().getColorTextures()[0];
        renderer.setFrameBuffer(null);
    };
    FinalCopyRP.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[0].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[0].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        renderer.renderMeshes(this.meshes);
        if (this.storeAction) {
            renderer.clear(this.storeAction);
        }
    };
    return FinalCopyRP;
}(RenderPass));

var RenderBuffer = /** @class */ (function () {
    function RenderBuffer(props) {
        this.size = [0, 0];
        this.multiSample = 1;
        this.destroyed = false;
        var storageType = props.storageType, format = props.format, attachment = props.attachment;
        this.storageType = storageType;
        this.format = format;
        this.attachment = attachment;
    }
    Object.defineProperty(RenderBuffer.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    return RenderBuffer;
}());

/**
 *
 */
var FrameBuffer = /** @class */ (function () {
    function FrameBuffer() {
    }
    FrameBuffer.prototype.resize = function (x, y, width, height) {
        // OVERRIDE
    };
    FrameBuffer.prototype.resetColorTextures = function (textures) {
        // OVERRIDE
    };
    FrameBuffer.prototype.unbind = function () {
        // OVERRIDE
    };
    FrameBuffer.prototype.bind = function () {
        // OVERRIDE
    };
    Object.defineProperty(FrameBuffer.prototype, "stencilStorage", {
        get: function () {
            // OVERRIDE
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FrameBuffer.prototype, "depthStorage", {
        get: function () {
            // OVERRIDE
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    FrameBuffer.prototype.getDepthTexture = function () {
        // OVERRIDE
        return undefined;
    };
    FrameBuffer.prototype.getStencilTexture = function () {
        // OVERRIDE
        return undefined;
    };
    FrameBuffer.prototype.getColorTextures = function () {
        // OVERRIDE
        return [];
    };
    FrameBuffer.prototype.dispose = function (opt) {
        // OVERRIDE
    };
    return FrameBuffer;
}());

var Renderer = /** @class */ (function () {
    function Renderer() {
    }
    Renderer.prototype.setFrameBuffer = function (frameBuffer) {
        // OVERRIDE
    };
    Renderer.prototype.getFrameBuffer = function () {
        // OVERRIDE
        return null;
    };
    // TODO 替代 setFrameBuffer
    Renderer.prototype.setRenderTarget = function (color, depth) {
        // OVERRIDE
    };
    Renderer.prototype.setViewport = function (x, y, width, height) {
        // OVERRIDE
    };
    Renderer.prototype.resize = function (canvasWidth, canvasHeight) {
        // OVERRIDE
    };
    Renderer.prototype.clear = function (action) {
        // OVERRIDE
    };
    Renderer.prototype.getWidth = function () {
        // OVERRIDE
        return 0;
    };
    Renderer.prototype.getHeight = function () {
        // OVERRIDE
        return 0;
    };
    /**
     * 添加 webglcontextlost 事件回调
     * @override
     * @param lostHandler
     */
    Renderer.prototype.addLostHandler = function (lostHandler) {
        // OVERRIDE
    };
    /**
     * 添加 webglContextrestored 事件的回调
     * @override
     * @param restoreHandler
     */
    Renderer.prototype.addRestoreHandler = function (restoreHandler) {
        // OVERRIDE
    };
    /**
     * @override
     * @param e
     */
    Renderer.prototype.lost = function (e) {
        // OVERRIDE
    };
    /**
     * @override
     */
    Renderer.prototype.restore = function () {
        // OVERRIDE
    };
    /**
     *
     * @override
     * @returns
     */
    Renderer.prototype.getShaderLibrary = function () {
        // OVERRIDE
        return undefined;
    };
    Renderer.prototype.renderRenderFrame = function (renderFrame) {
        // OVERRIDE
    };
    Renderer.prototype.renderMeshes = function (meshes) {
        // OVERRIDE
    };
    Renderer.prototype.dispose = function (haltGL) {
        // OVERRIDE
    };
    return Renderer;
}());

var _a$8;
function valIfUndefined(val, def) {
    if (val === undefined || val === null) {
        return def;
    }
    return val;
}
function getPreMultiAlpha(blending) {
    switch (blending) {
        case BlendingMode$1.ALPHA:
            return 1;
        case BlendingMode$1.ADD:
            return 1;
        case BlendingMode$1.SUBTRACTION:
            return 1;
        case BlendingMode$1.STRONG_LIGHT:
            return 1;
        case BlendingMode$1.WEAK_LIGHT:
            return 1;
        case BlendingMode$1.SUPERPOSITION:
            return 2;
        case BlendingMode$1.BRIGHTNESS:
            return 3;
        case BlendingMode$1.MULTIPLY:
            return 0;
        default:
            // 处理undefined
            return 1;
    }
}
var downgradeKeywords = (_a$8 = {},
    _a$8[exports.ShaderType.vertex] = {
        in: 'attribute',
        out: 'varying',
    },
    _a$8[exports.ShaderType.fragment] = {
        in: 'varying',
    },
    _a$8);
/**
 * 生成 shader，检测到 WebGL1 上下文会降级
 * @param marcos - 宏定义数组
 * @param shader - 原始 shader 文本
 * @param shaderType - shader 类型
 * @return 去除版本号的 shader 文本
 */
function createShaderWithMarcos(marcos, shader, shaderType) {
    var level = GPUCapability.getInstance().level;
    var ret = [];
    var header = '';
    // Mars shader 标志宏，没有其他含义，方便不支持完全的自定义 shader 的三方引擎接入使用
    ret.push('#define MARS_RUNTIME');
    if (marcos) {
        marcos.forEach(function (_a) {
            var _b = __read$1(_a, 2), key = _b[0], value = _b[1];
            if (value === true) {
                ret.push("#define ".concat(key));
            }
            else if (Number.isFinite(value)) {
                ret.push("#define ".concat(key, " ").concat(value));
            }
        });
        header = ret.length ? (ret.join('\n') + '\n') : '';
    }
    var versionTag = /#version\s+\b\d{3}\b\s*(es)?/;
    var GL_TYPE = "WEBGL".concat(level);
    header = header + "\n#ifndef ".concat(GL_TYPE, "\n#define ").concat(GL_TYPE, "\n#endif");
    var fullShader = header + '\n' + shader;
    // 判断shader是否带有版本头
    var match = fullShader.match(versionTag);
    var version = match ? match[0] : '';
    if (version && version.includes('300')) {
        var reg = new RegExp("".concat(version), 'g');
        // 带版本头且level为1，降级
        if (level === 1) {
            fullShader = fullShader.replace(/\b(in|out)\b/g, function (str) { var _a; return (_a = downgradeKeywords[shaderType][str]) !== null && _a !== void 0 ? _a : str; });
        }
        fullShader = fullShader.replace(reg, '\n');
    }
    return fullShader;
}
function setBlendMode(material, blendMode) {
    switch (blendMode) {
        case undefined:
            material.blendFunction = [glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA, glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA];
            break;
        case BlendingMode$1.ALPHA:
            material.blendFunction = [glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA, glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA];
            break;
        case BlendingMode$1.ADD:
            material.blendFunction = [glContext.ONE, glContext.ONE, glContext.ONE, glContext.ONE];
            break;
        case BlendingMode$1.SUBTRACTION:
            material.blendFunction = [glContext.ONE, glContext.ONE, glContext.ZERO, glContext.ONE];
            material.blendEquation = [glContext.FUNC_REVERSE_SUBTRACT, glContext.FUNC_REVERSE_SUBTRACT];
            break;
        case BlendingMode$1.SUPERPOSITION:
            material.blendFunction = [glContext.ONE, glContext.ONE, glContext.ONE, glContext.ONE];
            break;
        case BlendingMode$1.MULTIPLY:
            material.blendFunction = [glContext.DST_COLOR, glContext.ONE_MINUS_SRC_ALPHA, glContext.DST_COLOR, glContext.ONE_MINUS_SRC_ALPHA];
            break;
        case BlendingMode$1.BRIGHTNESS:
            material.blendFunction = [glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA, glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA];
            break;
        case BlendingMode$1.STRONG_LIGHT:
            material.blendFunction = [glContext.DST_COLOR, glContext.DST_ALPHA, glContext.ZERO, glContext.ONE];
            break;
        case BlendingMode$1.WEAK_LIGHT:
            material.blendFunction = [glContext.DST_COLOR, glContext.ZERO, glContext.ZERO, glContext.ONE];
            break;
        default:
            console.warn("blendMode ".concat(blendMode, " not in specification, please set blend params separately"));
    }
}
function setSideMode(material, side) {
    if (side === SideMode$1.DOUBLE) {
        material.culling = false;
    }
    else {
        material.culling = true;
        material.frontFace = glContext.CW;
        material.cullFace = side === SideMode$1.BACK ? glContext.BACK : glContext.FRONT;
    }
}
function setMaskMode(material, maskMode) {
    switch (maskMode) {
        case undefined:
            material.stencilTest = false;
            break;
        case MaskMode$1.MASK:
            material.stencilTest = true;
            material.stencilFunc = [glContext.ALWAYS, glContext.ALWAYS];
            material.stencilOpZPass = [glContext.REPLACE, glContext.REPLACE];
            break;
        case MaskMode$1.OBSCURED:
            material.stencilTest = true;
            material.stencilFunc = [glContext.EQUAL, glContext.EQUAL];
            break;
        case MaskMode$1.REVERSE_OBSCURED:
            material.stencilTest = true;
            material.stencilFunc = [glContext.NOTEQUAL, glContext.NOTEQUAL];
            break;
        case MaskMode$1.NONE:
            material.stencilTest = false;
            break;
        default:
            console.warn("maskMode ".concat(maskMode, " not in specification, please set stencil params seperately"));
    }
}

/**
 * 引擎接入暂时不需要实现
 */
var MaterialDataBlock = /** @class */ (function () {
    function MaterialDataBlock(props) {
        this.destroyed = false;
        var _a = props.name, name = _a === void 0 ? 'defaultDataBlock' : _a;
        this.name = name;
    }
    MaterialDataBlock.prototype.setUniformValues = function (uniformValue) {
        var _this = this;
        Object.keys(uniformValue).forEach(function (key) {
            _this.setUniformValue(key, uniformValue[key]);
        });
    };
    MaterialDataBlock.prototype.invalidAllFlags = function () {
        // OVERRIDE
    };
    MaterialDataBlock.prototype.updateUniformSubData = function (name, start, count) {
        // OVERRIDE
    };
    return MaterialDataBlock;
}());
function isUniformStruct(value) {
    return typeof value === 'object' && value && value.length === undefined && value instanceof Texture;
}
function isUniformStructArray(value) {
    return value && value.length !== undefined && isUniformStruct(value[0]);
}

/**
 * 材质渲染类型
 */
exports.MaterialRenderType = void 0;
(function (MaterialRenderType) {
    MaterialRenderType[MaterialRenderType["normal"] = 0] = "normal";
    MaterialRenderType[MaterialRenderType["transformFeedback"] = 1] = "transformFeedback";
})(exports.MaterialRenderType || (exports.MaterialRenderType = {}));
/**
 * 用于设置材质默认名称的自增序号
 * @internal
 */
var seed$9 = 1;
/**
 * Material 抽象类
 */
var Material = /** @class */ (function () {
    /**
     *
     * @param props - 材质属性
     */
    function Material(props) {
        this.props = props;
        this.destroyed = false;
        this.initialized = false;
        var _a = props.name, name = _a === void 0 ? 'Material' + seed$9++ : _a, _b = props.renderType, renderType = _b === void 0 ? exports.MaterialRenderType.normal : _b, shader = props.shader, uniformSemantics = props.uniformSemantics;
        this.name = name;
        this.renderType = renderType;
        this.shaderSource = shader;
        this.uniformSemantics = __assign$1({}, uniformSemantics);
    }
    Object.defineProperty(Material.prototype, "blending", {
        /******** mars-core 中会调用 引擎必须实现 ***********************/
        /**
         * 设置 Material 的颜色融合开关
         * @param blending - 是否开启混合效果
         */
        set: function (blending) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendFunction", {
        /**
         * 分别指定 Material 的颜色混合函数乘数
         * @param func - 混合函数参数
         */
        set: function (func) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendEquation", {
        /**
         * 分别指定 Material 的颜色混合方式
         * @param equation - 混合方程参数
         */
        set: function (equation) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "depthTest", {
        /**
         * 设置 Material 的深度测试开关
         * @param value - 是否开启深度测试
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "depthMask", {
        /**
         * 设置 Material 的写入深度缓冲开关
         * @param value - 是否开启深度写入
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilTest", {
        /**
         * 设置 Material 的模板测试开关
         * @param value - 是否开启模板测试
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilRef", {
        /**
         * 分别指定 Material 的模板测试参考值
         * @param value  - 模板测试参考值参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilFunc", {
        /**
         * 分别指定 Material 的模板测试函数
         * @param value - 模板测试函数参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilOpZPass", {
        /**
         * 分别指定 Material 的模板测试和深度测试都通过时使用的函数
         * @param value - 模板测试深度测试通过时的操作参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "culling", {
        /**
         * 设置 Material 的正反面剔除开关
         * @param value - 是否开启剔除
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "frontFace", {
        /**
         * 设置 Material 的正反面计算方向
         * @param value
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "cullFace", {
        /**
         * 设置 Material 要剔除的面
         * @param value - 剔除面参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendColor", {
        /***************************************************/
        /******** mars-core 中暂无调用 引擎可以先不实现 ***********************/
        /**
         * 设置 Material 的源和目标混合因子
         * @param color
         */
        set: function (color) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "depthRange", {
        /**
         * 设置 Material 的深度映射范围
         * @param value
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "depthFunc", {
        /**
         * 设置 Material 的深度比较函数
         * @param value - 深度测试函数参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "polygonOffsetFill", {
        /**
         * 设置 Material 的多边形偏移（实现类似深度偏移的效果）
         * @param value - 多边形偏移参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "polygonOffset", {
        /**
         * 指定 Material 计算深度值的比例因子 factor 和单位 units
         * @param value
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "sampleAlphaToCoverage", {
        /**
         * 设置 Material 的通过 alpha 值决定临时覆盖值计算的开关
         * @param value - 是否开启 alpha 抖动
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "colorMask", {
        /**
         * 设置 Material 颜色缓冲区的写入开关
         * @param value
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilMask", {
        /**
         * 分别指定 Material 的模板测试掩码
         * @param value - 模板测试写入掩码参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilOpFail", {
        /**
         * 分别指定 Material 模板测试失败时要使用的函数
         * @param value - 模板测试失败时的操作参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilOpZFail", {
        /**
         * 分别指定 Material 模板测试通过但深度测试失败时要使用的函数
         * @param value - 模板测试深度测试失败时的操作参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化 GPU 资源
     * @override
     * @param engine - 引擎对象
     */
    Material.prototype.initialize = function (engine) {
        // OVERRIDE
    };
    return Material;
}());

var vertex = "\nprecision highp float;\n\nattribute vec2 aPoint;\nuniform vec4 uPos;\nuniform vec2 uSize;\nuniform vec4 uQuat;\nuniform vec4 uColor;\nuniform mat4 mars_ObjectToWorld;\nuniform mat4 mars_MatrixInvV;\nuniform mat4 mars_MatrixVP;\nvarying vec4 vColor;\n#ifdef ENV_EDITOR\n  uniform vec4 uEditorTransform;\n#endif\n\nvec3 rotateByQuat(vec3 a, vec4 quat){\n  vec3 qvec = quat.xyz;\n  vec3 uv = cross(qvec, a);\n  vec3 uuv = cross(qvec, uv) * 2.;\n  return a +(uv * 2. * quat.w + uuv);\n}\n\nvoid main() {\n  vec4 _pos = uPos;\n  vec3 point = rotateByQuat(vec3(aPoint.xy * uSize, 0.),uQuat);\n  vec4 pos = vec4(_pos.xyz, 1.0);\n  pos = mars_ObjectToWorld * pos;\n  pos.xyz += mars_MatrixInvV[0].xyz * point.x+ mars_MatrixInvV[1].xyz * point.y;\n  gl_Position = mars_MatrixVP * pos;\n  vColor = uColor;\n  #ifdef ENV_EDITOR\n    gl_Position = vec4(gl_Position.xy * uEditorTransform.xy + uEditorTransform.zw * gl_Position.w, gl_Position.zw);\n  #endif\n}\n";
var fragment = "\nprecision highp float;\n\n#define fragColor gl_FragColor\n\nvarying vec4 vColor;\n\nvoid main() {\n  gl_FragColor = vColor;\n}\n\n";
var seed$8 = 1;
var InteractMesh = /** @class */ (function () {
    function InteractMesh(props, rendererOptions, transform) {
        this.transform = transform;
        this.color = props.options.previewColor;
        var material = this.createMaterial(rendererOptions);
        var geometry = this.createGeometry();
        this.mesh = this.createMesh(geometry, material);
        this.updateMesh();
    }
    InteractMesh.prototype.updateMesh = function () {
        var material = this.mesh.material;
        var uSize = material.getVector2('uSize').slice();
        var uPos = material.getVector4('uPos').slice();
        var uQuat = material.getVector4('uQuat').slice();
        var scale = __spreadArray([], __read$1(this.transform.scale), false);
        this.transform.assignWorldTRS(uPos, uQuat, scale);
        uSize[0] = scale[0];
        uSize[1] = scale[1];
        material.setVector2('uSize', uSize);
        material.setVector4('uPos', uPos);
        material.setVector4('uQuat', uQuat);
    };
    InteractMesh.prototype.createMaterial = function (rendererOptions) {
        var marcos = [
            ['ENV_EDITOR', getConfig(RUNTIME_ENV) === PLAYER_OPTIONS_ENV_EDITOR],
        ];
        var color = createValueGetter(this.color).getValue(0);
        GPUCapability.getInstance().level;
        var materialProps = {
            shader: {
                vertex: createShaderWithMarcos(marcos, vertex, exports.ShaderType.vertex),
                fragment: createShaderWithMarcos(marcos, fragment, exports.ShaderType.fragment),
                glslVersion: exports.GLSLVersion.GLSL1,
                cacheId: "".concat(rendererOptions.cachePrefix, "_mars_interact"),
            },
            uniformSemantics: {
                mars_MatrixVP: 'VIEWPROJECTION',
                mars_MatrixInvV: 'VIEWINVERSE',
                mars_ObjectToWorld: 'MODEL',
                uEditorTransform: 'EDITOR_TRANSFORM',
            },
        };
        var material = Material.create(materialProps);
        material.depthTest = false;
        material.setVector4('uPos', [0, 0, 0, 0]);
        material.setVector2('uSize', [1, 1]);
        material.setVector4('uColor', [color[0] / 255, color[1] / 255, color[2] / 255, color[3]]);
        material.setVector4('uQuat', [0, 0, 0, 0]);
        return material;
    };
    InteractMesh.prototype.createGeometry = function () {
        var indexData = new Uint8Array([0, 1, 1, 2, 2, 3, 3, 0]);
        return Geometry.create({
            attributes: {
                aPoint: {
                    size: 2,
                    offset: 0,
                    stride: 2 * Float32Array.BYTES_PER_ELEMENT,
                    data: new Float32Array([
                        -0.5, 0.5, 0.5, 0.5, 0.5, -0.5, -0.5, -0.5,
                    ]),
                },
            },
            drawCount: indexData.length,
            indices: { data: indexData },
            mode: glContext.LINES,
            maxVertex: 4,
        });
    };
    InteractMesh.prototype.createMesh = function (geometry, material) {
        return Mesh.create({
            name: 'Interact_preview' + seed$8++,
            priority: 0,
            worldMatrix: mat4create(),
            geometry: geometry,
            material: material,
        });
    };
    return InteractMesh;
}());

var InteractVFXItem = /** @class */ (function (_super) {
    __extends(InteractVFXItem, _super);
    function InteractVFXItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(InteractVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.interact;
        },
        enumerable: false,
        configurable: true
    });
    InteractVFXItem.prototype.onConstructed = function (options) {
        this.ui = options.content;
    };
    InteractVFXItem.prototype.onLifetimeBegin = function (composition) {
        var _a;
        var options = this.ui.options;
        (_a = this.composition) === null || _a === void 0 ? void 0 : _a.addInteractiveItem(this, options.type);
        if (options.type === InteractType$1.DRAG) {
            if (getConfig(RUNTIME_ENV) !== PLAYER_OPTIONS_ENV_EDITOR || options.enableInEditor) {
                this.beginDragTarget(options, composition.event);
            }
        }
    };
    InteractVFXItem.prototype.onItemUpdate = function () {
        var _a;
        (_a = this.previewContent) === null || _a === void 0 ? void 0 : _a.updateMesh();
        if (!this.dragEvent || !this.bouncingArg) {
            return;
        }
        var downgrade = 0.95;
        this.bouncingArg.vx *= downgrade;
        this.bouncingArg.vy *= downgrade;
        this.bouncingArg.dy += this.bouncingArg.vy;
        this.bouncingArg.dx += this.bouncingArg.vx;
        if (shouldIgnoreBouncing(this.bouncingArg)) {
            this.dragEvent = null;
            this.bouncingArg = null;
        }
        else {
            this.handleDragMove(this.dragEvent, this.bouncingArg);
        }
    };
    InteractVFXItem.prototype.onItemRemoved = function (composition) {
        var _a;
        composition.removeInteractiveItem(this, this.ui.options.type);
        this.clickable = false;
        (_a = this.previewContent) === null || _a === void 0 ? void 0 : _a.mesh.dispose();
        this.endDragTarget();
    };
    InteractVFXItem.prototype.getHitTestParams = function () {
        if (!this.clickable) {
            return;
        }
        var worldMatrix = this.transform.getWorldMatrix();
        var triangles = trianglesFromRect([0, 0, 0], 0.5, 0.5);
        var behavior = this.ui.options.behavior;
        triangles.forEach(function (triangle) {
            triangle.forEach(function (p) {
                vec3MulMat4(p, p, worldMatrix);
            });
        });
        return {
            type: exports.HitTestType.triangle,
            triangles: triangles,
            behavior: behavior,
        };
    };
    InteractVFXItem.prototype.doCreateContent = function (composition) {
        var _a = this.ui.options, type = _a.type, showPreview = _a.showPreview;
        if (type === InteractType$1.CLICK) {
            this.clickable = true;
            if (showPreview && getConfig(RUNTIME_ENV) === PLAYER_OPTIONS_ENV_EDITOR) {
                var rendererOptions = composition.getRendererOptions();
                this.previewContent = new InteractMesh(this.ui, rendererOptions, this.transform);
            }
        }
        return {};
    };
    InteractVFXItem.prototype.beginDragTarget = function (options, eventSystem) {
        var _this = this;
        if (options.target !== 'camera') {
            return;
        }
        var dragEvent;
        var handlerMap = {
            touchstart: function (event) {
                var _a;
                _this.dragEvent = null;
                _this.bouncingArg = null;
                var camera = (_a = _this.composition) === null || _a === void 0 ? void 0 : _a.camera;
                dragEvent = {
                    x: event.x,
                    y: event.y,
                    cameraParam: {
                        position: (camera === null || camera === void 0 ? void 0 : camera.position) || [0, 0, 8],
                        fov: (camera === null || camera === void 0 ? void 0 : camera.fov) || 60,
                    },
                };
            },
            touchmove: function (event) {
                _this.handleDragMove(dragEvent, event);
                _this.bouncingArg = event;
            },
            touchend: function (event) {
                var bouncingArg = _this.bouncingArg;
                if (!shouldIgnoreBouncing(bouncingArg, 3) && bouncingArg) {
                    var speed = 5;
                    bouncingArg.vx *= speed;
                    bouncingArg.vy *= speed;
                    _this.dragEvent = __assign$1({}, dragEvent);
                }
                dragEvent = null;
            },
        };
        Object.keys(handlerMap).forEach(function (name) {
            eventSystem.addEventListener(name, handlerMap[name]);
        });
        handlerMap.touchmove({ dx: 0, dy: 0, width: 1, height: 1 });
        this.endDragTarget = function () {
            Object.keys(handlerMap).forEach(function (name) {
                eventSystem.removeEventListener(name, handlerMap[name]);
            });
        };
    };
    InteractVFXItem.prototype.endDragTarget = function () {
        // OVERRIDE
    };
    InteractVFXItem.prototype.handleDragMove = function (evt, event) {
        var _a, _b;
        if (!(evt && evt.cameraParam) || !this.composition) {
            return;
        }
        var options = this.ui.options;
        var _c = evt.cameraParam, position = _c.position, fov = _c.fov;
        var dy = event.dy;
        var dx = event.dx * event.width / event.height;
        var depth = position[2];
        var sp = Math.tan(fov * Math.PI / 180 / 2) * Math.abs(depth);
        var height = dy * sp;
        var width = dx * sp;
        var nx = position[0] - width;
        var ny = position[1] - height;
        if (options.dxRange) {
            var _d = __read$1(options.dxRange, 2), min = _d[0], max = _d[1];
            nx = clamp$1(nx, min, max);
            if (nx !== min && nx !== max && min !== max) {
                (_a = event.origin) === null || _a === void 0 ? void 0 : _a.preventDefault();
            }
        }
        if (options.dyRange) {
            var _e = __read$1(options.dyRange, 2), min = _e[0], max = _e[1];
            ny = clamp$1(ny, min, max);
            if (ny !== min && ny !== max && min !== max) {
                (_b = event.origin) === null || _b === void 0 ? void 0 : _b.preventDefault();
            }
        }
        this.composition.camera.position = [nx, ny, depth];
    };
    return InteractVFXItem;
}(VFXItem));
function shouldIgnoreBouncing(arg, mul) {
    var threshold = 0.00001 * (mul || 1);
    return arg && Math.abs(arg.vx || 0) < threshold && Math.abs(arg.vy || 0) < threshold;
}

var InteractLoader = /** @class */ (function (_super) {
    __extends(InteractLoader, _super);
    function InteractLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.mesh = [];
        return _this;
    }
    InteractLoader.prototype.onCompositionItemLifeBegin = function (composition, item) {
        if (item instanceof InteractVFXItem && item.previewContent) {
            this.addMesh(item.previewContent.mesh);
        }
    };
    InteractLoader.prototype.onCompositionItemRemoved = function (composition, item) {
        if (item instanceof InteractVFXItem && item.previewContent) {
            this.removeMesh(item.previewContent.mesh, composition.renderFrame);
        }
    };
    InteractLoader.prototype.prepareRenderFrame = function (composition, renderFrame) {
        this.mesh && this.mesh.forEach(function (mesh) { return renderFrame.addMeshToDefaultRenderPass(mesh); });
        this.mesh = [];
        return false;
    };
    InteractLoader.prototype.addMesh = function (mesh) {
        this.mesh.push(mesh);
    };
    InteractLoader.prototype.removeMesh = function (mesh, frame) {
        frame.removeMeshFromDefaultRenderPass(mesh);
    };
    return InteractLoader;
}(AbstractPlugin));

var InteractItem = /** @class */ (function () {
    function InteractItem() {
    }
    return InteractItem;
}());

var blend = "vec4 blendColor(vec4 color,vec4 vc,float mode){vec4 ret=color*vc;\n#ifdef PRE_MULTIPLY_ALPHA\nfloat alpha=vc.a;\n#else\nfloat alpha=ret.a;\n#endif\nif(mode==1.){ret.rgb*=alpha;}else if(mode==2.){ret.rgb*=alpha;ret.a=dot(ret.rgb,vec3(0.33333333));}else if(mode==3.){alpha=color.r*alpha;ret=vec4(vc.rgb*alpha,alpha);}return ret;}";

var compatible_frag = "#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#define textureCube texture\n#define textureCubeLodEXT textureLod\nlayout(location=0)out vec4 fragColor;\n#else\n#define fragColor gl_FragColor\n#endif\n";

var compatible_vert = "#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#else\n#endif\n";

var itemFrameFrag = "#version 300 es\nprecision highp float;\n#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#define textureCube texture\n#define textureCubeLodEXT textureLod\nlayout(location=0)out vec4 fragColor;\n#else\n#define fragColor gl_FragColor\n#endif\nvec4 blendColor(vec4 color,vec4 vc,float mode){vec4 ret=color*vc;\n#ifdef PRE_MULTIPLY_ALPHA\nfloat alpha=vc.a;\n#else\nfloat alpha=ret.a;\n#endif\nif(mode==1.){ret.rgb*=alpha;}else if(mode==2.){ret.rgb*=alpha;ret.a=dot(ret.rgb,vec3(0.33333333));}else if(mode==3.){alpha=color.r*alpha;ret=vec4(vc.rgb*alpha,alpha);}return ret;}in vec4 vColor;in vec4 vTexCoord;in highp vec2 vParams;uniform vec3 uFrameColor;void main(){fragColor=vec4(uFrameColor.xyz,1.0);}";

var integrate = "float integrateCurveFrames(float t1,vec4 k0,vec4 k1){float k=k1.x-k0.x;float m0=k0.w*k;float m1=k1.z*k;float t0=k0.x;float v0=k0.y;float v1=k1.y;float dt=t0-t1;float dt2=dt*dt;float dt3=dt2*dt;vec4 a=vec4(dt3*dt,dt3,dt2,dt)/vec4(4.*k*k*k,3.*k*k,2.*k,1.);vec4 b=vec4(m0+m1+2.*v0-2.*v1,2.*m0+m1+3.*v0-3.*v1,m0,-v0);return dot(a,b);}float integrateByTimeCurveFrames(float t1,vec4 k0,vec4 k1){float k=k1.x-k0.x;float m0=k0.w*k;float m1=k1.z*k;float t0=k0.x;float v0=k0.y;float v1=k1.y;float dt=t0-t1;float dt2=dt*dt;float dt3=dt2*dt;float k2=k*k;float k3=k2*k;vec4 a=vec4(-30.*k3,10.*k2,5.*k,3.)*vec4(dt,dt2,dt3,dt3*dt);vec4 b=vec4(v0,m0,2.*m0+m1+3.*v0-3.*v1,m0+m1+2.*v0-2.*v1)*vec4(t0+t1,t0+2.*t1,t0+3.*t1,t0+4.*t1);return dot(a,b)/60./k3;}float integrateByTimeFromCurveFrames(float t1,float frameStart,float frameCount){if(t1==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i==count){return ret;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(t1>k0.x&&t1<=k1.x){return ret+integrateByTimeCurveFrames(t1,k0,k1);}ret+=integrateByTimeCurveFrames(k1.x,k0,k1);}return ret;}float integrateFromCurveFrames(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i==count){return ret;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(time>k0.x&&time<=k1.x){return ret+integrateCurveFrames(time,k0,k1);}ret+=integrateCurveFrames(k1.x,k0,k1);}return ret;}float integrateByTimeLineSeg(float t,vec2 p0,vec2 p1){float t0=p0.x;float t1=p1.x;float y0=p0.y;float y1=p1.y;float r=dot(vec4(2.*t*t*t,3.*t*t,-t0*t0*t0,3.*t0*t0),vec4(y0-y1,t0*y1-t1*y0,2.*y0+y1,t1*y0));return r/(t0-t1)/6.;}float integrateLineSeg(float time,vec2 p0,vec2 p1){float h=time-p0.x;float y0=p0.y;return(y0+y0+(p1.y-y0)*h/(p1.x-p0.x))*h/2.;}float integrateFromLineSeg(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i>count){return ret;}vec4 ks=lookup_curve(i+start);vec2 k0=ks.xy;vec2 k1=ks.zw;if(time>k0.x&&time<=k1.x){return ret+integrateLineSeg(time,k0,k1);}ret+=integrateLineSeg(k1.x,k0,k1);vec2 k2=lookup_curve(i+start+1).xy;if(time>k1.x&&time<=k2.x){return ret+integrateLineSeg(time,k1,k2);}ret+=integrateLineSeg(k2.x,k1,k2);}return ret;}float integrateByTimeFromLineSeg(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i>count){return ret;}vec4 ks=lookup_curve(i+start);vec2 k0=ks.xy;vec2 k1=ks.zw;if(time>k0.x&&time<=k1.x){return ret+integrateByTimeLineSeg(time,k0,k1);}ret+=integrateByTimeLineSeg(k1.x,k0,k1);vec2 k2=lookup_curve(i+start+1).xy;if(time>k1.x&&time<=k2.x){return ret+integrateByTimeLineSeg(time,k1,k2);}ret+=integrateByTimeLineSeg(k2.x,k1,k2);}return ret;}float getIntegrateFromTime0(float t1,vec4 value){float type=value.x;if(type==0.){return value.y*t1;}else if(type==1.){vec2 p0=vec2(0.,value.y);vec2 p1=vec2(value.w,value.z);return integrateLineSeg(t1,p0,p1);}if(type==3.){return integrateFromLineSeg(t1,value.y,value.z);}if(type==2.){float idx=floor(value.y);float ilen=floor(1./fract(value.y)+0.5);float d=integrateFromCurveFrames(t1,idx,ilen);return d*value.w+value.z*t1;}if(type==4.){return mix(value.y,value.z,aSeed)*t1;}return 0.;}float getIntegrateByTimeFromTime(float t0,float t1,vec4 value){float type=value.x;if(type==0.){return value.y*(t1*t1-t0*t0)/2.;}else if(type==1.){vec2 p0=vec2(0.,value.y);vec2 p1=vec2(value.w,value.z);return integrateByTimeLineSeg(t1,p0,p1)-integrateByTimeLineSeg(t0,p0,p1);}if(type==2.){float idx=floor(value.y);float ilen=floor(1./fract(value.y)+0.5);float d=integrateByTimeFromCurveFrames(t1,idx,ilen)-integrateByTimeFromCurveFrames(t0,idx,ilen);return d*value.w+value.z*pow(t1-t0,2.)*0.5;}if(type==3.){return integrateByTimeFromLineSeg(t1,value.y,value.z)-integrateByTimeFromLineSeg(t0,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed)*(t1*t1-t0*t0)/2.;}return 0.;}";

var itemVert = "#version 300 es\nprecision highp float;\n#define SHADER_VERTEX 1\n#define SPRITE_SHADER 1\nin vec4 aPoint;in vec2 aIndex;uniform mat4 uMainData[MAX_ITEM_COUNT];uniform vec4 uTexParams[MAX_ITEM_COUNT];uniform vec4 uTexOffset[MAX_ITEM_COUNT];uniform mat4 mars_ObjectToWorld;uniform mat4 mars_MatrixInvV;uniform mat4 mars_MatrixVP;out vec4 vColor;out vec4 vTexCoord;\n#ifdef ADJUST_LAYER\nout vec2 vFeatherCoord;\n#endif\nout highp vec3 vParams;const float d2r=3.141592653589793/180.;\n#ifdef ENV_EDITOR\nuniform vec4 uEditorTransform;\n#endif\nvec4 filterMain(float t,vec4 position);\n#pragma FILTER_VERT\nvec3 rotateByQuat(vec3 a,vec4 quat){vec3 qvec=quat.xyz;vec3 uv=cross(qvec,a);vec3 uuv=cross(qvec,uv)*2.;return a+(uv*2.*quat.w+uuv);}void main(){int index=int(aIndex.x);vec4 texParams=uTexParams[index];mat4 mainData=uMainData[index];float life=mainData[1].z;if(life<0.||life>1.){gl_Position=vec4(3.,3.,3.,1.);}else{vec4 _pos=mainData[0];vec2 size=mainData[1].xy;vec3 point=rotateByQuat(vec3(aPoint.xy*size,0.),mainData[2]);vec4 pos=vec4(_pos.xyz,1.0);float renderMode=texParams.z;if(renderMode==0.){pos=mars_ObjectToWorld*pos;pos.xyz+=mars_MatrixInvV[0].xyz*point.x+mars_MatrixInvV[1].xyz*point.y;}else if(renderMode==1.){pos.xyz+=point;pos=mars_ObjectToWorld*pos;}else if(renderMode==2.){pos=mars_ObjectToWorld*pos;pos.xy+=point.xy;}else if(renderMode==3.){pos=mars_ObjectToWorld*pos;pos.xyz+=mars_MatrixInvV[0].xyz*point.x+mars_MatrixInvV[2].xyz*point.y;}gl_Position=mars_MatrixVP*pos;\n#ifdef ADJUST_LAYER\nvec4 filter_Position=filterMain(life,pos);\n#endif\ngl_PointSize=6.0;\n#ifdef ENV_EDITOR\ngl_Position=vec4(gl_Position.xy*uEditorTransform.xy+uEditorTransform.zw*gl_Position.w,gl_Position.zw);\n#ifdef ADJUST_LAYER\nfilter_Position=vec4(filter_Position.xy*uEditorTransform.xy+uEditorTransform.zw*filter_Position.w,filter_Position.zw);\n#endif\n#endif\n#ifdef ADJUST_LAYER\nvTexCoord=vec4(filter_Position.xy/filter_Position.w+1.,gl_Position.xy/gl_Position.w+1.)/2.;vFeatherCoord=aPoint.zw;\n#else\nvec4 texOffset=uTexOffset[index];vTexCoord=vec4(aPoint.zw*texOffset.zw+texOffset.xy,texParams.xy);\n#endif\nvColor=mainData[3];vParams=vec3(aIndex.y,texParams.y,texParams.x);}}";

var item_define = "uniform mat4 uMainData[MAX_ITEM_COUNT];uniform vec4 uTexParams[MAX_ITEM_COUNT];uniform vec4 uTexOffset[MAX_ITEM_COUNT];";

var itemFrag = "#version 300 es\nprecision highp float;\n#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#define textureCube texture\n#define textureCubeLodEXT textureLod\nlayout(location=0)out vec4 fragColor;\n#else\n#define fragColor gl_FragColor\n#endif\nvec4 blendColor(vec4 color,vec4 vc,float mode){vec4 ret=color*vc;\n#ifdef PRE_MULTIPLY_ALPHA\nfloat alpha=vc.a;\n#else\nfloat alpha=ret.a;\n#endif\nif(mode==1.){ret.rgb*=alpha;}else if(mode==2.){ret.rgb*=alpha;ret.a=dot(ret.rgb,vec3(0.33333333));}else if(mode==3.){alpha=color.r*alpha;ret=vec4(vc.rgb*alpha,alpha);}return ret;}\n#define SPRITE_SHADER 1\nin vec4 vColor;in vec4 vTexCoord;in highp vec3 vParams;\n#ifdef ADJUST_LAYER\nuniform sampler2D uSamplerPre;vec4 filterMain(vec2 coord,sampler2D tex);in vec2 vFeatherCoord;uniform sampler2D uFeatherSampler;\n#endif\nuniform sampler2D uSampler0;uniform sampler2D uSampler1;uniform sampler2D uSampler2;uniform sampler2D uSampler3;uniform sampler2D uSampler4;uniform sampler2D uSampler5;uniform sampler2D uSampler6;uniform sampler2D uSampler7;\n#if MAX_FRAG_TEX == 16\nuniform sampler2D uSampler8;uniform sampler2D uSampler9;uniform sampler2D uSampler10;uniform sampler2D uSampler11;uniform sampler2D uSampler12;uniform sampler2D uSampler13;uniform sampler2D uSampler14;uniform sampler2D uSampler15;\n#endif\nvec4 texture2DbyIndex(float index,vec2 coord);\n#pragma FILTER_FRAG\n#ifndef WEBGL2\n#define round(a) floor(0.5+a)\n#endif\nvoid main(){vec4 color=vec4(0.);\n#ifdef ADJUST_LAYER\nvec2 featherCoord=abs(vFeatherCoord-vec2(0.5))/0.5;float cc=sqrt(max(featherCoord.x,featherCoord.y));float blend=vColor.a*texture2D(uFeatherSampler,vec2(cc,0.)).r;if(blend>=1.){color=filterMain(vTexCoord.xy,uSamplerPre);}else if(blend<=0.){color=texture2D(uSamplerPre,vTexCoord.zw);}else{color=mix(texture2D(uSamplerPre,vTexCoord.zw),filterMain(vTexCoord.xy,uSamplerPre),blend);}\n#else\nvec4 texColor=texture2DbyIndex(round(vParams.x),vTexCoord.xy);color=blendColor(texColor,vColor,round(vParams.y));if(vParams.z==0.&&color.a<0.04){discard;}\n#endif\nfragColor=color;}vec4 texture2DbyIndex(float index,vec2 coord){\n#ifndef ADJUST_LAYER\nif(index==0.){return texture2D(uSampler0,coord);}if(index==1.){return texture2D(uSampler1,coord);}if(index==2.){return texture2D(uSampler2,coord);}if(index==3.){return texture2D(uSampler3,coord);}if(index==4.){return texture2D(uSampler4,coord);}if(index==5.){return texture2D(uSampler5,coord);}if(index==6.){return texture2D(uSampler6,coord);}if(index==7.){return texture2D(uSampler7,coord);}\n#if MAX_FRAG_TEX == 16\nif(index==8.){return texture2D(uSampler8,coord);}if(index==9.){return texture2D(uSampler9,coord);}if(index==10.){return texture2D(uSampler10,coord);}if(index==11.){return texture2D(uSampler11,coord);}if(index==12.){return texture2D(uSampler12,coord);}if(index==13.){return texture2D(uSampler13,coord);}if(index==14.){return texture2D(uSampler14,coord);}if(index==15.){return texture2D(uSampler15,coord);}\n#endif\nreturn texture2D(uSampler0,coord);\n#else\nreturn vec4(0.);\n#endif\n}";

var particleFrag = "#version 300 es\nprecision mediump float;\n#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#define textureCube texture\n#define textureCubeLodEXT textureLod\nlayout(location=0)out vec4 fragColor;\n#else\n#define fragColor gl_FragColor\n#endif\nvec4 blendColor(vec4 color,vec4 vc,float mode){vec4 ret=color*vc;\n#ifdef PRE_MULTIPLY_ALPHA\nfloat alpha=vc.a;\n#else\nfloat alpha=ret.a;\n#endif\nif(mode==1.){ret.rgb*=alpha;}else if(mode==2.){ret.rgb*=alpha;ret.a=dot(ret.rgb,vec3(0.33333333));}else if(mode==3.){alpha=color.r*alpha;ret=vec4(vc.rgb*alpha,alpha);}return ret;}\n#define PATICLE_SHADER 1\nin float vLife;in vec2 vTexCoord;in vec4 vColor;uniform sampler2D uMaskTex;uniform vec4 uColorParams;uniform vec2 uTexOffset;\n#ifdef COLOR_OVER_LIFETIME\nuniform sampler2D uColorOverLifetime;\n#endif\n#ifdef USE_SPRITE\nin vec4 vTexCoordBlend;\n#ifdef USE_FILTER\nuniform vec4 uFSprite;\n#endif\n#endif\nin float vSeed;\n#ifdef PREVIEW_BORDER\nuniform vec4 uPreviewColor;\n#endif\n#ifdef USE_SPRITE\nvec4 getTextureColor(sampler2D tex,vec2 texCoord){if(vTexCoordBlend.w>0.){return mix(texture2D(tex,texCoord),texture2D(tex,vTexCoordBlend.xy+texCoord),vTexCoordBlend.z);}return texture2D(tex,texCoord);}\n#else\n#define getTextureColor texture2D\n#endif\n#ifndef WEBGL2\n#define round(a) floor(0.5+a)\n#endif\n#ifdef PREVIEW_BORDER\nvoid main(){fragColor=uPreviewColor;}\n#else\n#pragma FILTER_FRAG\nvoid main(){vec4 color=vec4(1.0);vec4 tempColor=vColor;vec2 texOffset=uTexOffset;if(vLife<0.){discard;}\n#ifdef USE_FILTER\n#ifdef USE_SPRITE\ntexOffset=uTexOffset/uFSprite.xy;\n#endif\ncolor=filterMain(vTexCoord,uMaskTex);\n#else\nif(uColorParams.x>0.0){color=getTextureColor(uMaskTex,vTexCoord);}\n#endif\n#ifdef COLOR_OVER_LIFETIME\n#ifndef ENABLE_VERTEX_TEXTURE\ntempColor*=texture2D(uColorOverLifetime,vec2(vLife,0.));\n#endif\n#endif\ncolor=blendColor(color,tempColor,round(uColorParams.y));if(color.a<=0.01&&uColorParams.w>0.){float _at=texture2D(uMaskTex,vTexCoord+texOffset).a+texture2D(uMaskTex,vTexCoord+texOffset*-1.).a;if(_at<=0.02){discard;}}fragColor=color;}\n#endif\n";

var particleVert = "#version 300 es\nprecision highp float;\n#define SHADER_VERTEX 1\n#define PATICLE_SHADER 1\n#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#else\n#endif\n#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#define CURVE_VALUE_COUNT VERT_CURVE_VALUE_COUNT\n#define FRAG_CURVE_VALUE_COUNT 0\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#define CURVE_VALUE_COUNT FRAG_CURVE_VALUE_COUNT\n#define VERT_CURVE_VALUE_COUNT 0\n#endif\n#if CURVE_VALUE_COUNT > 0\n#if LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;const float uCurveCount=1./float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#else\n#define lookup_curve(i) vec4(0.)\n#endif\n#ifdef WEBGL2\n#define ITR_END (count + 1)\n#else\n#define ITR_END MAX_C\n#endif\n#ifdef SHADER_VERTEX\nin float aSeed;out float vSeed;\n#define NONE_CONST_INDEX 1\n#else\n#if LOOKUP_TEXTURE_CURVE\n#define NONE_CONST_INDEX 1\n#endif\n#endif\n#ifdef NONE_CONST_INDEX\n#ifdef SHADER_VERTEX\n#define MAX_C VERT_MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C FRAG_MAX_KEY_FRAME_COUNT\n#endif\n#else\n#define MAX_C CURVE_VALUE_COUNT\n#endif\nfloat evaluateCurveFrames(float time,vec4 keyframe0,vec4 keyframe1){float dt=keyframe1.x-keyframe0.x;float m0=keyframe0.w*dt;float m1=keyframe1.z*dt;float t=(time-keyframe0.x)/dt;float t2=t*t;float t3=t2*t;return dot(vec4(dot(vec3(2.,-3.,1.),vec3(t3,t2,1.)),dot(vec3(1,-2.,1),vec3(t3,t2,t)),t3-t2,dot(vec2(-2,3),vec2(t3,t2))),vec4(keyframe0.y,m0,m1,keyframe1.y));}float valueFromCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);int end=start+count;for(int i=0;i<ITR_END;i++){\n#ifdef NONE_CONST_INDEX\nif(i==count){return lookup_curve(count).y;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);\n#else\nif(i<start){continue;}vec4 k0=lookup_curve(i);vec4 k1=lookup_curve(i+1);if(i==end){return k0.y;}\n#endif\nif(time>=k0.x&&time<=k1.x){return evaluateCurveFrames(time,k0,k1);}}return lookup_curve(0).y;}float evaluteLineSeg(float t,vec2 p0,vec2 p1){return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);}float valueFromLineSegs(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);int end=start+count;for(int i=0;i<ITR_END;i++){\n#ifdef NONE_CONST_INDEX\nif(i>count){return lookup_curve(i).w;}\n#else\nif(i<start){continue;}if(i>end){return lookup_curve(i-2).w;}\n#endif\n#ifdef NONE_CONST_INDEX\nvec4 seg=lookup_curve(i+start);\n#else\nvec4 seg=lookup_curve(i);\n#endif\nvec2 p0=seg.xy;vec2 p1=seg.zw;if(time>=p0.x&&time<=p1.x){return evaluteLineSeg(time,p0,p1);}\n#ifdef NONE_CONST_INDEX\nvec2 p2=lookup_curve(i+start+1).xy;\n#else\nvec2 p2=lookup_curve(i+1).xy;\n#endif\nif(time>p1.x&&time<=p2.x){return evaluteLineSeg(time,p1,p2);}}return lookup_curve(0).y;}float getValueFromTime(float time,vec4 value){float type=value.x;if(type==0.){return value.y;}else if(type==1.){return mix(value.y,value.z,time/value.w);}if(type==2.){return valueFromCurveFrames(time,floor(value.y),floor(1./fract(value.y)+0.5))*value.w+value.z;}if(type==3.){return valueFromLineSegs(time,value.y,value.z);}if(type==4.){\n#ifdef SHADER_VERTEX\nfloat seed=aSeed;\n#else\nfloat seed=vSeed;\n#endif\nreturn mix(value.y,value.z,seed);}return 0.;}float integrateCurveFrames(float t1,vec4 k0,vec4 k1){float k=k1.x-k0.x;float m0=k0.w*k;float m1=k1.z*k;float t0=k0.x;float v0=k0.y;float v1=k1.y;float dt=t0-t1;float dt2=dt*dt;float dt3=dt2*dt;vec4 a=vec4(dt3*dt,dt3,dt2,dt)/vec4(4.*k*k*k,3.*k*k,2.*k,1.);vec4 b=vec4(m0+m1+2.*v0-2.*v1,2.*m0+m1+3.*v0-3.*v1,m0,-v0);return dot(a,b);}float integrateByTimeCurveFrames(float t1,vec4 k0,vec4 k1){float k=k1.x-k0.x;float m0=k0.w*k;float m1=k1.z*k;float t0=k0.x;float v0=k0.y;float v1=k1.y;float dt=t0-t1;float dt2=dt*dt;float dt3=dt2*dt;float k2=k*k;float k3=k2*k;vec4 a=vec4(-30.*k3,10.*k2,5.*k,3.)*vec4(dt,dt2,dt3,dt3*dt);vec4 b=vec4(v0,m0,2.*m0+m1+3.*v0-3.*v1,m0+m1+2.*v0-2.*v1)*vec4(t0+t1,t0+2.*t1,t0+3.*t1,t0+4.*t1);return dot(a,b)/60./k3;}float integrateByTimeFromCurveFrames(float t1,float frameStart,float frameCount){if(t1==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i==count){return ret;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(t1>k0.x&&t1<=k1.x){return ret+integrateByTimeCurveFrames(t1,k0,k1);}ret+=integrateByTimeCurveFrames(k1.x,k0,k1);}return ret;}float integrateFromCurveFrames(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i==count){return ret;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(time>k0.x&&time<=k1.x){return ret+integrateCurveFrames(time,k0,k1);}ret+=integrateCurveFrames(k1.x,k0,k1);}return ret;}float integrateByTimeLineSeg(float t,vec2 p0,vec2 p1){float t0=p0.x;float t1=p1.x;float y0=p0.y;float y1=p1.y;float r=dot(vec4(2.*t*t*t,3.*t*t,-t0*t0*t0,3.*t0*t0),vec4(y0-y1,t0*y1-t1*y0,2.*y0+y1,t1*y0));return r/(t0-t1)/6.;}float integrateLineSeg(float time,vec2 p0,vec2 p1){float h=time-p0.x;float y0=p0.y;return(y0+y0+(p1.y-y0)*h/(p1.x-p0.x))*h/2.;}float integrateFromLineSeg(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i>count){return ret;}vec4 ks=lookup_curve(i+start);vec2 k0=ks.xy;vec2 k1=ks.zw;if(time>k0.x&&time<=k1.x){return ret+integrateLineSeg(time,k0,k1);}ret+=integrateLineSeg(k1.x,k0,k1);vec2 k2=lookup_curve(i+start+1).xy;if(time>k1.x&&time<=k2.x){return ret+integrateLineSeg(time,k1,k2);}ret+=integrateLineSeg(k2.x,k1,k2);}return ret;}float integrateByTimeFromLineSeg(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i>count){return ret;}vec4 ks=lookup_curve(i+start);vec2 k0=ks.xy;vec2 k1=ks.zw;if(time>k0.x&&time<=k1.x){return ret+integrateByTimeLineSeg(time,k0,k1);}ret+=integrateByTimeLineSeg(k1.x,k0,k1);vec2 k2=lookup_curve(i+start+1).xy;if(time>k1.x&&time<=k2.x){return ret+integrateByTimeLineSeg(time,k1,k2);}ret+=integrateByTimeLineSeg(k2.x,k1,k2);}return ret;}float getIntegrateFromTime0(float t1,vec4 value){float type=value.x;if(type==0.){return value.y*t1;}else if(type==1.){vec2 p0=vec2(0.,value.y);vec2 p1=vec2(value.w,value.z);return integrateLineSeg(t1,p0,p1);}if(type==3.){return integrateFromLineSeg(t1,value.y,value.z);}if(type==2.){float idx=floor(value.y);float ilen=floor(1./fract(value.y)+0.5);float d=integrateFromCurveFrames(t1,idx,ilen);return d*value.w+value.z*t1;}if(type==4.){return mix(value.y,value.z,aSeed)*t1;}return 0.;}float getIntegrateByTimeFromTime(float t0,float t1,vec4 value){float type=value.x;if(type==0.){return value.y*(t1*t1-t0*t0)/2.;}else if(type==1.){vec2 p0=vec2(0.,value.y);vec2 p1=vec2(value.w,value.z);return integrateByTimeLineSeg(t1,p0,p1)-integrateByTimeLineSeg(t0,p0,p1);}if(type==2.){float idx=floor(value.y);float ilen=floor(1./fract(value.y)+0.5);float d=integrateByTimeFromCurveFrames(t1,idx,ilen)-integrateByTimeFromCurveFrames(t0,idx,ilen);return d*value.w+value.z*pow(t1-t0,2.)*0.5;}if(type==3.){return integrateByTimeFromLineSeg(t1,value.y,value.z)-integrateByTimeFromLineSeg(t0,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed)*(t1*t1-t0*t0)/2.;}return 0.;}const float d2r=3.141592653589793/180.;in vec3 aPos;in vec4 aOffset;in vec3 aVel;in vec3 aRot;in vec4 aColor;in vec3 aDirX;in vec3 aDirY;\n#ifdef USE_SPRITE\nin vec3 aSprite;uniform vec4 uSprite;struct UVDetail{vec2 uv0;vec3 uv1;};UVDetail getSpriteUV(vec2 uv,float lifeTime);out vec4 vTexCoordBlend;\n#endif\n#pragma EDITOR_VERT_DEFINE\n#ifdef FINAL_TARGET\nuniform vec3 uFinalTarget;uniform vec4 uForceCurve;\n#endif\nuniform mat4 mars_ObjectToWorld;uniform mat4 mars_MatrixV;uniform mat4 mars_MatrixVP;uniform vec4 uParams;uniform vec4 uAcceleration;uniform vec4 uGravityModifierValue;uniform vec4 uOpacityOverLifetimeValue;\n#ifdef ROT_X_LIFETIME\nuniform vec4 uRXByLifeTimeValue;\n#endif\n#ifdef ROT_Y_LIFETIME\nuniform vec4 uRYByLifeTimeValue;\n#endif\n#ifdef ROT_Z_LIFETIME\nuniform vec4 uRZByLifeTimeValue;\n#endif\n#ifdef COLOR_OVER_LIFETIME\nuniform sampler2D uColorOverLifetime;\n#endif\n#if LINEAR_VEL_X + LINEAR_VEL_Y + LINEAR_VEL_Z\n#if LINEAR_VEL_X\nuniform vec4 uLinearXByLifetimeValue;\n#endif\n#if LINEAR_VEL_Y\nuniform vec4 uLinearYByLifetimeValue;\n#endif\n#if LINEAR_VEL_Z\nuniform vec4 uLinearZByLifetimeValue;\n#endif\n#endif\n#ifdef SPEED_OVER_LIFETIME\nuniform vec4 uSpeedLifetimeValue;\n#endif\n#if ORB_VEL_X + ORB_VEL_Y + ORB_VEL_Z\n#if ORB_VEL_X\nuniform vec4 uOrbXByLifetimeValue;\n#endif\n#if ORB_VEL_Y\nuniform vec4 uOrbYByLifetimeValue;\n#endif\n#if ORB_VEL_Z\nuniform vec4 uOrbZByLifetimeValue;\n#endif\nuniform vec3 uOrbCenter;\n#endif\nuniform vec4 uSizeByLifetimeValue;\n#ifdef SIZE_Y_BY_LIFE\nuniform vec4 uSizeYByLifetimeValue;\n#endif\nout float vLife;out vec4 vColor;out vec2 vTexCoord;\n#ifdef USE_FILTER\n#pragma FILTER_VERT\n#endif\n#ifdef ENV_EDITOR\nuniform vec4 uEditorTransform;\n#endif\nvec3 calOrbitalMov(float _life,float _dur){vec3 orb=vec3(0.0);\n#ifdef AS_ORBITAL_MOVEMENT\n#define FUNC(a) getValueFromTime(_life,a)\n#else\n#define FUNC(a) getIntegrateFromTime0(_life,a) * _dur\n#endif\n#if ORB_VEL_X\norb.x=FUNC(uOrbXByLifetimeValue);\n#endif\n#if ORB_VEL_Y\norb.y=FUNC(uOrbYByLifetimeValue);\n#endif\n#if ORB_VEL_Z\norb.z=FUNC(uOrbZByLifetimeValue);\n#endif\n#undef FUNC\nreturn orb;}vec3 calLinearMov(float _life,float _dur){vec3 mov=vec3(0.0);\n#ifdef AS_LINEAR_MOVEMENT\n#define FUNC(a) getValueFromTime(_life,a)\n#else\n#define FUNC(a) getIntegrateFromTime0(_life,a) * _dur\n#endif\n#if LINEAR_VEL_X\nmov.x=FUNC(uLinearXByLifetimeValue);\n#endif\n#if LINEAR_VEL_Y\nmov.y=FUNC(uLinearYByLifetimeValue);\n#endif\n#if LINEAR_VEL_Z\nmov.z=FUNC(uLinearZByLifetimeValue);\n#endif\n#undef FUNC\nreturn mov;}mat3 mat3FromRotation(vec3 rotation){vec3 sinR=sin(rotation*d2r);vec3 cosR=cos(rotation*d2r);return mat3(cosR.z,-sinR.z,0.,sinR.z,cosR.z,0.,0.,0.,1.)*mat3(cosR.y,0.,sinR.y,0.,1.,0.,-sinR.y,0,cosR.y)*mat3(1.,0.,0.,0,cosR.x,-sinR.x,0.,sinR.x,cosR.x);}\n#ifdef USE_SPRITE\nUVDetail getSpriteUV(vec2 uv,float lifeTime){float t=fract(clamp((lifeTime-aSprite.x)/aSprite.y,0.0,1.)*aSprite.z);float frame=uSprite.z*t;float frameIndex=max(ceil(frame)-1.,0.);float row=floor((frameIndex+0.1)/uSprite.x);float col=frameIndex-row*uSprite.x;vec2 retUV=(vec2(col,row)+uv)/uSprite.xy;UVDetail ret;if(uSprite.w>0.){float blend=frame-frameIndex;float frameIndex1=min(ceil(frame),uSprite.z-1.);float row1=floor((frameIndex1+0.1)/uSprite.x);float col1=frameIndex1-row1*uSprite.x;vec2 coord=(vec2(col1,row1)+uv)/uSprite.xy-retUV;ret.uv1=vec3(coord.x,1.-coord.y,blend);}ret.uv0=vec2(retUV.x,1.-retUV.y);return ret;}\n#endif\nvec3 calculateTranslation(vec3 vel,float t0,float t1,float dur){float dt=t1-t0;float d=getIntegrateByTimeFromTime(0.,dt,uGravityModifierValue);vec3 acc=uAcceleration.xyz*d;\n#ifdef SPEED_OVER_LIFETIME\nreturn vel*getIntegrateFromTime0(dt/dur,uSpeedLifetimeValue)*dur+acc;\n#endif\nreturn vel*dt+acc;}mat3 transformFromRotation(vec3 rot,float _life,float _dur){vec3 rotation=rot;\n#ifdef ROT_LIFETIME_AS_MOVEMENT\n#define FUNC1(a) getValueFromTime(_life,a)\n#else\n#define FUNC1(a) getIntegrateFromTime0(_life,a) * _dur\n#endif\n#ifdef ROT_X_LIFETIME\nrotation.x+=FUNC1(uRXByLifeTimeValue);\n#endif\n#ifdef ROT_Y_LIFETIME\nrotation.y+=FUNC1(uRYByLifeTimeValue);\n#endif\n#ifdef ROT_Z_LIFETIME\nrotation.z+=FUNC1(uRZByLifeTimeValue);\n#endif\nif(dot(rotation,rotation)==0.0){return mat3(1.0);}\n#undef FUNC1\nreturn mat3FromRotation(rotation);}void main(){float time=uParams.x-aOffset.z;float dur=aOffset.w;if(time<0.||time>dur){gl_Position=vec4(-3.,-3.,-3.,1.);}else{float life=clamp(time/dur,0.0,1.0);vLife=life;\n#ifdef USE_SPRITE\nUVDetail uvD=getSpriteUV(aOffset.xy,time);vTexCoord=uvD.uv0;vTexCoordBlend=vec4(uvD.uv1,uSprite.w);\n#else\nvTexCoord=aOffset.xy;\n#endif\nvColor=aColor;\n#ifdef COLOR_OVER_LIFETIME\n#ifdef ENABLE_VERTEX_TEXTURE\nvColor*=texture2D(uColorOverLifetime,vec2(life,0.));\n#endif\n#endif\nvColor.a*=clamp(getValueFromTime(life,uOpacityOverLifetimeValue),0.,1.);vec3 size=vec3(vec2(getValueFromTime(life,uSizeByLifetimeValue)),1.0);\n#ifdef SIZE_Y_BY_LIFE\nsize.y=getValueFromTime(life,uSizeYByLifetimeValue);\n#endif\nvec3 point=transformFromRotation(aRot,life,dur)*(aDirX*size.x+aDirY*size.y);vec3 pt=calculateTranslation(aVel,aOffset.z,uParams.x,dur);vec3 _pos=aPos+pt;\n#if ORB_VEL_X + ORB_VEL_Y + ORB_VEL_Z\n_pos=mat3FromRotation(calOrbitalMov(life,dur))*(_pos-uOrbCenter);_pos+=uOrbCenter;\n#endif\n#if LINEAR_VEL_X + LINEAR_VEL_Y + LINEAR_VEL_Z\n_pos.xyz+=calLinearMov(life,dur);\n#endif\n#ifdef FINAL_TARGET\nfloat force=getValueFromTime(life,uForceCurve);vec4 pos=vec4(mix(_pos,uFinalTarget,force),1.);\n#else\nvec4 pos=vec4(_pos,1.0);\n#endif\n#if RENDER_MODE == 1\npos.xyz+=point;pos=mars_ObjectToWorld*pos;\n#elif RENDER_MODE == 3\npos=mars_ObjectToWorld*pos;pos.xyz+=mars_MatrixV[0].xyz*point.x+mars_MatrixV[2].xyz*point.y;\n#elif RENDER_MODE == 2\npos=mars_ObjectToWorld*pos;pos.xy+=point.xy;\n#elif RENDER_MODE == 0\npos=mars_ObjectToWorld*pos;pos.xyz+=mars_MatrixV[0].xyz*point.x+mars_MatrixV[1].xyz*point.y;\n#endif\ngl_Position=mars_MatrixVP*pos;vSeed=aSeed;gl_PointSize=6.0;\n#ifdef USE_FILTER\nfilterMain(life);\n#endif\n#ifdef ENV_EDITOR\ngl_Position=vec4(gl_Position.xy*uEditorTransform.xy+uEditorTransform.zw*gl_Position.w,gl_Position.zw);\n#endif\n#pragma EDITOR_VERT_TRANSFORM\n}}";

var trailVert = "#version 300 es\nprecision mediump float;\n#define SHADER_VERTEX 1\n#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#else\n#endif\n#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#define CURVE_VALUE_COUNT VERT_CURVE_VALUE_COUNT\n#define FRAG_CURVE_VALUE_COUNT 0\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#define CURVE_VALUE_COUNT FRAG_CURVE_VALUE_COUNT\n#define VERT_CURVE_VALUE_COUNT 0\n#endif\n#if CURVE_VALUE_COUNT > 0\n#if LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;const float uCurveCount=1./float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#else\n#define lookup_curve(i) vec4(0.)\n#endif\n#ifdef WEBGL2\n#define ITR_END (count + 1)\n#else\n#define ITR_END MAX_C\n#endif\n#ifdef SHADER_VERTEX\nin float aSeed;out float vSeed;\n#define NONE_CONST_INDEX 1\n#else\n#if LOOKUP_TEXTURE_CURVE\n#define NONE_CONST_INDEX 1\n#endif\n#endif\n#ifdef NONE_CONST_INDEX\n#ifdef SHADER_VERTEX\n#define MAX_C VERT_MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C FRAG_MAX_KEY_FRAME_COUNT\n#endif\n#else\n#define MAX_C CURVE_VALUE_COUNT\n#endif\nfloat evaluateCurveFrames(float time,vec4 keyframe0,vec4 keyframe1){float dt=keyframe1.x-keyframe0.x;float m0=keyframe0.w*dt;float m1=keyframe1.z*dt;float t=(time-keyframe0.x)/dt;float t2=t*t;float t3=t2*t;return dot(vec4(dot(vec3(2.,-3.,1.),vec3(t3,t2,1.)),dot(vec3(1,-2.,1),vec3(t3,t2,t)),t3-t2,dot(vec2(-2,3),vec2(t3,t2))),vec4(keyframe0.y,m0,m1,keyframe1.y));}float valueFromCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);int end=start+count;for(int i=0;i<ITR_END;i++){\n#ifdef NONE_CONST_INDEX\nif(i==count){return lookup_curve(count).y;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);\n#else\nif(i<start){continue;}vec4 k0=lookup_curve(i);vec4 k1=lookup_curve(i+1);if(i==end){return k0.y;}\n#endif\nif(time>=k0.x&&time<=k1.x){return evaluateCurveFrames(time,k0,k1);}}return lookup_curve(0).y;}float evaluteLineSeg(float t,vec2 p0,vec2 p1){return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);}float valueFromLineSegs(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);int end=start+count;for(int i=0;i<ITR_END;i++){\n#ifdef NONE_CONST_INDEX\nif(i>count){return lookup_curve(i).w;}\n#else\nif(i<start){continue;}if(i>end){return lookup_curve(i-2).w;}\n#endif\n#ifdef NONE_CONST_INDEX\nvec4 seg=lookup_curve(i+start);\n#else\nvec4 seg=lookup_curve(i);\n#endif\nvec2 p0=seg.xy;vec2 p1=seg.zw;if(time>=p0.x&&time<=p1.x){return evaluteLineSeg(time,p0,p1);}\n#ifdef NONE_CONST_INDEX\nvec2 p2=lookup_curve(i+start+1).xy;\n#else\nvec2 p2=lookup_curve(i+1).xy;\n#endif\nif(time>p1.x&&time<=p2.x){return evaluteLineSeg(time,p1,p2);}}return lookup_curve(0).y;}float getValueFromTime(float time,vec4 value){float type=value.x;if(type==0.){return value.y;}else if(type==1.){return mix(value.y,value.z,time/value.w);}if(type==2.){return valueFromCurveFrames(time,floor(value.y),floor(1./fract(value.y)+0.5))*value.w+value.z;}if(type==3.){return valueFromLineSegs(time,value.y,value.z);}if(type==4.){\n#ifdef SHADER_VERTEX\nfloat seed=aSeed;\n#else\nfloat seed=vSeed;\n#endif\nreturn mix(value.y,value.z,seed);}return 0.;}in vec4 aPos;in vec3 aDir;in vec3 aInfo;in vec4 aColor;in float aTime;\n#ifdef ATTR_TRAIL_START\nin float aTrailStart;\n#else\nuniform float uTrailStart[64];in float aTrailStartIndex;\n#endif\nuniform mat4 mars_MatrixInvV;uniform mat4 mars_ObjectToWorld;uniform mat4 mars_MatrixVP;uniform vec4 uTextureMap;uniform float uTime;uniform vec4 uParams;uniform vec4 uColorParams;uniform vec4 uOpacityOverLifetimeValue;uniform vec4 uWidthOverTrail;\n#ifdef COLOR_OVER_TRAIL\nuniform sampler2D uColorOverTrail;\n#endif\n#ifdef COLOR_OVER_LIFETIME\nuniform sampler2D uColorOverLifetime;\n#endif\nout float vLife;out vec2 vTexCoord;out vec4 vColor;\n#ifdef ENV_EDITOR\nuniform vec4 uEditorTransform;\n#endif\nvoid main(){vec4 _pa=mars_MatrixVP*vec4(aPos.xyz,1.);vec4 _pb=mars_MatrixVP*vec4(aPos.xyz+aDir,1.);vec2 dir=normalize(_pb.xy/_pb.w-_pa.xy/_pa.w);vec2 screen_xy=vec2(-dir.y,dir.x);vec4 pos=mars_ObjectToWorld*vec4(aPos.xyz,1.);\n#ifdef ATTR_TRAIL_START\nfloat ts=aTrailStart;\n#else\nfloat ts=uTrailStart[int(aTrailStartIndex)];\n#endif\nfloat trail=(ts-aInfo.y)/uParams.y;float width=aPos.w*getValueFromTime(trail,uWidthOverTrail)/max(abs(screen_xy.x),abs(screen_xy.y));pos.xyz+=(mars_MatrixInvV[0].xyz*screen_xy.x+mars_MatrixInvV[1].xyz*screen_xy.y)*width;float time=min((uTime-aTime)/aInfo.x,1.0);gl_Position=mars_MatrixVP*pos;vColor=aColor;\n#ifdef COLOR_OVER_LIFETIME\n#ifdef ENABLE_VERTEX_TEXTURE\nvColor*=texture2D(uColorOverLifetime,vec2(time,0.));\n#endif\n#endif\n#ifdef COLOR_OVER_TRAIL\nvColor*=texture2D(uColorOverTrail,vec2(trail,0.));\n#endif\nvColor.a*=clamp(getValueFromTime(time,uOpacityOverLifetimeValue),0.,1.);vLife=time;vTexCoord=uTextureMap.xy+vec2(trail,aInfo.z)*uTextureMap.zw;vSeed=aSeed;\n#ifdef ENV_EDITOR\ngl_Position=vec4(gl_Position.xy*uEditorTransform.xy+uEditorTransform.zw*gl_Position.w,gl_Position.zw);\n#endif\n}";

var value = "#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#define CURVE_VALUE_COUNT VERT_CURVE_VALUE_COUNT\n#define FRAG_CURVE_VALUE_COUNT 0\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#define CURVE_VALUE_COUNT FRAG_CURVE_VALUE_COUNT\n#define VERT_CURVE_VALUE_COUNT 0\n#endif\n#if CURVE_VALUE_COUNT > 0\n#if LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;const float uCurveCount=1./float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#else\n#define lookup_curve(i) vec4(0.)\n#endif\n#ifdef WEBGL2\n#define ITR_END (count + 1)\n#else\n#define ITR_END MAX_C\n#endif\n#ifdef SHADER_VERTEX\nin float aSeed;out float vSeed;\n#define NONE_CONST_INDEX 1\n#else\n#if LOOKUP_TEXTURE_CURVE\n#define NONE_CONST_INDEX 1\n#endif\n#endif\n#ifdef NONE_CONST_INDEX\n#ifdef SHADER_VERTEX\n#define MAX_C VERT_MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C FRAG_MAX_KEY_FRAME_COUNT\n#endif\n#else\n#define MAX_C CURVE_VALUE_COUNT\n#endif\nfloat evaluateCurveFrames(float time,vec4 keyframe0,vec4 keyframe1){float dt=keyframe1.x-keyframe0.x;float m0=keyframe0.w*dt;float m1=keyframe1.z*dt;float t=(time-keyframe0.x)/dt;float t2=t*t;float t3=t2*t;return dot(vec4(dot(vec3(2.,-3.,1.),vec3(t3,t2,1.)),dot(vec3(1,-2.,1),vec3(t3,t2,t)),t3-t2,dot(vec2(-2,3),vec2(t3,t2))),vec4(keyframe0.y,m0,m1,keyframe1.y));}float valueFromCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);int end=start+count;for(int i=0;i<ITR_END;i++){\n#ifdef NONE_CONST_INDEX\nif(i==count){return lookup_curve(count).y;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);\n#else\nif(i<start){continue;}vec4 k0=lookup_curve(i);vec4 k1=lookup_curve(i+1);if(i==end){return k0.y;}\n#endif\nif(time>=k0.x&&time<=k1.x){return evaluateCurveFrames(time,k0,k1);}}return lookup_curve(0).y;}float evaluteLineSeg(float t,vec2 p0,vec2 p1){return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);}float valueFromLineSegs(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);int end=start+count;for(int i=0;i<ITR_END;i++){\n#ifdef NONE_CONST_INDEX\nif(i>count){return lookup_curve(i).w;}\n#else\nif(i<start){continue;}if(i>end){return lookup_curve(i-2).w;}\n#endif\n#ifdef NONE_CONST_INDEX\nvec4 seg=lookup_curve(i+start);\n#else\nvec4 seg=lookup_curve(i);\n#endif\nvec2 p0=seg.xy;vec2 p1=seg.zw;if(time>=p0.x&&time<=p1.x){return evaluteLineSeg(time,p0,p1);}\n#ifdef NONE_CONST_INDEX\nvec2 p2=lookup_curve(i+start+1).xy;\n#else\nvec2 p2=lookup_curve(i+1).xy;\n#endif\nif(time>p1.x&&time<=p2.x){return evaluteLineSeg(time,p1,p2);}}return lookup_curve(0).y;}float getValueFromTime(float time,vec4 value){float type=value.x;if(type==0.){return value.y;}else if(type==1.){return mix(value.y,value.z,time/value.w);}if(type==2.){return valueFromCurveFrames(time,floor(value.y),floor(1./fract(value.y)+0.5))*value.w+value.z;}if(type==3.){return valueFromLineSegs(time,value.y,value.z);}if(type==4.){\n#ifdef SHADER_VERTEX\nfloat seed=aSeed;\n#else\nfloat seed=vSeed;\n#endif\nreturn mix(value.y,value.z,seed);}return 0.;}";

var valueDefine = "#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#define CURVE_VALUE_COUNT VERT_CURVE_VALUE_COUNT\n#define FRAG_CURVE_VALUE_COUNT 0\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#define CURVE_VALUE_COUNT FRAG_CURVE_VALUE_COUNT\n#define VERT_CURVE_VALUE_COUNT 0\n#endif\n#if CURVE_VALUE_COUNT > 0\n#if LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;const float uCurveCount=1./float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#else\n#define lookup_curve(i) vec4(0.)\n#endif\n#ifdef WEBGL2\n#define ITR_END (count + 1)\n#else\n#define ITR_END MAX_C\n#endif\n";

var alphaFrameFrag = "uniform vec4 uTexRange;uniform vec2 uFilterSourceSize;\n#define INTERPOLATION 0\nvec4 filterMain(vec2 texCoord,sampler2D source){float x=uTexRange.x+texCoord.x*uTexRange.y;\n#if INTERPOLATION\nvec2 texInPixel=texCoord*uFilterSourceSize;vec2 coordMin=floor(texInPixel);vec2 pp=texInPixel-coordMin;vec4 fCoord=vec4(coordMin/uFilterSourceSize,(coordMin+vec2(1.))/uFilterSourceSize);vec4 cLT=texture2D(uFilterSource,vec2(fCoord.x,fCoord.w));vec4 cLB=texture2D(uFilterSource,vec2(fCoord.x,fCoord.y));vec4 cRT=texture2D(uFilterSource,vec2(fCoord.z,fCoord.w));vec4 cRB=texture2D(uFilterSource,vec2(fCoord.z,fCoord.y));vec4 color=mix(mix(cLB,cRB,pp.x),mix(cLT,cRT,pp.x),pp.y);\n#else\nvec4 color=texture2D(source,vec2(x,texCoord.y));\n#endif\nx=uTexRange.z+texCoord.x*uTexRange.w;vec4 opacity=texture2D(source,vec2(x,texCoord.y));return vec4(color.rgb,opacity.r);}";

var alphaMaskFrag = "uniform sampler2D uAlphaXSample;uniform sampler2D uAlphaYSample;vec4 filterMain(vec2 texCoord,sampler2D source){vec4 color=texture2D(source,texCoord);float x=texture2D(uAlphaXSample,vec2(vFeatherCoord.x,0.)).r;float y=texture2D(uAlphaYSample,vec2(vFeatherCoord.y,0.)).r;return vec4(color.rgb,color.a*min(x,y));}";

var cameraMove_frag = "uniform vec2 uMoveTexSize;uniform sampler2D uFilterSource;\n#define INTERPOLATION 1\nvec4 filterMain(vec2 texCoord,sampler2D tex){\n#ifdef INTERPOLATION\nvec2 texInPixel=texCoord*uMoveTexSize;vec2 coordMin=floor(texInPixel);vec2 pp=texInPixel-coordMin;vec4 fCoord=vec4(coordMin/uMoveTexSize,(coordMin+vec2(1.))/uMoveTexSize);vec4 cLT=texture2D(uFilterSource,vec2(fCoord.x,fCoord.w));vec4 cLB=texture2D(uFilterSource,vec2(fCoord.x,fCoord.y));vec4 cRT=texture2D(uFilterSource,vec2(fCoord.z,fCoord.w));vec4 cRB=texture2D(uFilterSource,vec2(fCoord.z,fCoord.y));vec4 cB=mix(cLB,cRB,pp.x);vec4 cT=mix(cLT,cRT,pp.x);return mix(cB,cT,pp.y);\n#else\nreturn texture2D(uFilterSource,texCoord);\n#endif\n}";

var cameraMoveVert = "uniform mat4 uMoveCameraViewPro;vec4 filterMain(float p,vec4 pos){return uMoveCameraViewPro*pos;}";

var delayFrag = "uniform sampler2D uLastSource;uniform vec4 uParams;vec4 filterMain(vec2 coord,sampler2D tex){vec4 c1=texture2D(tex,coord);if(uParams.x<1.){return c1;}vec4 c2=texture2D(uLastSource,coord);return mix(c1,c2,uParams.y);}";

var distortionFrag = "uniform vec4 uWaveParams;\n#ifdef PATICLE_SHADER\nin vec4 vWaveParams;\n#else\nuniform vec4 vWaveParams;\n#endif\nvec4 filterMain(vec2 texCoord,sampler2D tex){vec2 vp=texCoord-uWaveParams.xy;float xx=dot(vp,uWaveParams.zw);float d=sin(vWaveParams.x*xx+vWaveParams.y)*vWaveParams.z;vec2 up=vec2(-uWaveParams.w,uWaveParams.z)*d;return texture2D(tex,clamp(texCoord+up,0.,1.));}";

var distortionVert = "uniform vec4 uMovementValue;uniform vec4 uStrengthValue;uniform vec4 uPeriodValue;out vec4 vWaveParams;void filterMain(float lifetime){const float pi2=3.14159265;vWaveParams=vec4(getValueFromTime(lifetime,uPeriodValue)*pi2,getValueFromTime(lifetime,uMovementValue)*pi2,getValueFromTime(lifetime,uStrengthValue),0.);}";

var bloomMixVert = "uniform sampler2D uBloomBlur;uniform vec4 uBloomParams;vec4 filterMain(vec2 coord,sampler2D tex){const vec3 gamma=vec3(1./2.2);vec4 c1=texture2D(tex,coord);vec4 bloomColor=texture2D(uBloomBlur,coord);float alpha=max(c1.a,bloomColor.a);vec3 color=max(c1.rgb*c1.a,bloomColor.rgb*bloomColor.a)/alpha*uBloomParams.y+bloomColor.rgb*uBloomParams.x;return vec4(color,alpha);}";

var bloomThresholdVert = "uniform vec4 uColorThreshold;vec4 filterMain(vec2 coord,sampler2D tex){vec4 c1=texture2D(tex,coord);vec3 color=c1.rgb*c1.a;vec3 s=step(uColorThreshold.xyz,color);float m=min(s.r+s.g+s.b,1.);return c1*m;}";

var _a$7;
exports.maxSpriteMeshItemCount = 8;
exports.maxSpriteTextureCount = 8;
var particleOriginMap = (_a$7 = {},
    _a$7[ParticleOrigin$1.PARTICLE_ORIGIN_CENTER] = translatePoint(0, 0),
    _a$7);
var seed$7 = 1;
var SpriteMesh = /** @class */ (function () {
    function SpriteMesh(renderInfo, calculateGroup) {
        this.calculateGroup = calculateGroup;
        this.items = [];
        this.dirty = false;
        var wireframe = renderInfo.wireframe;
        var geometry = this.createGeometry(wireframe ? glContext.LINES : glContext.TRIANGLES);
        var material = this.createMaterial(renderInfo, 2);
        this.wireframe = wireframe;
        this.mesh = Mesh.create({
            name: 'MSprite' + seed$7++,
            priority: 0,
            worldMatrix: mat4create(),
            geometry: geometry,
            material: material,
        });
    }
    SpriteMesh.prototype.setItems = function (items) {
        var _a, _b, _c, _d;
        var datas = [];
        var textures = [];
        var itemSlot = 2;
        var aPointLen = 0;
        var indexLen = 0;
        var pointCount = 0;
        if (!items.length) {
            this.mesh.setVisible(true);
            return true;
        }
        this.items = items.slice();
        if (items.length > 2) {
            itemSlot = exports.maxSpriteMeshItemCount;
        }
        var renderInfo = items[0].renderInfo;
        if (this.mtlSlotCount !== itemSlot) {
            this.mesh.setMaterial(this.createMaterial(renderInfo, itemSlot), { textures: exports.DestroyOptions.keep });
        }
        var attachmentLength = (_d = (_c = (_b = (_a = renderInfo === null || renderInfo === void 0 ? void 0 : renderInfo.filter) === null || _a === void 0 ? void 0 : _a.passSplitOptions) === null || _b === void 0 ? void 0 : _b.attachments) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
        this.splitLayer = attachmentLength > 0;
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var texture = item === null || item === void 0 ? void 0 : item.renderer.texture;
            if (texture) {
                addItem(textures, texture);
            }
            item.mesh = this;
        }
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var texture = item === null || item === void 0 ? void 0 : item.renderer.texture;
            var textureIndex = texture ? textures.indexOf(texture) : -1;
            var data = this.getItemInitData(item, i, pointCount, textureIndex);
            aPointLen += data.aPoint.length;
            indexLen += data.index.length;
            datas.push(data);
            pointCount += data.aPoint.length / 6;
            this.updateItem(item, true);
        }
        var bundle = {
            aPoint: new Float32Array(aPointLen),
            index: new Uint16Array(indexLen),
        };
        var cursor = {
            aPoint: 0,
            index: 0,
        };
        var _loop_1 = function (i) {
            var data = datas[i];
            Object.keys(bundle).forEach(function (name) {
                var arr = bundle[name];
                var ta = data[name];
                arr.set(ta, cursor[name]);
                cursor[name] += ta.length;
            });
        };
        for (var i = 0; i < datas.length; i++) {
            _loop_1(i);
        }
        var _e = this.mesh, material = _e.material, geometries = _e.geometries;
        var geometry = geometries[0];
        var indexData = bundle.index;
        geometry.setIndexData(indexData);
        geometry.setAttributeData('aPoint', bundle.aPoint);
        geometry.setDrawCount(indexLen);
        this.mesh.setVisible(!geometry.getDrawCount());
        this.mesh.priority = items[0].listIndex;
        for (var i = 0; i < textures.length; i++) {
            var texture = textures[i];
            material.setTexture('uSampler' + i, texture);
        }
        // FIXME: 内存泄漏的临时方案，后面再调整
        var emptyTexture = items[0].emptyTexture;
        for (var k = textures.length; k < exports.maxSpriteMeshItemCount; k++) {
            material.setTexture('uSampler' + k, emptyTexture);
        }
        if (this.splitLayer) {
            var tex = generateFeatureTexture(items[0].feather);
            material.setTexture('uFeatherSampler', tex);
        }
    };
    SpriteMesh.prototype.updateItem = function (item, init) {
        var index = this.items.indexOf(item);
        if (index <= -1) {
            return;
        }
        // const itemCount = this.items.length;
        //const texData = this.texDataBlock.getUniformValue('uTexParams') as Float32Array;
        var texDataArray = this.mesh.material.getVector4Array('uTexParams');
        var idxStart = index * 4;
        var parentData;
        if (this.calculateGroup && item.parentId) {
            parentData = this.calculateGroup.getRenderData(item.parentId);
        }
        var selfData = item.getRenderData(item.time, init || parentData !== undefined);
        parentData = parentData !== null && parentData !== void 0 ? parentData : {};
        //const uniformValue = this.mainDataBlock.getUniformValue('uMainData') as Float32Array;
        //const mainData = uniformValue.buffer;
        var mainDataArray = this.mesh.material.getMatrixArray('uMainData');
        var start = index * 16;
        var uPosStart = start;
        var uPos = [mainDataArray[uPosStart], mainDataArray[uPosStart + 1], mainDataArray[uPosStart + 2], mainDataArray[uPosStart + 3]];
        //byteStart += rowLen;
        start += 4;
        var uSizeStart = start;
        var uSize = [mainDataArray[uSizeStart], mainDataArray[uSizeStart + 1], mainDataArray[uSizeStart + 2], mainDataArray[uSizeStart + 3]];
        //byteStart += rowLen;
        start += 4;
        var uQuatStart = start;
        var uQuat = [mainDataArray[uQuatStart], mainDataArray[uQuatStart + 1], mainDataArray[uQuatStart + 2], mainDataArray[uQuatStart + 3]];
        //byteStart += rowLen;
        start += 4;
        var uColorStart = start;
        var uColor = [mainDataArray[uColorStart], mainDataArray[uColorStart + 1], mainDataArray[uColorStart + 2], mainDataArray[uColorStart + 3]];
        if (!(parentData.visible || selfData.visible)) {
            //uSize[2] = -1;
            mainDataArray[uSizeStart + 2] = -1;
            return;
        }
        selfData.transform.assignWorldTRS(uPos, uQuat, uSize);
        vecMulCombine(uColor, selfData.color, parentData.color);
        for (var i = 0; i < 4; i++) {
            mainDataArray[uPosStart + i] = uPos[i];
            mainDataArray[uQuatStart + i] = uQuat[i];
            mainDataArray[uSizeStart + i] = uSize[i];
            mainDataArray[uColorStart + i] = uColor[i];
        }
        //this.mainDataBlock.updateUniformSubData('uMainData', index, 1);
        uSize[2] = selfData.life;
        mainDataArray[uSizeStart + 2] = selfData.life;
        if (init) {
            var renderer = item.renderer;
            texDataArray[idxStart] = renderer.occlusion ? +(renderer.transparentOcclusion) : 1;
            texDataArray[idxStart + 2] = renderer.renderMode;
            texDataArray[idxStart + 1] = +this.preMultiAlpha;
            //this.texDataBlock.updateUniformSubData('uTexParams', index, 1);
        }
        if (selfData.texOffset) {
            //const texOffsetData = this.texDataBlock.getUniformValue('uTexOffset') as Float32Array;
            var texOffsetDataArray = this.mesh.material.getVector4Array('uTexOffset');
            for (var i = 0; i < 4; i++) {
                texOffsetDataArray[index * 4 + i] = selfData.texOffset[i];
            }
            //texOffsetData.set(selfData.texOffset, index * 4);
            //this.texDataBlock.updateUniformSubData('uTexOffset', index, 1);
        }
    };
    SpriteMesh.prototype.applyChange = function () {
        if (this.dirty) {
            this.setItems(this.items);
            this.dirty = false;
        }
    };
    SpriteMesh.prototype.getItemInitData = function (item, idx, pointStartIndex, textureIndex) {
        var geoData = item.__geoData;
        if (this.lineMode) {
            geoData = this.getItemGeometryData(item, idx);
        }
        else if (!geoData) {
            geoData = item.__geoData = this.getItemGeometryData(item, idx);
        }
        var pointData = geoData.aPoint;
        if (pointData[4] !== idx || pointData[5] !== textureIndex) {
            for (var i = 0; i < pointData.length; i += 6) {
                pointData[i + 4] = idx;
                pointData[i + 5] = textureIndex;
            }
        }
        var index = geoData.index;
        var idxCount = index.length;
        // @ts-expect-error
        var indexData = this.wireframe ? new Uint8Array([0, 1, 1, 3, 2, 3, 2, 0]) : new index.constructor(idxCount);
        if (!this.wireframe) {
            for (var i = 0; i < idxCount; i++) {
                indexData[i] = pointStartIndex + index[i];
            }
        }
        return {
            aPoint: geoData.aPoint,
            index: indexData,
        };
    };
    SpriteMesh.prototype.getItemRegionData = function (item) {
        var index = this.items.indexOf(item);
        if (index > -1) {
            //const mainData = this.mainDataBlock.getUniformValue('uMainData') as spec.TypedArray;
            var mainData = this.mesh.material.getMatrixArray('uMainData');
            var idx = index * 16;
            if (mainData === null) {
                return;
            }
            return {
                position: [mainData[idx] || 0, mainData[idx + 1] || 0, mainData[idx + 2] || 0],
                size: [mainData[idx + 4], mainData[idx + 5]],
                quat: [mainData[idx + 8], mainData[idx + 9], mainData[idx + 10], mainData[idx + 11]],
                color: [mainData[idx + 12], mainData[idx + 13], mainData[idx + 14], mainData[idx + 15]],
            };
        }
    };
    SpriteMesh.prototype.createGeometry = function (mode) {
        var BYTES_PER_ELEMENT = Float32Array.BYTES_PER_ELEMENT;
        return Geometry.create({
            attributes: {
                aPoint: {
                    size: 4,
                    offset: 0,
                    stride: SPRITE_VERTEX_STRIDE * BYTES_PER_ELEMENT,
                    releasable: true,
                    type: glContext.FLOAT,
                    data: new Float32Array(0),
                },
                aIndex: {
                    size: 2,
                    offset: 4 * BYTES_PER_ELEMENT,
                    stride: SPRITE_VERTEX_STRIDE * BYTES_PER_ELEMENT,
                    dataSource: 'aPoint',
                    type: glContext.FLOAT,
                },
            },
            indices: { data: new Uint16Array(0), releasable: true },
            mode: mode,
            maxVertex: 4 * exports.maxSpriteMeshItemCount,
        });
    };
    SpriteMesh.prototype.createMaterial = function (renderInfo, count) {
        var e_1, _a;
        var filter = renderInfo.filter, side = renderInfo.side, occlusion = renderInfo.occlusion, blending = renderInfo.blending, maskMode = renderInfo.maskMode, mask = renderInfo.mask;
        var filterMesh = (filter === null || filter === void 0 ? void 0 : filter.mesh) || {};
        var materialProps = {
            shader: spriteMeshShaderFromRenderInfo(renderInfo, count),
            uniformSemantics: __assign$1({ mars_MatrixVP: 'VIEWPROJECTION', mars_MatrixInvV: 'VIEWINVERSE', mars_ObjectToWorld: 'MODEL', uEditorTransform: 'EDITOR_TRANSFORM' }, filterMesh.uniformSemantics),
            uniformValues: {},
        };
        this.preMultiAlpha = getPreMultiAlpha(blending);
        this.mtlSlotCount = count;
        var material = Material.create(materialProps);
        var states = __assign$1({ side: side, blending: true, blendMode: blending, mask: mask, maskMode: maskMode, depthTest: true, depthMask: occlusion }, filterMesh.materialStates);
        material.blending = states.blending;
        material.stencilRef = states.mask !== undefined ? [states.mask, states.mask] : undefined;
        material.depthTest = states.depthTest;
        material.depthMask = states.depthMask;
        states.blending && setBlendMode(material, states.blendMode);
        material.blendFunction = states.blendFunction;
        setMaskMode(material, states.maskMode);
        setSideMode(material, states.side);
        var filterUniform = filterMesh.uniformValues;
        // TODO uniform的数据组织形式待优化，临时方案。
        if (filterUniform) {
            try {
                for (var _b = __values$1(Object.keys(filterUniform)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    var value = filterUniform[key];
                    if (value instanceof Texture) {
                        material.setTexture(key, value);
                    }
                    else if (typeof value === 'number') {
                        material.setFloat(key, value);
                    }
                    else if (value.length === 2) {
                        material.setVector2(key, value);
                    }
                    else if (value.length === 4) {
                        material.setVector4(key, value);
                    }
                    else {
                        material.setMatrix(key, value);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        var uMainData = [];
        var uTexParams = [];
        var uTexOffset = [];
        for (var i = 0; i < count; i++) {
            uMainData.push(mat4create());
            uTexParams.push([0, 0, 0, 0]);
            uTexOffset.push([0, 0, 0, 0]);
        }
        if (!material.hasUniform('uMainData')) {
            material.setMatrixArray('uMainData', uMainData);
        }
        if (!material.hasUniform('uTexParams')) {
            material.setVector4Array('uTexParams', uTexParams);
        }
        if (!material.hasUniform('uTexOffset')) {
            material.setVector4Array('uTexOffset', uTexOffset);
        }
        return material;
    };
    SpriteMesh.prototype.getItemGeometryData = function (item, aIndex) {
        var splits = item.splits, renderer = item.renderer, textureSheetAnimation = item.textureSheetAnimation, startSize = item.startSize;
        var _a = __read$1(startSize, 2), sx = _a[0], sy = _a[1];
        item.fallbackAnchor();
        var _b = __read$1(item.anchor, 2), anchorX = _b[0], anchorY = _b[1];
        if (renderer.shape) {
            var _c = renderer.shape, index_1 = _c.index, aPoint_1 = _c.aPoint;
            var point = new Float32Array(aPoint_1);
            for (var i = 0; i < point.length; i += 6) {
                point[i] *= sx;
                point[i + 1] *= sy;
            }
            return {
                index: index_1,
                aPoint: Array.from(point),
            };
        }
        var originData = particleOriginMap[0];
        var aPoint = [];
        var index = [];
        var dx = 0;
        var dy = 0;
        var col = 2;
        var row = 2;
        if (splits.length === 1) {
            col = 1;
            row = 1;
        }
        for (var x = 0; x < col; x++) {
            for (var y = 0; y < row; y++) {
                var base = (y * 2 + x) * 4;
                // @ts-expect-error
                var split = textureSheetAnimation ? [0, 0, 1, 1, splits[0][4]] : splits[y * 2 + x];
                var texOffset = split[4] ? [0, 0, 1, 0, 0, 1, 1, 1] : [0, 1, 0, 0, 1, 1, 1, 0];
                var dw = ((x + x + 1) / col - 1) / 2;
                var dh = ((y + y + 1) / row - 1) / 2;
                var tox = split[0];
                var toy = split[1];
                var tsx = split[4] ? split[3] : split[2];
                var tsy = split[4] ? split[2] : split[3];
                var origin_1 = [
                    (originData[0] + dx) / col + dw,
                    (originData[1] + dy) / row + dh,
                    (originData[2] + dx) / col + dw,
                    (originData[3] + dy) / row + dh,
                    (originData[4] + dx) / col + dw,
                    (originData[5] + dy) / row + dh,
                    (originData[6] + dx) / col + dw,
                    (originData[7] + dy) / row + dh,
                ];
                aPoint.push((origin_1[0] - anchorX) * sx, (origin_1[1] - anchorY) * sy, texOffset[0] * tsx + tox, texOffset[1] * tsy + toy, aIndex, 0, (origin_1[2] - anchorX) * sx, (origin_1[3] - anchorY) * sy, texOffset[2] * tsx + tox, texOffset[3] * tsy + toy, aIndex, 0, (origin_1[4] - anchorX) * sx, (origin_1[5] - anchorY) * sy, texOffset[4] * tsx + tox, texOffset[5] * tsy + toy, aIndex, 0, (origin_1[6] - anchorX) * sx, (origin_1[7] - anchorY) * sy, texOffset[6] * tsx + tox, texOffset[7] * tsy + toy, aIndex, 0);
                if (this.lineMode) {
                    index.push(base, 1 + base, 1 + base, 3 + base, 3 + base, 2 + base, 2 + base, base);
                }
                else {
                    index.push(base, 1 + base, 2 + base, 2 + base, 1 + base, 3 + base);
                }
            }
        }
        return { index: index, aPoint: aPoint };
    };
    return SpriteMesh;
}());
function setSpriteMeshMaxItemCountByGPU(gpuCapability) {
    // 8 or 16
    exports.maxSpriteTextureCount = Math.min(gpuCapability.maxFragmentTextures, 16);
    if (gpuCapability.maxVertexUniforms >= 256) {
        return exports.maxSpriteMeshItemCount = 32;
    }
    else if (gpuCapability.maxVertexUniforms >= 128) {
        return exports.maxSpriteMeshItemCount = 16;
    }
    exports.maxSpriteTextureCount = 8;
}
function getImageItemRenderInfo(item) {
    var _a;
    var renderer = item.renderer;
    var filter = item.filter;
    var blending = renderer.blending, side = renderer.side, occlusion = renderer.occlusion, mask = renderer.mask, maskMode = renderer.maskMode, order = renderer.order;
    var blendingCache = +blending;
    var cachePrefix = item.cachePrefix || '-';
    var filterId = ((_a = filter === null || filter === void 0 ? void 0 : filter.mesh) === null || _a === void 0 ? void 0 : _a.shaderCacheId) || '$F$';
    return {
        side: side,
        occlusion: occlusion,
        blending: blending,
        mask: mask,
        maskMode: maskMode,
        cachePrefix: cachePrefix,
        filter: filter,
        cacheId: "".concat(cachePrefix, ".").concat(filterId, ".").concat(+side, "+").concat(+occlusion, "+").concat(blendingCache, "+").concat(order, "+").concat(maskMode, ".").concat(mask),
    };
}
function spriteMeshShaderFromFilter(filter, options) {
    options = options || { count: 2 };
    var marcos = [
        ['MAX_ITEM_COUNT', options.count || 2],
        ['PRE_MULTIPLY_ALPHA', false],
        ['ENV_EDITOR', getConfig(RUNTIME_ENV) === PLAYER_OPTIONS_ENV_EDITOR],
        ['ADJUST_LAYER', !!filter],
        ['USE_BLEND', !options.ignoreBlend],
        ['MAX_FRAG_TEX', exports.maxSpriteTextureCount >= 16 ? 16 : 8],
    ];
    var fragment = options.wireframe ? itemFrameFrag : itemFrag.replace(/#pragma\s+FILTER_FRAG/, (filter === null || filter === void 0 ? void 0 : filter.fragment) || '');
    var vertex = itemVert.replace(/#pragma\s+FILTER_VERT/, (filter === null || filter === void 0 ? void 0 : filter.vertex) || 'vec4 filterMain(float t,vec4 pos){return mars_MatrixVP * pos;}');
    var level = GPUCapability.getInstance().level;
    return {
        fragment: createShaderWithMarcos(marcos, fragment, exports.ShaderType.fragment),
        vertex: createShaderWithMarcos(marcos, vertex, exports.ShaderType.vertex),
        glslVersion: level === 1 ? exports.GLSLVersion.GLSL1 : exports.GLSLVersion.GLSL3,
        marcos: marcos,
        shared: true,
    };
}
function spriteMeshShaderIdFromRenderInfo(renderInfo, count) {
    return renderInfo.filter ? "".concat(renderInfo.filter.mesh.shaderCacheId, "_mars_filter") : "".concat(renderInfo.cachePrefix, "_mars_sprite_").concat(count);
}
function spriteMeshShaderFromRenderInfo(renderInfo, count) {
    var filter = renderInfo.filter, wireframe = renderInfo.wireframe;
    var shader = spriteMeshShaderFromFilter(filter === null || filter === void 0 ? void 0 : filter.mesh, {
        count: count,
        wireframe: wireframe,
    });
    shader.shared = true;
    if (!wireframe) {
        shader.cacheId = spriteMeshShaderIdFromRenderInfo(renderInfo, count);
    }
    return shader;
}
function generateFeatureTexture(feather) {
    var tex;
    if (!feather) {
        tex = Texture.createWithData();
    }
    else {
        var len = 128;
        var data = new Uint8Array(len);
        for (var i = 0, s = len - 1; i < len; i++) {
            var p = i / s;
            var val = feather.getValue(p);
            data[i] = Math.round(val * 255);
        }
        tex = Texture.createWithData({ width: len, height: 1, data: data }, {
            name: 'feather',
            format: glContext.LUMINANCE,
            minFilter: glContext.LINEAR,
            magFilter: glContext.LINEAR,
            wrapS: glContext.CLAMP_TO_EDGE,
            wrapT: glContext.CLAMP_TO_EDGE,
        });
    }
    return tex;
}
// TODO 只有单测用
function setMaxSpriteMeshItemCount(count) {
    exports.maxSpriteMeshItemCount = count;
}
function setSpriteMeshMaxFragmentTextures(count) {
    exports.maxSpriteTextureCount = count;
}

var itemSortProperty = 'listIndex';
var SpriteGroup = /** @class */ (function () {
    // TODO: 类型
    function SpriteGroup(props) {
        this.meshSplits = [];
        this.items = [];
        this.meshes = []; // meshSplits对应的mesh数组 每次diff后更新
        this.itemsToRemove = [];
        this.itemsToAdd = [];
        this.time = 0;
        var calculateGroup = props.calculateGroup;
        this.calculateGroup = calculateGroup;
    }
    /**
     * 合成reset的时候执行 清空items相关数组
     */
    SpriteGroup.prototype.resetMeshSplits = function () {
        this.meshSplits.length = 0;
        this.meshes.length = 0;
        this.items.length = 0;
        this.itemsToAdd.length = 0;
        this.itemsToRemove.length = 0;
    };
    /**
     * 根据需要添加/移除的元素计算需要增加/移除/修改顺序的mesh并返回
     */
    SpriteGroup.prototype.diffMeshSplits = function () {
        var _a, _b, _c, _d, _e, _f;
        var splits = this.meshSplits;
        var itemsToRemove = this.itemsToRemove;
        var itemsToAdd = this.itemsToAdd;
        var splitsToRemove = [];
        var meshToAdd = [];
        var meshToRemove = [];
        var meshToModify = [];
        var items = this.items;
        var layer = { layerToAdd: [] };
        var combined = [];
        /**
         * 移除元素
         * 图层元素，从items和含有元素的meshSplit中移除元素并获取需要移除的MeshSplit
         * 滤镜元素，从items移除元素，判断前一个元素 / 后一个元素所在meshSplit能否合并
         */
        for (var i = 0; i < itemsToRemove.length; i++) {
            var item = itemsToRemove[i];
            if (isSprite(item)) {
                splitsToRemove.push.apply(splitsToRemove, __spreadArray([], __read$1(this.removeMeshSplitsItem(items, item, splits, itemsToRemove)), false));
                this.check();
            }
            else {
                var itemIndex = items.indexOf(item);
                if (itemIndex > -1) {
                    items.splice(itemIndex, 1);
                    combined.length = 0;
                    if (itemIndex > 0) {
                        combined = this.combineSplits(items, itemIndex - 1, splits);
                        splitsToRemove.push.apply(splitsToRemove, __spreadArray([], __read$1(combined), false));
                    }
                    if (!combined.length && itemIndex <= items.length - 1) {
                        combined = this.combineSplits(items, itemIndex, splits);
                        splitsToRemove.push.apply(splitsToRemove, __spreadArray([], __read$1(combined), false));
                    }
                    this.check();
                }
            }
        }
        var checkCombine = false;
        /**
         * 添加元素
         * 获取item增加后需要新增的meshSplit，根据renderInfo创建spriteMesh并增加到meshToAdd数组
         * 新增meshSplit都添加后(checkCombine) 检查meshSplit数组是否有相邻可以合并的meshSplit
         */
        for (var i = 0; i < itemsToAdd.length; i++) {
            var item = itemsToAdd[i];
            var neoSplits = this.addMeshSplitsItem(items, item, splits);
            for (var j = 0; j < neoSplits.length; j++) {
                var neoSplit = neoSplits[j];
                if (neoSplit.spriteMesh) {
                    throw new Error('no sprite mesh in neo split');
                }
                var sp = neoSplit.spriteMesh = new SpriteMesh(neoSplit.renderInfo, this.calculateGroup);
                meshToAdd.push(sp.mesh);
                sp.setItems(neoSplit.items.map(function (c) { return c.content; }));
                sp.applyChange();
                if (sp.splitLayer) {
                    (_a = layer.layerToAdd) === null || _a === void 0 ? void 0 : _a.push(sp);
                }
                neoSplit.dirty = false;
                this.check();
                checkCombine = true;
            }
        }
        if (checkCombine) {
            var _loop_1 = function (i) {
                var currentSplit = splits[i];
                var nextSplit = splits[i + 1];
                if (nextSplit.cacheId === currentSplit.cacheId &&
                    !((_b = nextSplit.spriteMesh) === null || _b === void 0 ? void 0 : _b.splitLayer) &&
                    !((_c = currentSplit.spriteMesh) === null || _c === void 0 ? void 0 : _c.splitLayer) &&
                    currentSplit.items.length + nextSplit.items.length <= exports.maxSpriteMeshItemCount) {
                    var first = currentSplit.items[0];
                    var last = nextSplit.items[nextSplit.items.length - 1];
                    var neo_1 = this_1.getMeshSplits(items, items.indexOf(first), items.indexOf(last));
                    if (neo_1.length === 1) {
                        Object.keys(neo_1[0]).forEach(function (key) {
                            // @ts-expect-error
                            currentSplit[key] = neo_1[0][key];
                        });
                        (_d = currentSplit.spriteMesh) === null || _d === void 0 ? void 0 : _d.setItems(currentSplit.items.map(function (i) { return i.content; }));
                        (_e = currentSplit.spriteMesh) === null || _e === void 0 ? void 0 : _e.applyChange();
                        var mesh = (_f = nextSplit.spriteMesh) === null || _f === void 0 ? void 0 : _f.mesh;
                        // @ts-expect-error
                        if (meshToAdd.includes(mesh)) {
                            removeItem(meshToAdd, mesh);
                        }
                        else {
                            addItem(meshToRemove, mesh);
                        }
                        splits.splice(i + 1, 1);
                        i--; //recheck
                    }
                }
                out_i_1 = i;
            };
            var this_1 = this, out_i_1;
            for (var i = 0; i < splits.length - 1; i++) {
                _loop_1(i);
                i = out_i_1;
            }
        }
        // FIXME 重复赋值?
        itemsToRemove.length = 0;
        /**
         * 根据每个meshSplit的indexStart和mesh的priority判断mesh是否需要修改
         * 需要则添加到meshToModify数组
         */
        for (var i = 0; i < splits.length; i++) {
            var split = splits[i];
            // @ts-expect-error
            var spriteMesh = split.spriteMesh;
            if (split.items.length === 0) {
                throw new Error('split not combined');
            }
            if (split.dirty) {
                var priority = split.indexStart;
                if (spriteMesh.mesh.priority !== priority) {
                    meshToModify.push(spriteMesh.mesh);
                }
                spriteMesh.setItems(split.items.map(function (item) { return item.content; }));
            }
            spriteMesh.applyChange();
            split.dirty = false;
        }
        /**
         * 有需要移除的meshSplit 则废弃对应的mesh 保留material
         * 添加到meshToRemove数组
         */
        if (splitsToRemove.length) {
            for (var i = 0; i < splitsToRemove.length; i++) {
                var split = splitsToRemove[i];
                var sp = split.spriteMesh;
                // @ts-expect-error
                var mesh = sp.mesh;
                mesh.dispose({ material: { textures: exports.DestroyOptions.keep } });
                meshToRemove.push(mesh);
            }
        }
        this.itemsToRemove.length = 0;
        this.itemsToAdd.length = 0;
        /**
         * 有mesh需要改动 返回
         */
        if (meshToAdd.length + meshToRemove.length + meshToModify.length) {
            var ms_1 = this.meshes;
            // @ts-expect-error
            this.meshSplits.forEach(function (split, i) { return ms_1[i] = split.spriteMesh.mesh; });
            ms_1.length = this.meshSplits.length;
            return {
                add: meshToAdd.length ? meshToAdd : undefined,
                remove: meshToRemove.length ? meshToRemove : undefined,
                modify: meshToModify.length ? meshToModify : undefined,
                // @ts-expect-error
                layer: layer.layerToAdd.length > 0 ? layer : undefined,
            };
        }
    };
    /**
     * 合成生命周期开始时执行
     * 如果 items 中有该 sprite/filter 类型的 vfxItem 则添加到 itemsToRemove 数组中
     * 如果没有该 vfxItem 添加到 itemsToAdd 数组
     * @param vfxItem
     */
    SpriteGroup.prototype.addItem = function (vfxItem) {
        if (!this.items.includes(vfxItem)) {
            addItem(this.itemsToAdd, vfxItem);
        }
        else {
            removeItem(this.itemsToRemove, vfxItem);
        }
    };
    /**
     * 合成dispose时执行
     * 如果items中有该vfxItem 则添加到itemsToRemove数组中(sprite在头 filter在尾)
     * 如果没有该vfxItem 添加到 itemsToAdd数组
     */
    SpriteGroup.prototype.removeItem = function (item) {
        if (this.items.includes(item)) {
            if (isSprite(item)) {
                this.itemsToRemove.unshift(item);
            }
            else {
                this.itemsToRemove.push(item);
            }
        }
        else {
            removeItem(this.itemsToAdd, item);
        }
    };
    /**
     * 找到指定 item 所在的 spriteMesh
     * @param item
     * @returns
     */
    SpriteGroup.prototype.getSpriteMesh = function (item) {
        var splits = this.meshSplits;
        for (var i = 0; i < splits.length; i++) {
            // FIXME: spriteMesh 的可选性
            var mesh = splits[i].spriteMesh;
            var itemIndex = mesh.items.indexOf(item);
            if (itemIndex > -1) {
                return mesh;
            }
        }
    };
    /**
     * 合成在每帧 tick 时执行
     * 对 meshSplits 数组中包含的每个 spriteMesh 上的 item 更新时间
     * 再更新 mesh 的 geometry 和 material 中 item 对应位置上的数据
     */
    SpriteGroup.prototype.onUpdate = function (dt) {
        var time = (this.time += dt / 1000);
        var splits = this.meshSplits;
        for (var i = 0; i < splits.length; i++) {
            // FIXME: spriteMesh 的可选性
            var mesh = splits[i].spriteMesh;
            //mesh.time = time;
            var items = mesh.items;
            for (var j = 0; j < items.length; j++) {
                var item = items[j];
                item.updateTime(time);
                if (!item.ended) {
                    mesh.updateItem(item);
                }
            }
            mesh.applyChange();
        }
    };
    SpriteGroup.prototype.dispose = function () {
        this.meshSplits.forEach(function (mesh) {
            var _a;
            (_a = mesh.spriteMesh) === null || _a === void 0 ? void 0 : _a.mesh.dispose();
        });
    };
    SpriteGroup.prototype.check = function () {
    };
    /**
     * 添加元素到合适的 meshSplit 上
     * 返回新添加的 meshSplit 数组（返回 meshSplit 没有真的创建 spriteMesh）
     * @internal
     */
    SpriteGroup.prototype.addMeshSplitsItem = function (items, item, splits) {
        var itemIndex = items.indexOf(item);
        if (itemIndex !== -1) {
            throw Error('item has been added');
        }
        var firstSplit = splits[0];
        if (!firstSplit) {
            addItemWithOrder(items, item, itemSortProperty);
            if (isSprite(item)) {
                var content = item.createContent();
                var split = {
                    indexStart: item.listIndex,
                    indexEnd: item.listIndex,
                    items: [item],
                    renderInfo: content.renderInfo,
                    cacheId: content.renderInfo.cacheId,
                    textures: [item.content.renderer.texture],
                };
                splits.unshift(split);
                return [split];
            }
            return [];
        }
        var _loop_2 = function (i) {
            var split = splits[i];
            var listIndex = item.listIndex;
            if (isSprite(item)) {
                // @ts-expect-error
                if (listIndex <= split.indexEnd) {
                    addItemWithOrder(items, item, itemSortProperty);
                    var itemIndex_1 = items.indexOf(item);
                    var indexStart = Math.min(itemIndex_1, items.indexOf(split.items[0]));
                    var indexEnd = Math.max(itemIndex_1, items.indexOf(split.items[split.items.length - 1]));
                    var neoSplits_1 = this_2.getMeshSplits(items, indexStart, indexEnd);
                    var neoSplitIndex_1 = neoSplits_1.findIndex(function (split) { return split.items.includes(item); });
                    if (neoSplits_1.length === 2) {
                        splits.splice(i + neoSplitIndex_1, 0, neoSplits_1[neoSplitIndex_1]);
                        //1 or 0
                        Object.keys(neoSplits_1[1 - neoSplitIndex_1]).forEach(function (key) {
                            // @ts-expect-error
                            split[key] = neoSplits_1[1 - neoSplitIndex_1][key];
                        });
                        return { value: [neoSplits_1[neoSplitIndex_1]] };
                    }
                    else if (neoSplits_1.length === 3) {
                        Object.keys(neoSplits_1[0]).forEach(function (key) {
                            // @ts-expect-error
                            split[key] = neoSplits_1[0][key];
                        });
                        splits.splice(i + 1, 0, neoSplits_1[1], neoSplits_1[2]);
                        if (neoSplitIndex_1 !== 1) {
                            throw Error('neo split not in middle');
                        }
                        return { value: [neoSplits_1[1], neoSplits_1[2]] };
                    }
                    else if (neoSplits_1.length !== 1) {
                        throw Error('invalid splits 1');
                    }
                    //todo add case
                    Object.keys(neoSplits_1[0]).forEach(function (key) {
                        // @ts-expect-error
                        split[key] = neoSplits_1[0][key];
                    });
                    return { value: [] };
                }
            }
            else {
                if (listIndex < split.indexStart || listIndex === split.indexEnd) {
                    addItemWithOrder(items, item, itemSortProperty);
                    return { value: [] };
                    // @ts-expect-error
                }
                else if (listIndex < split.indexEnd) {
                    addItemWithOrder(items, item, itemSortProperty);
                    var lastItem = split.items[split.items.length - 1];
                    var endIndex = items.indexOf(lastItem);
                    var neoSplits_2 = this_2.getMeshSplits(items, items.indexOf(split.items[0]), endIndex);
                    Object.keys(neoSplits_2[0]).forEach(function (key) {
                        // @ts-expect-error
                        split[key] = neoSplits_2[0][key];
                    });
                    if (neoSplits_2.length === 2) {
                        splits.splice(i + 1, 0, neoSplits_2[1]);
                        return { value: [neoSplits_2[1]] };
                    }
                    else if (neoSplits_2.length !== 1) {
                        throw Error('invalid splits 2');
                    }
                }
            }
        };
        var this_2 = this;
        /**
         * 插入 item 到合适的 meshSplit 上
         * 对图层元素：
         *   1. 存在 item.listIndex < split.indexEnd 的 meshSplit，判断加入 item 后是否需要添加 meshSplit，把新增的 meshSplit（1或2个）插入到到 meshSplits 中, 并更新原来 meshSplit 上的数据
         *   2. 添加 item 到 items 数组
         *   3. 再执行一次 item 添加到最后一张 meshSplit 的合并算法，判断是否新增 meshSplit 并更新对应数据
         * 对滤镜元素：
         *   1. 存在 item.listIndex === split.indexEnd 的 meshSplit，执行 item 添加到 items 数组
         *   2. 否则若存在 item.listIndex < split.indexEnd 的 meshSplit，判断加入 item 后是否需要添加 meshSplit，把新增的 meshSplit（1个）插入到到 meshSplits 中, 并更新原来 meshSplit 上的数据
         *
         */
        for (var i = 0; i < splits.length; i++) {
            var state_1 = _loop_2(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        addItemWithOrder(items, item, itemSortProperty);
        if (isSprite(item)) {
            var last_1 = splits[splits.length - 1];
            var neoSplits_3 = this.getMeshSplits(items, items.indexOf(last_1.items[0]), items.indexOf(item));
            Object.keys(neoSplits_3[0]).forEach(function (key) {
                // @ts-expect-error
                last_1[key] = neoSplits_3[0][key];
            });
            if (neoSplits_3.length === 2) {
                splits.push(neoSplits_3[1]);
                return [neoSplits_3[1]];
            }
            else if (neoSplits_3.length !== 1) {
                throw Error('invalid splits 3');
            }
        }
        return [];
    };
    /**
     * 从包含指定item的meshSplit、this.items中移除指定item
     * 并判断指定meshSplit能否与this.meshSplits中的其它meshSplit合并
     * 返回不需要的meshSplit(没有items/内容合并到其它meshSplit)
     */
    SpriteGroup.prototype.removeMeshSplitsItem = function (items, item, splits, itemsToRemove) {
        var targetSplit = null;
        var targetSplitIndex = -1;
        var ret = [];
        /**
         * 遍历this.meshSplits，找到元素的listIndex在split的indexStart和indexEnd范围内的第一个meshSplit
         */
        for (var i = 0; i < splits.length; i++) {
            var split = splits[i];
            // @ts-expect-error
            if (split.indexStart <= item.listIndex && split.indexEnd >= item.listIndex) {
                targetSplit = split;
                targetSplitIndex = i;
                break;
            }
        }
        if (targetSplit) {
            var index = targetSplit.items.indexOf(item);
            if (index < 0) {
                if (itemsToRemove === null || itemsToRemove === void 0 ? void 0 : itemsToRemove.includes(item)) {
                    //ignore removed
                    return [];
                }
                throw Error('item not found');
            }
            targetSplit.items.splice(index, 1);
            targetSplit.dirty = true;
            removeItem(items, item);
            /**
             * 如果找到的meshSplit中items为空 说明不需要这个meshSplit了
             * 把它从this.meshSplits中移除，并添加到返回的结果数组ret中
             * 如果meshSplit中还包含item，就把indexStart和indexEnd做对应修改
             */
            if (targetSplit.items.length === 0) {
                removeItem(splits, targetSplit);
                ret.push(targetSplit);
                targetSplitIndex = targetSplitIndex - 1;
                targetSplit = splits[targetSplitIndex];
                // this.meshSplits为空 不需要执行合并算法 直接返回
                if (!splits.length || targetSplitIndex < 0) {
                    return ret;
                }
            }
            else {
                targetSplit.indexEnd = targetSplit.items[targetSplit.items.length - 1].listIndex;
                targetSplit.indexStart = targetSplit.items[0].listIndex;
            }
            /**
             * 根据targetSplit(含有目标元素的meshSplit/ 它的前一个)在meshSplits数组中的位置，执行合并算法：
             * 如果是第一个或倒数第二个，与它后面一个判断能否执行合并
             * 如果最后一个，则判断能否和前一个合并
             * 不是上述位置,则和前后的meshSplit都需要判断能否合并
             * 如果两个meshSplit允许共用mesh 则合并
             */
            if (targetSplitIndex === 0 || targetSplitIndex === splits.length - 2) {
                // this.meshSplits中的最前两个或者最后两个meshSplit
                var p0 = splits[targetSplitIndex];
                var p1 = splits[targetSplitIndex + 1];
                if (p0 && p1) {
                    var i0 = p0.items[0];
                    var i1 = p1.items[p1.items.length - 1];
                    var meshes = this.getMeshSplits(items, items.indexOf(i0), items.indexOf(i1));
                    // 两个meshSplit可以合并成一个 把后者并入前一个meshSplit 共用前者的spriteMesh
                    if (meshes.length === 1) {
                        meshes[0].spriteMesh = splits[targetSplitIndex].spriteMesh;
                        splits[targetSplitIndex] = meshes[0];
                        ret.push(splits.splice(targetSplitIndex + 1, 1)[0]);
                    }
                }
            }
            else if (targetSplitIndex === splits.length - 1) {
                // 和前一个判断能否合并
                if (targetSplit.items.length === 0) {
                    ret.push(splits.splice(targetSplitIndex, 1)[0]);
                }
                else {
                    var p0 = splits[targetSplitIndex - 1];
                    var p1 = splits[targetSplitIndex];
                    var i0 = p0.items[0];
                    var i1 = p1.items[p1.items.length - 1];
                    var meshes = this.getMeshSplits(items, items.indexOf(i0), items.indexOf(i1));
                    if (meshes.length === 1) {
                        meshes[0].spriteMesh = splits[targetSplitIndex - 1].spriteMesh;
                        splits[targetSplitIndex - 1] = meshes[0];
                        ret.push(splits.splice(targetSplitIndex, 1)[0]);
                    }
                }
            }
            else {
                // 和前后都需要判断能否合并
                var p0 = splits[targetSplitIndex - 1];
                var p1 = splits[targetSplitIndex + 1];
                var i0 = p0.items[0];
                var i1 = p1.items[p1.items.length - 1];
                var meshes = this.getMeshSplits(items, items.indexOf(i0), items.indexOf(i1));
                if (meshes.length === 2) {
                    meshes[0].spriteMesh = splits[targetSplitIndex].spriteMesh;
                    meshes[1].spriteMesh = splits[targetSplitIndex + 1].spriteMesh;
                    splits[targetSplitIndex] = meshes[0];
                    splits[targetSplitIndex + 1] = meshes[1];
                    ret.push(splits.splice(targetSplitIndex - 1, 1)[0]);
                }
            }
        }
        return ret;
    };
    /**
     * 合并Mesh
     * 找到item所在的meshSplit 判断能否和前一张/后一张合并
     * 返回不需要的meshSplit(内容合并到其它meshSplit)
     */
    SpriteGroup.prototype.combineSplits = function (items, itemIndex, splits) {
        var item = items[itemIndex];
        var ret = [];
        // item.composition 不存在表示元素已经dispose
        if (isSprite(item) && item.composition) {
            // FIXME: 可选性
            var targetSplitIndex = void 0;
            for (var i = 0; i < splits.length; i++) {
                var split = splits[i];
                if (split.items.includes(item)) {
                    targetSplitIndex = i;
                    break;
                }
            }
            var p0 = void 0;
            var p1 = void 0;
            if (targetSplitIndex === 0) {
                p0 = splits[targetSplitIndex];
                p1 = splits[targetSplitIndex + 1];
            }
            else {
                p0 = splits[targetSplitIndex - 1];
                p1 = splits[targetSplitIndex];
            }
            if (p0 && p1) {
                var startIndex = items.indexOf(p0.items[0]);
                var endIndex = items.indexOf(p1.items[p1.items.length - 1]);
                if (Number.isInteger(startIndex) && Number.isInteger(endIndex)) {
                    var meshes = this.getMeshSplits(items, startIndex, endIndex);
                    if (meshes.length === 1) {
                        meshes[0].spriteMesh = splits[targetSplitIndex].spriteMesh;
                        if (targetSplitIndex === 0) {
                            splits[0] = meshes[0];
                            ret.push(splits.splice(1, 1)[0]);
                        }
                        else {
                            ret.push(splits.splice(targetSplitIndex - 1, 1)[0]);
                            splits[targetSplitIndex - 1] = meshes[0];
                        }
                    }
                }
            }
        }
        return ret;
    };
    /**
     *  判断items中[startIndex, endIndex]范围的元素需要多少个meshSplit
     *  item的filter、材质的显示面、蒙板、混合模式、顺序、深度遮挡等信息一致且在mesh容纳的范围内
     *  则放置到同一个meshSplit上，上述信息记录在cacheId中
     */
    SpriteGroup.prototype.getMeshSplits = function (items, startIndex, endIndex, init) {
        if (startIndex === void 0) { startIndex = 0; }
        if (endIndex === void 0) { endIndex = items.length - 1; }
        var current = null;
        var ret = [];
        for (var i = startIndex; i <= endIndex; i++) {
            var item = items[i];
            // 不可见的元素跳过 不参与合并
            if (!init && (!item.contentVisible || item.lifetime < 0)) {
                continue;
            }
            if (!isSprite(item)) {
                if (init && (!item.contentVisible)) {
                    continue;
                }
                if (current) {
                    ret.push(current);
                    current = null;
                }
            }
            else {
                var cacheId = item.createContent().renderInfo.cacheId;
                var texture = item.content.renderer.texture;
                var replaceCurrent = true;
                if (current) {
                    var texInc = current.textures.includes(texture) ? 0 : 1;
                    if (current.cacheId === cacheId &&
                        item.type === ItemType$1.sprite &&
                        current.items.length < exports.maxSpriteMeshItemCount &&
                        (texInc + current.textures.length) <= exports.maxSpriteTextureCount) {
                        addItemWithOrder(current.items, item, itemSortProperty);
                        addItem(current.textures, texture);
                        replaceCurrent = false;
                    }
                    else {
                        ret.push(current);
                    }
                }
                if (replaceCurrent) {
                    current = {
                        indexStart: item.listIndex,
                        cacheId: cacheId,
                        renderInfo: item.content.renderInfo,
                        items: [item],
                        textures: [texture],
                    };
                }
            }
        }
        if (current) {
            ret.push(current);
        }
        ret.forEach(function (split) {
            split.indexEnd = split.items[split.items.length - 1].listIndex;
            split.dirty = true;
        });
        return ret;
    };
    return SpriteGroup;
}());
function isSprite(item) {
    var type = item.type;
    return type === ItemType$1.sprite || type === ItemType$1.filter;
}

var defRenderInfo = {
    blending: 0,
    cacheId: '-',
    mask: 0,
    maskMode: 0,
    occlusion: false,
    side: 0,
    cachePrefix: '-',
};
var SpriteLoader = /** @class */ (function (_super) {
    __extends(SpriteLoader, _super);
    function SpriteLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'sprite';
        return _this;
    }
    SpriteLoader.precompile = function (compositions, shaderLibrary) {
        var _a;
        var _b = GPUCapability.getInstance(), level = _b.level, detail = _b.detail;
        if (!shaderLibrary.shaderResults[spriteMeshShaderIdFromRenderInfo(defRenderInfo, 2)]) {
            shaderLibrary.addShader(spriteMeshShaderFromRenderInfo(defRenderInfo, 2));
            shaderLibrary.addShader(spriteMeshShaderFromRenderInfo(defRenderInfo, exports.maxSpriteMeshItemCount));
            var hasFilter_1 = false;
            (_a = compositions[0]) === null || _a === void 0 ? void 0 : _a.items.forEach(function (item) {
                if (item.type === ItemType$1.filter && item.content.filter) {
                    hasFilter_1 = true;
                    var shaderDefs = createFilterShaders(item.content.filter);
                    shaderDefs.forEach(function (def) {
                        if (!def.isParticle) {
                            var shader = spriteMeshShaderFromFilter(def, def);
                            if (def.shaderCacheId) {
                                shader.cacheId = "".concat(def.shaderCacheId, "_mars_filter");
                            }
                            shaderLibrary.addShader(shader);
                        }
                    });
                }
            });
            if (hasFilter_1) {
                shaderLibrary.addShader(createCopyShader(level === 2, false));
            }
            if (detail.writableFragDepth) {
                shaderLibrary.addShader(createCopyShader(level === 2, true));
            }
        }
        return Promise.resolve();
    };
    SpriteLoader.prototype.spriteMeshShaderFromFilter = function (filter, options) {
        return spriteMeshShaderFromFilter(filter.mesh, options);
    };
    SpriteLoader.prototype.onCompositionDestroyed = function (composition) {
        var spriteGroup = composition.loaderData.spriteGroup;
        spriteGroup.dispose();
    };
    SpriteLoader.prototype.onCompositionReset = function (composition, pipeline) {
        var spriteGroup = new SpriteGroup({ calculateGroup: composition.calculateGroup });
        composition.loaderData.spriteGroup = spriteGroup;
        spriteGroup.resetMeshSplits();
    };
    SpriteLoader.prototype.onCompositionItemLifeBegin = function (composition, item) {
        var spriteGroup = composition.loaderData.spriteGroup;
        if (item.type !== ItemType$1.composition) {
            spriteGroup.addItem(item);
        }
    };
    SpriteLoader.prototype.onCompositionItemRemoved = function (composition, item) {
        var spriteGroup = composition.loaderData.spriteGroup;
        spriteGroup.removeItem(item);
    };
    SpriteLoader.prototype.onCompositionUpdate = function (composition, dt) {
        var spriteGroup = composition.loaderData.spriteGroup;
        spriteGroup.onUpdate(dt);
    };
    SpriteLoader.prototype.prepareRenderFrame = function (composition, renderFrame) {
        var _a, _b, _c;
        var spriteGroup = composition.loaderData.spriteGroup;
        var ret = spriteGroup.diffMeshSplits();
        if (ret) {
            (_a = ret.remove) === null || _a === void 0 ? void 0 : _a.forEach(function (mesh) { return renderFrame.removeMeshFromDefaultRenderPass(mesh); });
            (_b = ret.add) === null || _b === void 0 ? void 0 : _b.forEach(function (mesh) { return renderFrame.addMeshToDefaultRenderPass(mesh); });
            (_c = ret.modify) === null || _c === void 0 ? void 0 : _c.forEach(function (mesh) {
                // reset priority
                renderFrame.removeMeshFromDefaultRenderPass(mesh);
                renderFrame.addMeshToDefaultRenderPass(mesh);
            });
            return !!(this.layerInfo = ret.layer);
        }
        return false;
    };
    SpriteLoader.prototype.postProcessFrame = function (composition, pipeline) {
        var _a, _b;
        (_b = (_a = this.layerInfo) === null || _a === void 0 ? void 0 : _a.layerToAdd) === null || _b === void 0 ? void 0 : _b.forEach(function (layer) {
            var filterDefine = layer.items[0].filter;
            if (filterDefine !== undefined) {
                var options = filterDefine.passSplitOptions;
                var renderPass = pipeline.splitDefaultRenderPassByMesh(layer.mesh, options);
                // layer.mesh.material.setUniformSemantic('uSamplerPre', SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_0);
                if (filterDefine.renderPassDelegate) {
                    renderPass.delegate = filterDefine.renderPassDelegate;
                }
                if (filterDefine.onRenderPassCreated) {
                    filterDefine.onRenderPassCreated(renderPass, pipeline);
                }
            }
        });
        this.layerInfo = undefined;
    };
    return SpriteLoader;
}(AbstractPlugin));

var _a$6;
var singleSplits = [[0, 0, 1, 1]];
var tempRot$1 = [0, 0, 0];
var tempSize$1 = [1, 1, 1];
var tempColor = [1, 1, 1, 1];
var tempPos = [0, 0, 0];
var SpriteItem = /** @class */ (function () {
    // TODO: 类型
    function SpriteItem(props, opts, vfxItem) {
        var _a, _b;
        var _c = props.positionOverLifetime, positionOverLifetime = _c === void 0 ? {} : _c, interaction = props.interaction, renderer = props.renderer, options = props.options, _d = props.listIndex, listIndex = _d === void 0 ? 0 : _d;
        var emptyTexture = opts.emptyTexture;
        var transform = vfxItem.transform, duration = vfxItem.duration, endBehavior = vfxItem.endBehavior;
        var positionOverLifeTime = positionOverLifetime;
        var scale = transform.scale;
        this._transform = transform;
        this.positionOverLifeTime = positionOverLifeTime;
        this.options = {
            startSpeed: positionOverLifeTime.startSpeed || 0,
            startSize: scale && scale[0] || 1,
            sizeAspect: scale && (scale[0] / (scale[1] || 1)) || 1,
            startColor: options.startColor || [1, 1, 1, 1],
            duration: duration || 0,
            looping: endBehavior && endBehavior === ItemEndBehavior$1.loop,
            gravity: ensureVec3(positionOverLifeTime.gravity),
            // @ts-expect-error
            gravityModifier: positionOverLifeTime.gravityOverLifetime && createValueGetter(positionOverLifeTime.gravityOverLifetime),
            direction: positionOverLifeTime.direction ? vecNormalize([], positionOverLifeTime.direction) : ensureVec3(),
            endBehavior: endBehavior || END_BEHAVIOR_DESTROY$1,
        };
        var _e = renderer, _f = _e.renderMode, renderMode = _f === void 0 ? RenderMode$1.BILLBOARD : _f, _g = _e.blending, blending = _g === void 0 ? BlendingMode$1.ALPHA : _g, texture = _e.texture, occlusion = _e.occlusion, transparentOcclusion = _e.transparentOcclusion, _h = _e.side, side = _h === void 0 ? SideMode$1.DOUBLE : _h, shape = _e.shape, _j = _e.mask, mask = _j === void 0 ? 0 : _j, _k = _e.maskMode, maskMode = _k === void 0 ? 0 : _k, anchor = _e.anchor, particleOrigin = _e.particleOrigin;
        this.interaction = interaction;
        this.renderer = {
            renderMode: renderMode,
            blending: blending,
            texture: this.initTexture(texture, emptyTexture),
            occlusion: !!occlusion,
            transparentOcclusion: !!transparentOcclusion || maskMode === MaskMode$1.MASK,
            side: side,
            shape: shape,
            mask: mask,
            maskMode: maskMode,
            order: listIndex,
            anchor: anchor,
            particleOrigin: particleOrigin,
        };
        this.cache = {
            color: [1, 1, 1, 1],
            startSize: [scale[0], scale[1], scale[0]],
        };
        var colorOverLifetime = props.colorOverLifetime;
        if (colorOverLifetime) {
            // @ts-expect-error
            this.opacityOverLifetime = colorOverLifetime.opacity && createValueGetter(colorOverLifetime.opacity);
            if (colorOverLifetime.color && colorOverLifetime.color[0] === ValueType$1.GRADIENT_COLOR) {
                this.colorOverLifetime = colorStopsFromGradient(colorOverLifetime.color[1]);
            }
        }
        var sizeOverLifetime = props.sizeOverLifetime;
        if (sizeOverLifetime) {
            if (sizeOverLifetime.separateAxes) {
                this.sizeSeparateAxes = true;
                this.sizeXOverLifetime = createValueGetter(sizeOverLifetime.x || 1);
                this.sizeYOverLifetime = createValueGetter(sizeOverLifetime.y || 1);
                this.sizeZOverLifetime = createValueGetter(sizeOverLifetime.z || 1);
            }
            else {
                this.sizeXOverLifetime = createValueGetter(sizeOverLifetime.size || 1);
            }
        }
        var linearVelEnable = positionOverLifeTime.linearX || positionOverLifeTime.linearY || positionOverLifeTime.linearZ;
        if (linearVelEnable) {
            this.linearVelOverLifetime = {
                x: positionOverLifeTime.linearX && createValueGetter(positionOverLifeTime.linearX),
                y: positionOverLifeTime.linearY && createValueGetter(positionOverLifeTime.linearY),
                z: positionOverLifeTime.linearZ && createValueGetter(positionOverLifeTime.linearZ),
                asMovement: positionOverLifeTime.asMovement,
                enabled: !!linearVelEnable,
            };
        }
        var orbitalVelEnable = positionOverLifeTime.orbitalX || positionOverLifeTime.orbitalY || positionOverLifeTime.orbitalZ;
        if (orbitalVelEnable) {
            this.orbitalVelOverLifetime = {
                x: positionOverLifeTime.orbitalX && createValueGetter(positionOverLifeTime.orbitalX),
                y: positionOverLifeTime.orbitalY && createValueGetter(positionOverLifeTime.orbitalY),
                z: positionOverLifeTime.orbitalZ && createValueGetter(positionOverLifeTime.orbitalZ),
                center: ensureVec3(positionOverLifeTime.orbCenter),
                asRotation: positionOverLifeTime.asRotation,
                enabled: !!orbitalVelEnable,
            };
        }
        this.speedOverLifetime = positionOverLifeTime.speedOverLifetime && createValueGetter(positionOverLifeTime.speedOverLifetime);
        var rot = props.rotationOverLifetime;
        if (rot) {
            this.rotationOverLifetime = {
                asRotation: rot.asRotation,
                separateAxes: rot.separateAxes,
                z: createValueGetter(rot.z || 0),
            };
            if (rot.separateAxes) {
                var rotLt = this.rotationOverLifetime;
                rotLt.x = createValueGetter(rot.x || 0);
                rotLt.y = createValueGetter(rot.y || 0);
            }
        }
        if (((_a = props.filter) === null || _a === void 0 ? void 0 : _a.feather) && ((_b = props.filter) === null || _b === void 0 ? void 0 : _b.feather) !== 1) {
            this.feather = createValueGetter(props.filter.feather);
        }
        this.emptyTexture = emptyTexture;
        this._time = 0;
        this.maxTime = this.options.duration;
        this.gravityModifier = this.options.gravityModifier;
        this.splits = props.splits || singleSplits;
        this.listIndex = vfxItem.listIndex || 0;
        this.textureSheetAnimation = props.textureSheetAnimation;
        this.cachePrefix = '-';
        this.parentId = vfxItem.parentId;
        this.reusable = vfxItem.reusable;
        this.name = vfxItem.name;
        this._renderInfo = getImageItemRenderInfo(this);
        this.delay = vfxItem.delay || 0;
        this.visible = vfxItem.getVisible();
    }
    SpriteItem.prototype.fallbackAnchor = function () {
        if (!this.anchor) {
            var renderer = this.renderer;
            // 2d coord, x ->left y->down
            var anchor = renderer.anchor;
            var setOffset = true;
            if (!anchor && renderer.particleOrigin) {
                anchor = convertParticleOrigin2Anchor(renderer.particleOrigin);
                setOffset = false;
            }
            anchor = anchor || [0.5, 0.5];
            var rotation = deepClone(this._transform.rotation);
            var position = deepClone(this._transform.position);
            var transformPath = this.positionOverLifeTime.path;
            var path = void 0;
            if (transformPath) {
                if (transformPath[0] === ValueType$1.CONSTANT_VEC3) {
                    vecAdd(position, position, transformPath[1]);
                }
                else {
                    path = createValueGetter(transformPath);
                }
            }
            this.transform = {
                position: position,
                rotation: rotation,
                path: path,
            };
            this.anchor = anchor ? [anchor[0] - 0.5, 0.5 - anchor[1]] : [0, 0];
            if (setOffset) {
                var offset = getAnchorOffset(this.anchor, this._transform);
                position[0] += offset[0];
                position[1] += offset[1];
            }
        }
        return this.anchor;
    };
    Object.defineProperty(SpriteItem.prototype, "filter", {
        get: function () {
            // @ts-expect-error
            return this._filter;
        },
        set: function (f) {
            this._filter = f;
            this._renderInfo.filter = f;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteItem.prototype, "renderInfo", {
        get: function () {
            return this._renderInfo;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteItem.prototype, "ended", {
        get: function () {
            return this._time > this.maxTime && !this.options.looping && !this.reusable;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteItem.prototype, "time", {
        get: function () {
            return this._time;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteItem.prototype, "velocity", {
        get: function () {
            if (!this._velocity) {
                this._velocity = vecMulScalar([], this.options.direction, this.options.startSpeed);
            }
            return this._velocity;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteItem.prototype, "startSize", {
        get: function () {
            return this.cache.startSize;
        },
        enumerable: false,
        configurable: true
    });
    SpriteItem.prototype.initTexture = function (texture, emptyTexture) {
        var tex = texture !== null && texture !== void 0 ? texture : emptyTexture;
        return tex;
    };
    SpriteItem.prototype.willTranslate = function () {
        var pro = '_willTranslate';
        // eslint-disable-next-line no-prototype-builtins
        if (!this.hasOwnProperty(pro)) {
            var linearVel = this.linearVelOverLifetime;
            if (linearVel && linearVel.enabled) {
                // @ts-expect-error
                return this[pro] = true;
            }
            var orbitalVelOverLifetime = this.orbitalVelOverLifetime;
            if (orbitalVelOverLifetime && orbitalVelOverLifetime.enabled) {
                // @ts-expect-error
                return this[pro] = true;
            }
            var options = this.options;
            if ((options.gravityModifier && !isZeroVec(options.gravity)) ||
                (options.startSpeed && !isZeroVec(options.direction))) {
                // @ts-expect-error
                return this[pro] = true;
            }
            // @ts-expect-error
            return this[pro] = false;
        }
        // @ts-expect-error
        return this[pro];
    };
    SpriteItem.prototype.updateTime = function (globalTime) {
        var time = globalTime - this.delay;
        var duration = this.options.duration;
        if (time >= this.maxTime && this.options.looping) {
            var start = time - this.maxTime;
            while (start > duration) {
                start -= duration;
            }
            this._time = start;
        }
        else {
            var freeze = this.options.endBehavior === END_BEHAVIOR_FREEZE$1;
            this._time = freeze ? Math.min(this.maxTime, time) : time;
        }
    };
    // stop () {
    //   this._time = this.maxTime;
    // }
    SpriteItem.prototype.getTextures = function () {
        var ret = [];
        var tex = this.renderer.texture;
        if (tex) {
            ret.push(tex);
        }
        return ret;
    };
    SpriteItem.prototype.getRenderData = function (_time, init) {
        var options = this.options;
        var sizeInc = vecFill(tempSize$1, 1);
        var rotInc = vecFill(tempRot$1, 0);
        var colorInc = vecFill(tempColor, 1);
        var sizeChanged, rotChanged, colorChanged;
        var time = _time < 0 ? _time : Math.max(_time, 0.);
        var duration = options.duration;
        var life = time / duration;
        this.fallbackAnchor();
        var ret = {
            life: life,
            transform: this._transform,
            anchor: this.anchor,
        };
        var transform = this.transform;
        life = life < 0 ? 0 : (life > 1 ? 1 : life);
        if (this.sizeXOverLifetime) {
            sizeInc[0] = this.sizeXOverLifetime.getValue(life);
            if (this.sizeSeparateAxes) {
                sizeInc[1] = this.sizeYOverLifetime.getValue(life);
                sizeInc[2] = this.sizeZOverLifetime.getValue(life);
            }
            else {
                sizeInc[2] = sizeInc[1] = sizeInc[0];
            }
            sizeChanged = true;
        }
        if (sizeChanged || init) {
            ret.transform.setScale(sizeInc[0], sizeInc[1], sizeInc[2]);
        }
        ret.startSize = this.cache.startSize;
        var rotationOverLifetime = this.rotationOverLifetime;
        if (rotationOverLifetime) {
            var func = function (v) { return rotationOverLifetime.asRotation ? v.getValue(life) : v.getIntegrateValue(0, life, duration); };
            var incZ = func(rotationOverLifetime.z);
            var separateAxes = rotationOverLifetime.separateAxes;
            rotInc[0] = separateAxes ? func(rotationOverLifetime.x) : 0;
            rotInc[1] = separateAxes ? func(rotationOverLifetime.y) : 0;
            rotInc[2] = incZ;
            rotChanged = true;
        }
        if (rotChanged || init) {
            var rot = vecAdd(tempRot$1, transform.rotation, rotInc);
            ret.transform.setRotation(rot[0], rot[1], rot[2]);
        }
        var opacityOverLifetime = this.opacityOverLifetime;
        var colorOverLifetime = this.colorOverLifetime;
        if (colorOverLifetime) {
            colorInc = getColorFromGradientStops(colorOverLifetime, life, true);
            colorChanged = true;
        }
        if (opacityOverLifetime) {
            colorInc[3] *= opacityOverLifetime.getValue(life);
            colorChanged = true;
        }
        if (colorChanged || init) {
            ret.color = vecMulCombine(this.cache.color, colorInc, options.startColor);
        }
        var pos;
        if (this.willTranslate() || init) {
            var out = vecFill(tempSize$1, 0);
            pos = calculateTranslation(out, this, options.gravity, time, duration, transform.position, this.velocity);
        }
        if (transform.path) {
            if (!pos) {
                pos = vecAssign(tempPos, transform.position, 3);
            }
            vecAdd(pos, pos, transform.path.getValue(life));
        }
        if (pos) {
            ret.transform.setPosition(pos[0], pos[1], pos[2]);
        }
        var ta = this.textureSheetAnimation;
        if (ta) {
            var total = ta.total || (ta.row * ta.col);
            var texRectX = 0;
            var texRectY = 0;
            var texRectW = 1;
            var texRectH = 1;
            var flip = void 0;
            if (this.splits) {
                var sp = this.splits[0];
                flip = sp[4];
                texRectX = sp[0];
                texRectY = sp[1];
                if (flip) {
                    texRectW = sp[3];
                    texRectH = sp[2];
                }
                else {
                    texRectW = sp[2];
                    texRectH = sp[3];
                }
            }
            var dx = void 0, dy = void 0;
            if (flip) {
                dx = 1 / ta.row * texRectW;
                dy = 1 / ta.col * texRectH;
            }
            else {
                dx = 1 / ta.col * texRectW;
                dy = 1 / ta.row * texRectH;
            }
            var texOffset = void 0;
            if (ta.animate) {
                var frameIndex = Math.round(life * (total - 1));
                var yIndex = Math.floor(frameIndex / ta.col);
                var xIndex = frameIndex - yIndex * ta.col;
                texOffset = flip ? [dx * yIndex, dy * (ta.col - xIndex)] : [dx * xIndex, dy * (1 + yIndex)];
            }
            else {
                texOffset = [0, dy];
            }
            ret.texOffset = [
                texRectX + texOffset[0],
                texRectH + texRectY - texOffset[1],
                dx, dy,
            ];
        }
        else if (init) {
            ret.texOffset = [0, 0, 1, 1];
        }
        ret.visible = this.visible;
        return ret;
    };
    return SpriteItem;
}());
function convertParticleOrigin2Anchor(p) {
    var point = ParticleOriginTranslateMap[p || ParticleOrigin$1.PARTICLE_ORIGIN_CENTER];
    return [
        0.5 - point[0],
        point[1] + 0.5,
    ];
}
function getAnchorOffset(anchor, transform) {
    var scale = transform.scale;
    return [
        anchor[0] * scale[0],
        anchor[1] * scale[1],
    ];
}
var ParticleOriginTranslateMap = (_a$6 = {},
    _a$6[ParticleOrigin$1.PARTICLE_ORIGIN_CENTER] = [0, 0],
    _a$6[ParticleOrigin$1.PARTICLE_ORIGIN_CENTER_BOTTOM] = [0, 0.5],
    _a$6[ParticleOrigin$1.PARTICLE_ORIGIN_CENTER_TOP] = [0, -0.5],
    _a$6[ParticleOrigin$1.PARTICLE_ORIGIN_LEFT_TOP] = [0.5, -0.5],
    _a$6[ParticleOrigin$1.PARTICLE_ORIGIN_LEFT_CENTER] = [0.5, 0],
    _a$6[ParticleOrigin$1.PARTICLE_ORIGIN_LEFT_BOTTOM] = [0.5, 0.5],
    _a$6[ParticleOrigin$1.PARTICLE_ORIGIN_RIGHT_CENTER] = [-0.5, 0],
    _a$6[ParticleOrigin$1.PARTICLE_ORIGIN_RIGHT_BOTTOM] = [-0.5, 0.5],
    _a$6[ParticleOrigin$1.PARTICLE_ORIGIN_RIGHT_TOP] = [-0.5, -0.5],
    _a$6);

var SpriteVFXItem = /** @class */ (function (_super) {
    __extends(SpriteVFXItem, _super);
    function SpriteVFXItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(SpriteVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.sprite;
        },
        enumerable: false,
        configurable: true
    });
    SpriteVFXItem.prototype.onConstructed = function (props) {
        this.sprite = props.content;
    };
    SpriteVFXItem.prototype.onLifetimeBegin = function (composition, content) {
        this._contentVisible = true;
    };
    SpriteVFXItem.prototype.onItemRemoved = function (composition, content) {
        this._contentVisible = false;
        if (content) {
            delete content.mesh;
            composition.destroyTextures(content.getTextures());
        }
    };
    SpriteVFXItem.prototype.handleVisibleChanged = function (visible) {
        if (this.content) {
            this.content.visible = visible;
        }
    };
    SpriteVFXItem.prototype.getCurrentPosition = function () {
        var pos = [0, 0, 0];
        this.transform.assignWorldTRS(pos);
        return pos;
    };
    SpriteVFXItem.prototype.getHitTestParams = function (force) {
        var _a;
        var item = this.content;
        var ig = this.composition.loaderData.spriteGroup;
        var ui = item && item.interaction;
        if ((force || ui) && item && ig) {
            var mesh = ig.getSpriteMesh(item);
            if (!mesh) {
                return;
            }
            // const renderData = this.getCurrentRenderData();
            var renderData = mesh.getItemRegionData(item);
            if (renderData) {
                var originalPos_1 = [0, 0, 0];
                var position = renderData.position, quat_1 = renderData.quat, scale = renderData.size;
                var startSize = this.content.startSize;
                var anchor = this.content.anchor || [0, 0];
                // position: anchor * startSize + original position + otherTransform
                // anchor改变自身缩放/旋转点 父节点transform应用于整体
                vecMinus(originalPos_1, position, [anchor[0] * startSize[0], anchor[1] * startSize[1], 0]);
                var hw = startSize[0] * scale[0] / 2, hh = startSize[1] * scale[1] / 2;
                var aw_1 = anchor[0] * startSize[0], ah_1 = anchor[1] * startSize[1];
                var triangles = trianglesFromRect([-aw_1 * scale[0], -ah_1 * scale[1], 0], hw, hh);
                triangles.forEach(function (triangle) {
                    triangle.forEach(function (p) {
                        rotateByQuat(p, p, quat_1);
                        vecAdd(p, p, [aw_1 + originalPos_1[0], ah_1 + originalPos_1[1], originalPos_1[2]]);
                    });
                });
                return {
                    behavior: ((_a = item.interaction) === null || _a === void 0 ? void 0 : _a.behavior) || 0,
                    type: exports.HitTestType.triangle,
                    triangles: triangles,
                    backfaceCulling: item.renderer.side === SideMode$1.FRONT,
                };
            }
            else {
                console.error("Can not get SpriteVFXItem ".concat(this.name, "'s renderer data"));
                return;
            }
        }
    };
    SpriteVFXItem.prototype.doCreateContent = function (composition) {
        var emptyTexture = composition.getRendererOptions().emptyTexture;
        return new SpriteItem(this.sprite, { emptyTexture: emptyTexture }, this);
    };
    return SpriteVFXItem;
}(VFXItem));

var seed$6 = 1;
var FilterSpriteVFXItem = /** @class */ (function (_super) {
    __extends(FilterSpriteVFXItem, _super);
    function FilterSpriteVFXItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(FilterSpriteVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.filter;
        },
        enumerable: false,
        configurable: true
    });
    FilterSpriteVFXItem.prototype.onConstructed = function (props) {
        _super.prototype.onConstructed.call(this, props);
        this.filterOptions = props.content.filter;
        this.cachePrefix = 'filter:' + seed$6++;
        // @ts-expect-error
        this.sprite.renderer.texture = this.composition.renderFrame.transparentTexture;
    };
    FilterSpriteVFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        var e_1, _a;
        var _b, _c, _d;
        _super.prototype.onItemUpdate.call(this, dt, lifetime);
        var mesh = (_b = this._content) === null || _b === void 0 ? void 0 : _b.mesh;
        if (mesh) {
            var variables = this.filter.mesh.variables;
            if (variables) {
                var material = mesh.mesh.material;
                try {
                    // TODO 考虑其他的variable类型
                    for (var _e = __values$1(Object.keys(variables)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var key = _f.value;
                        var value = variables[key](lifetime);
                        if (value.length > 4) {
                            material.setMatrix(key, value);
                        }
                        else {
                            material.setVector4(key, value);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
        (_d = (_c = this.filter).onItemUpdate) === null || _d === void 0 ? void 0 : _d.call(_c, dt, this);
    };
    FilterSpriteVFXItem.prototype.onItemRemoved = function (composition, content) {
        var _a, _b;
        (_b = (_a = this.filter).onItemRemoved) === null || _b === void 0 ? void 0 : _b.call(_a, this);
        _super.prototype.onItemRemoved.call(this, composition, content);
    };
    FilterSpriteVFXItem.prototype.doCreateContent = function (composition) {
        var _a;
        var spriteItem = _super.prototype.doCreateContent.call(this, composition);
        var filter = createFilter(this.filterOptions, composition);
        this.filter = filter;
        spriteItem.renderInfo.filter = filter;
        spriteItem.filter = filter;
        spriteItem.renderInfo.cacheId = spriteItem.renderInfo.cacheId.replace('$F$', (_a = filter.mesh.shaderCacheId) !== null && _a !== void 0 ? _a : '');
        var variables = filter.mesh.variables;
        if (!filter.mesh.uniformValues) {
            filter.mesh.uniformValues = {};
        }
        if (variables) {
            Object.keys(variables).forEach(function (uniformName) {
                var func = variables[uniformName];
                filter.mesh.uniformValues[uniformName] = func(0);
            });
        }
        return spriteItem;
    };
    return FilterSpriteVFXItem;
}(SpriteVFXItem));

var ParticleMesh = /** @class */ (function () {
    function ParticleMesh(props, rendererOptions) {
        var _a, _b, _c;
        this.particleCount = 0;
        var speedOverLifetime = props.speedOverLifetime, colorOverLifetime = props.colorOverLifetime, linearVelOverLifetime = props.linearVelOverLifetime, orbitalVelOverLifetime = props.orbitalVelOverLifetime, sizeOverLifetime = props.sizeOverLifetime, rotationOverLifetime = props.rotationOverLifetime, sprite = props.sprite, renderFrame = props.renderFrame, gravityModifier = props.gravityModifier, maxCount = props.maxCount, duration = props.duration, textureFlip = props.textureFlip, useSprite = props.useSprite, name = props.name, filter = props.filter, gravity = props.gravity, forceTarget = props.forceTarget; props.shaderCachePrefix; var side = props.side, occlusion = props.occlusion, anchor = props.anchor, blending = props.blending, maskMode = props.maskMode, mask = props.mask, transparentOcclusion = props.transparentOcclusion, listIndex = props.listIndex, meshSlots = props.meshSlots, _d = props.renderMode, renderMode = _d === void 0 ? 0 : _d, _e = props.matrix, matrix = _e === void 0 ? mat4create() : _e, _f = props.diffuse, diffuse = _f === void 0 ? Texture.createWithData() : _f;
        var detail = GPUCapability.getInstance().detail;
        var halfFloatTexture = detail.halfFloatTexture, maxVertexUniforms = detail.maxVertexUniforms;
        var marcos = [
            ['RENDER_MODE', +renderMode],
            ['PRE_MULTIPLY_ALPHA', false],
            ['ENV_EDITOR', getConfig(RUNTIME_ENV) === PLAYER_OPTIONS_ENV_EDITOR],
        ];
        var level = GPUCapability.getInstance().level;
        var vertexKeyFrameMeta = createKeyFrameMeta();
        var fragmentKeyFrameMeta = createKeyFrameMeta();
        var enableVertexTexture = maxVertexUniforms > 0;
        var uniformValues = {};
        var vertex_lookup_texture = 0;
        var shaderCacheId = 0;
        var particleDefine;
        var useOrbitalVel;
        this.useSprite = useSprite;
        if (enableVertexTexture) {
            marcos.push(['ENABLE_VERTEX_TEXTURE', true]);
        }
        if (speedOverLifetime) {
            marcos.push(['SPEED_OVER_LIFETIME', true]);
            shaderCacheId |= 1 << 1;
            uniformValues.uSpeedLifetimeValue = speedOverLifetime.toUniform(vertexKeyFrameMeta);
        }
        this.renderFrame = renderFrame;
        if (sprite === null || sprite === void 0 ? void 0 : sprite.animate) {
            marcos.push(['USE_SPRITE', true]);
            shaderCacheId |= 1 << 2;
            uniformValues.uFSprite = uniformValues.uSprite = new Float32Array([sprite.col, sprite.row, sprite.total, sprite.blend ? 1 : 0]);
            this.useSprite = true;
        }
        if (filter && filter.name !== FILTER_NAME_NONE) {
            marcos.push(['USE_FILTER', true]);
            shaderCacheId |= 1 << 3;
            var filterDefine = createFilter(filter, rendererOptions.composition);
            if (!filterDefine.particle) {
                throw new Error("particle filter ".concat(filter.name, " not implement"));
            }
            particleDefine = filterDefine.particle;
            Object.keys((_a = particleDefine.uniforms) !== null && _a !== void 0 ? _a : {}).forEach(function (uName) {
                var _a;
                var getter = (_a = particleDefine.uniforms) === null || _a === void 0 ? void 0 : _a[uName];
                if (uniformValues[uName]) {
                    throw new Error('conflict uniform name:' + uName);
                }
                uniformValues[uName] = getter === null || getter === void 0 ? void 0 : getter.toUniform(vertexKeyFrameMeta);
            });
            Object.keys((_b = particleDefine.uniformValues) !== null && _b !== void 0 ? _b : {}).forEach(function (uName) {
                var _a;
                var val = (_a = particleDefine.uniformValues) === null || _a === void 0 ? void 0 : _a[uName];
                if (uniformValues[uName]) {
                    throw new Error('conflict uniform name:' + uName);
                }
                uniformValues[uName] = val;
            });
        }
        if (colorOverLifetime === null || colorOverLifetime === void 0 ? void 0 : colorOverLifetime.color) {
            marcos.push(['COLOR_OVER_LIFETIME', true]);
            shaderCacheId |= 1 << 4;
            uniformValues.uColorOverLifetime = colorOverLifetime.color instanceof Texture ? colorOverLifetime.color : Texture.createWithData(imageDataFromGradient(colorOverLifetime.color));
        }
        if (colorOverLifetime === null || colorOverLifetime === void 0 ? void 0 : colorOverLifetime.opacity) {
            uniformValues.uOpacityOverLifetimeValue = colorOverLifetime.opacity.toUniform(vertexKeyFrameMeta);
        }
        else {
            uniformValues.uOpacityOverLifetimeValue = createValueGetter(1).toUniform(vertexKeyFrameMeta);
        }
        ['x', 'y', 'z'].forEach(function (pro, i) {
            var defL = 0;
            var defO = 0;
            if (linearVelOverLifetime === null || linearVelOverLifetime === void 0 ? void 0 : linearVelOverLifetime[pro]) {
                uniformValues["uLinear".concat(pro.toUpperCase(), "ByLifetimeValue")] = linearVelOverLifetime[pro].toUniform(vertexKeyFrameMeta);
                defL = 1;
                shaderCacheId |= 1 << (7 + i);
                linearVelOverLifetime.enabled = true;
            }
            marcos.push(["LINEAR_VEL_".concat(pro.toUpperCase()), defL]);
            if (orbitalVelOverLifetime === null || orbitalVelOverLifetime === void 0 ? void 0 : orbitalVelOverLifetime[pro]) {
                uniformValues["uOrb".concat(pro.toUpperCase(), "ByLifetimeValue")] = orbitalVelOverLifetime[pro].toUniform(vertexKeyFrameMeta);
                defO = 1;
                shaderCacheId |= 1 << (10 + i);
                useOrbitalVel = true;
                orbitalVelOverLifetime.enabled = true;
            }
            marcos.push(["ORB_VEL_".concat(pro.toUpperCase()), defO]);
        });
        if (linearVelOverLifetime === null || linearVelOverLifetime === void 0 ? void 0 : linearVelOverLifetime.asMovement) {
            marcos.push(['AS_LINEAR_MOVEMENT', true]);
            shaderCacheId |= 1 << 5;
        }
        if (useOrbitalVel) {
            if (orbitalVelOverLifetime === null || orbitalVelOverLifetime === void 0 ? void 0 : orbitalVelOverLifetime.asRotation) {
                marcos.push(['AS_ORBITAL_MOVEMENT', true]);
                shaderCacheId |= 1 << 6;
            }
            uniformValues.uOrbCenter = new Float32Array((orbitalVelOverLifetime === null || orbitalVelOverLifetime === void 0 ? void 0 : orbitalVelOverLifetime.center) || [0, 0, 0]);
        }
        uniformValues.uSizeByLifetimeValue = sizeOverLifetime === null || sizeOverLifetime === void 0 ? void 0 : sizeOverLifetime.x.toUniform(vertexKeyFrameMeta);
        if (sizeOverLifetime === null || sizeOverLifetime === void 0 ? void 0 : sizeOverLifetime.separateAxes) {
            marcos.push(['SIZE_Y_BY_LIFE', 1]);
            shaderCacheId |= 1 << 14;
            uniformValues.uSizeYByLifetimeValue = (_c = sizeOverLifetime === null || sizeOverLifetime === void 0 ? void 0 : sizeOverLifetime.y) === null || _c === void 0 ? void 0 : _c.toUniform(vertexKeyFrameMeta);
        }
        if (rotationOverLifetime === null || rotationOverLifetime === void 0 ? void 0 : rotationOverLifetime.z) {
            uniformValues.uRZByLifeTimeValue = rotationOverLifetime.z.toUniform(vertexKeyFrameMeta);
            shaderCacheId |= 1 << 15;
            marcos.push(['ROT_Z_LIFETIME', 1]);
        }
        if (rotationOverLifetime === null || rotationOverLifetime === void 0 ? void 0 : rotationOverLifetime.x) {
            uniformValues.uRXByLifeTimeValue = rotationOverLifetime.x.toUniform(vertexKeyFrameMeta);
            shaderCacheId |= 1 << 16;
            marcos.push(['ROT_X_LIFETIME', 1]);
        }
        if (rotationOverLifetime === null || rotationOverLifetime === void 0 ? void 0 : rotationOverLifetime.y) {
            uniformValues.uRYByLifeTimeValue = rotationOverLifetime.y.toUniform(vertexKeyFrameMeta);
            shaderCacheId |= 1 << 17;
            marcos.push(['ROT_Y_LIFETIME', 1]);
        }
        if (rotationOverLifetime === null || rotationOverLifetime === void 0 ? void 0 : rotationOverLifetime.asRotation) {
            marcos.push(['ROT_LIFETIME_AS_MOVEMENT', 1]);
            shaderCacheId |= 1 << 18;
        }
        uniformValues.uGravityModifierValue = gravityModifier.toUniform(vertexKeyFrameMeta);
        if (forceTarget) {
            marcos.push(['FINAL_TARGET', true]);
            shaderCacheId |= 1 << 19;
            uniformValues.uFinalTarget = new Float32Array(forceTarget.target || [0, 0, 0]);
            uniformValues.uForceCurve = forceTarget.curve.toUniform(vertexKeyFrameMeta);
        }
        if (halfFloatTexture && fragmentKeyFrameMeta.max) {
            shaderCacheId |= 1 << 20;
            uniformValues.uFCurveValueTexture = generateHalfFloatTexture(CurveValue.getAllData(fragmentKeyFrameMeta, true), fragmentKeyFrameMeta.index, 1);
        }
        else {
            uniformValues.uFCurveValues = CurveValue.getAllData(fragmentKeyFrameMeta);
        }
        var vertexCurveTexture = vertexKeyFrameMeta.max + vertexKeyFrameMeta.curves.length - 32 > maxVertexUniforms;
        // if (getConfig(RENDER_PREFER_LOOKUP_TEXTURE)) {
        //   vertexCurveTexture = true;
        // }
        if (level === 2) {
            vertexKeyFrameMeta.max = -1;
            vertexKeyFrameMeta.index = meshSlots ? meshSlots[0] : getSlot(vertexKeyFrameMeta.index);
            if (fragmentKeyFrameMeta.index > 0) {
                fragmentKeyFrameMeta.max = -1;
                fragmentKeyFrameMeta.index = meshSlots ? meshSlots[1] : getSlot(fragmentKeyFrameMeta.index);
            }
        }
        if (vertexCurveTexture && halfFloatTexture && enableVertexTexture) {
            var tex = generateHalfFloatTexture(CurveValue.getAllData(vertexKeyFrameMeta, true), vertexKeyFrameMeta.index, 1);
            uniformValues.uVCurveValueTexture = tex;
            vertex_lookup_texture = 1;
        }
        else {
            uniformValues.uVCurveValues = CurveValue.getAllData(vertexKeyFrameMeta);
        }
        var shaderCache = ['-p:', renderMode, shaderCacheId, vertexKeyFrameMeta.index, vertexKeyFrameMeta.max, fragmentKeyFrameMeta.index, fragmentKeyFrameMeta.max].join('+');
        marcos.push(['VERT_CURVE_VALUE_COUNT', vertexKeyFrameMeta.index], ['FRAG_CURVE_VALUE_COUNT', fragmentKeyFrameMeta.index], ['VERT_MAX_KEY_FRAME_COUNT', vertexKeyFrameMeta.max], ['FRAG_MAX_KEY_FRAME_COUNT', fragmentKeyFrameMeta.max]);
        var fragment = filter ? particleFrag.replace(/#pragma\s+FILTER_FRAG/, particleDefine.fragment) : particleFrag;
        var originalVertex = "#define LOOKUP_TEXTURE_CURVE ".concat(vertex_lookup_texture, "\n").concat(particleVert);
        var vertex = filter ? originalVertex.replace(/#pragma\s+FILTER_VERT/, particleDefine.vertex || 'void filterMain(float t){}\n') : originalVertex;
        var shader = {
            fragment: createShaderWithMarcos(marcos, fragment, exports.ShaderType.fragment),
            vertex: createShaderWithMarcos(marcos, vertex, exports.ShaderType.vertex),
            glslVersion: level === 1 ? exports.GLSLVersion.GLSL1 : exports.GLSLVersion.GLSL3,
            shared: true,
            cacheId: shaderCache,
            marcos: marcos,
            name: "particle#".concat(name),
        };
        if (filter) {
            shader.cacheId += filter.name;
        }
        var mtlOptions = {
            shader: shader,
            uniformSemantics: {
                mars_MatrixV: 'VIEW',
                mars_MatrixVP: 'VIEWPROJECTION',
                uEditorTransform: 'EDITOR_TRANSFORM',
                mars_ObjectToWorld: 'MODEL',
            },
        };
        var preMulAlpha = getPreMultiAlpha(blending);
        uniformValues.uTexOffset = new Float32Array(diffuse ? [1 / diffuse.getWidth(), 1 / diffuse.getHeight()] : [0, 0]);
        uniformValues.uMaskTex = diffuse;
        uniformValues.uColorParams = new Float32Array([diffuse ? 1 : 0, +preMulAlpha, 0, +(!!occlusion && !transparentOcclusion)]);
        uniformValues.uParams = [0, duration, 0, 0];
        uniformValues.uAcceleration = [(gravity === null || gravity === void 0 ? void 0 : gravity[0]) || 0, (gravity === null || gravity === void 0 ? void 0 : gravity[1]) || 0, (gravity === null || gravity === void 0 ? void 0 : gravity[2]) || 0, 0];
        // mtlOptions.uniformValues = uniformValues;
        var material = Material.create(mtlOptions);
        material.blending = true;
        material.depthTest = true;
        material.depthMask = !!(occlusion);
        material.stencilRef = mask ? [mask, mask] : undefined;
        setMaskMode(material, maskMode);
        setBlendMode(material, blending);
        setSideMode(material, side);
        var typeMap = {
            'uSprite': 'vec4',
            'uParams': 'vec4',
            'uAcceleration': 'vec4',
            'uGravityModifierValue': 'vec4',
            'uOpacityOverLifetimeValue': 'vec4',
            'uRXByLifeTimeValue': 'vec4',
            'uRYByLifeTimeValue': 'vec4',
            'uRZByLifeTimeValue': 'vec4',
            'uLinearXByLifetimeValue': 'vec4',
            'uLinearYByLifetimeValue': 'vec4',
            'uLinearZByLifetimeValue': 'vec4',
            'uSpeedLifetimeValue': 'vec4',
            'uOrbXByLifetimeValue': 'vec4',
            'uOrbYByLifetimeValue': 'vec4',
            'uOrbZByLifetimeValue': 'vec4',
            'uSizeByLifetimeValue': 'vec4',
            'uSizeYByLifetimeValue': 'vec4',
            'uColorParams': 'vec4',
            'uFSprite': 'vec4',
            'uPreviewColor': 'vec4',
            'uVCurveValues': 'vec4Array',
            'uFCurveValues': 'vec4',
            'uFinalTarget': 'vec3',
            'uForceCurve': 'vec3',
            'uOrbCenter': 'vec3',
            'uTexOffset': 'vec2',
            'uPeriodValue': 'vec4',
            'uMovementValue': 'vec4',
            'uStrengthValue': 'vec4',
            'uWaveParams': 'vec4',
        };
        Object.keys(uniformValues).map(function (name) {
            var value = uniformValues[name];
            if (value instanceof Texture) {
                material.setTexture(name, value);
                return;
            }
            var res = [];
            switch (typeMap[name]) {
                case 'vec4':
                    material.setVector4(name, value);
                    break;
                case 'vec3':
                    material.setVector3(name, value);
                    break;
                case 'vec2':
                    material.setVector2(name, value);
                    break;
                case 'vec4Array':
                    for (var i = 0; i < value.length; i = i + 4) {
                        var v = [value[i], value[i + 1], value[i + 2], value[i + 3]];
                        res.push(v);
                    }
                    material.setVector4Array(name, res);
                    res.length = 0;
                    break;
                default:
                    console.warn("uniform ".concat(name, "'s type not in typeMap"));
            }
        });
        var geometry = Geometry.create(generateGeometryProps(maxCount * 4, this.useSprite, "particle#".concat(name)));
        var mesh = Mesh.create({
            name: "MParticle_".concat(name),
            priority: listIndex,
            material: material,
            geometry: geometry,
        });
        this.anchor = anchor ? [anchor[0] - 0.5, 0.5 - anchor[1]] : [0, 0];
        this.mesh = mesh;
        this.geometry = mesh.firstGeometry();
        this.forceTarget = forceTarget;
        this.sizeOverLifetime = sizeOverLifetime;
        this.speedOverLifetime = speedOverLifetime;
        this.linearVelOverLifetime = linearVelOverLifetime;
        this.orbitalVelOverLifetime = orbitalVelOverLifetime;
        this.orbitalVelOverLifetime = orbitalVelOverLifetime;
        this.gravityModifier = gravityModifier;
        this.maxCount = maxCount;
        this.duration = duration;
        this.emitterMatrix = matrix;
        this.textureOffsets = textureFlip ? [0, 0, 1, 0, 0, 1, 1, 1] : [0, 1, 0, 0, 1, 1, 1, 0];
    }
    Object.defineProperty(ParticleMesh.prototype, "time", {
        get: function () {
            var value = this.mesh.material.getVector4('uParams');
            return value[0];
        },
        set: function (v) {
            this.mesh.material.setVector4('uParams', [+v, this.duration, 0, 0]);
        },
        enumerable: false,
        configurable: true
    });
    ParticleMesh.prototype.getPointColor = function (index) {
        var data = this.geometry.getAttributeData('aRot');
        var i = index * 32 + 4;
        return [data[i], data[i + 1], data[i + 2], data[i + 3]];
    };
    ParticleMesh.prototype.getPointPosition = function (index) {
        var geo = this.geometry;
        var posIndex = index * 48;
        var posData = geo.getAttributeData('aPos');
        var offsetData = geo.getAttributeData('aOffset');
        var time = this.time - offsetData[index * 16 + 2];
        var pointDur = offsetData[index * 16 + 3];
        var mtl = this.mesh.material;
        var ret = calculateTranslation([0, 0, 0], this, mtl.getVector4('uAcceleration').slice(0, 3), time, pointDur, posData, posData, posIndex, posIndex + 3);
        if (this.forceTarget) {
            var target = mtl.getVector3('uFinalTarget');
            var life = this.forceTarget.curve.getValue(time / pointDur);
            var dl = 1 - life;
            ret[0] = ret[0] * dl + target[0] * life;
            ret[1] = ret[1] * dl + target[1] * life;
            ret[2] = ret[2] * dl + target[2] * life;
        }
        return ret;
    };
    ParticleMesh.prototype.clearPoints = function () {
        this.resetGeometryData(this.geometry);
        this.particleCount = 0;
        this.geometry.setDrawCount(0);
        this.maxParticleBufferCount = 0;
    };
    ParticleMesh.prototype.resetGeometryData = function (geometry) {
        var names = geometry.getAttributeNames();
        var index = geometry.getIndexData();
        for (var i = 0; i < names.length; i++) {
            var name_1 = names[i];
            var data = geometry.getAttributeData(name_1);
            if (data) {
                // @ts-expect-error
                geometry.setAttributeData(name_1, new data.constructor(0));
            }
        }
        // @ts-expect-error
        geometry.setIndexData(new index.constructor(0));
    };
    ParticleMesh.prototype.reverseTime = function (time) {
        var data = this.geometry.getAttributeData('aOffset');
        for (var i = 0; i < data.length; i += 4) {
            data[i + 2] -= time;
        }
        this.geometry.setAttributeData('aOffset', data);
        this.time -= time;
    };
    ParticleMesh.prototype.removePoint = function (index) {
        if (index < this.particleCount) {
            this.geometry.setAttributeSubData('aOffset', index * 16, new Float32Array(16));
        }
    };
    ParticleMesh.prototype.setPoint = function (point, index) {
        if (index === void 0) { index = 0; }
        var maxCount = this.maxCount;
        if (index < maxCount) {
            var particleCount = index + 1;
            var vertexCount_1 = particleCount * 4;
            var geometry_1 = this.geometry;
            var increaseBuffer_1 = particleCount > this.maxParticleBufferCount;
            var inc_1 = 1;
            if (this.particleCount > 300) {
                inc_1 = (this.particleCount + 100) / this.particleCount;
            }
            else if (this.particleCount > 100) {
                inc_1 = 1.4;
            }
            else if (this.particleCount > 0) {
                inc_1 = 2;
            }
            var pointData_1 = {
                aPos: new Float32Array(48),
                aRot: new Float32Array(32),
                aOffset: new Float32Array(16),
            };
            var useSprite = this.useSprite;
            if (useSprite) {
                pointData_1.aSprite = new Float32Array(12);
            }
            var offsets = this.textureOffsets;
            var off = [0, 0, point.delay, point.lifetime];
            var wholeUV = [0, 0, 1, 1];
            var pos = point.pos;
            var vel = point.vel;
            var color = point.color;
            var rot = ensureVec3(point.rot);
            var anchor = this.anchor;
            var sizeOffsets = [-.5, .5, -.5, -.5, .5, .5, .5, -.5];
            var seed = Math.random();
            var sprite = void 0;
            if (useSprite) {
                sprite = point.sprite;
            }
            for (var j = 0; j < 4; j++) {
                var offset = j * 2;
                var j3 = j * 3;
                var j4 = j * 4;
                var j12 = j * 12;
                var j8 = j * 8;
                pointData_1.aPos.set(pos, j12);
                pointData_1.aPos.set(vel, j12 + 3);
                pointData_1.aRot.set(rot, j8);
                pointData_1.aRot[j8 + 3] = seed;
                pointData_1.aRot.set(color, j8 + 4);
                if (useSprite) {
                    // @ts-expect-error
                    pointData_1.aSprite.set(sprite, j3);
                }
                var uv = point.uv || wholeUV;
                if (uv) {
                    var uvy = useSprite ? (1 - offsets[offset + 1]) : offsets[offset + 1];
                    off[0] = uv[0] + offsets[offset] * uv[2];
                    off[1] = uv[1] + uvy * uv[3];
                }
                pointData_1.aOffset.set(off, j4);
                var ji = (j + j);
                var sx = (sizeOffsets[ji] - anchor[0]) * point.size[0];
                var sy = (sizeOffsets[ji + 1] - anchor[1]) * point.size[1];
                for (var k = 0; k < 3; k++) {
                    pointData_1.aPos[j12 + 6 + k] = point.dirX[k] * sx;
                    pointData_1.aPos[j12 + 9 + k] = point.dirY[k] * sy;
                }
            }
            var indexData = new Uint16Array([0, 1, 2, 2, 1, 3].map(function (x) { return x + index * 4; }));
            if (increaseBuffer_1) {
                var baseIndexData = geometry_1.getIndexData();
                var idx = enlargeBuffer(baseIndexData, particleCount * 6, inc_1, maxCount * 6);
                idx.set(indexData, index * 6);
                geometry_1.setIndexData(idx);
                this.maxParticleBufferCount = idx.length / 6;
            }
            else {
                geometry_1.setIndexSubData(index * 6, indexData);
            }
            Object.keys(pointData_1).forEach(function (name) {
                var data = pointData_1[name];
                var attrSize = geometry_1.getAttributeStride(name) / Float32Array.BYTES_PER_ELEMENT;
                if (increaseBuffer_1) {
                    var baseData = geometry_1.getAttributeData(name);
                    var geoData = enlargeBuffer(baseData, vertexCount_1 * attrSize, inc_1, maxCount * 4 * attrSize);
                    geoData.set(data, data.length * index);
                    geometry_1.setAttributeData(name, geoData);
                }
                else {
                    geometry_1.setAttributeSubData(name, data.length * index, data);
                }
            });
            this.particleCount = Math.max(particleCount, this.particleCount);
            geometry_1.setDrawCount(this.particleCount * 6);
        }
    };
    return ParticleMesh;
}());
var gl2UniformSlots = [10, 32, 64, 160];
function getSlot(count) {
    for (var w = 0; w < gl2UniformSlots.length; w++) {
        var slot = gl2UniformSlots[w];
        if (slot > count) {
            return slot;
        }
    }
    return count || gl2UniformSlots[0];
}
function generateGeometryProps(maxVertex, useSprite, name) {
    var bpe = Float32Array.BYTES_PER_ELEMENT;
    var j12 = bpe * 12;
    var attributes = {
        aPos: { size: 3, offset: 0, stride: j12, data: new Float32Array(0) },
        aVel: { size: 3, offset: 3 * bpe, stride: j12, dataSource: 'aPos' },
        aDirX: { size: 3, offset: 6 * bpe, stride: j12, dataSource: 'aPos' },
        aDirY: { size: 3, offset: 9 * bpe, stride: j12, dataSource: 'aPos' },
        //
        aRot: { size: 3, offset: 0, stride: 8 * bpe, data: new Float32Array(0) },
        aSeed: { size: 1, offset: 3 * bpe, stride: 8 * bpe, dataSource: 'aRot' },
        aColor: { size: 4, offset: 4 * bpe, stride: 8 * bpe, dataSource: 'aRot' },
        //
        aOffset: { size: 4, stride: 4 * bpe, data: new Float32Array(0) },
    };
    if (useSprite) {
        attributes['aSprite'] = { size: 3, data: new Float32Array(0) };
    }
    return { attributes: attributes, indices: { data: new Uint16Array(0) }, name: name, maxVertex: maxVertex };
}
function getParticleMeshShader(item) {
    var _a, _b, _c, _d, _e;
    var props = item.content;
    var renderMode = +(((_a = props.renderer) === null || _a === void 0 ? void 0 : _a.renderMode) || 0);
    var marcos = [
        ['RENDER_MODE', renderMode],
        ['PRE_MULTIPLY_ALPHA', false],
        ['ENV_EDITOR', getConfig(RUNTIME_ENV) === PLAYER_OPTIONS_ENV_EDITOR],
    ];
    var _f = GPUCapability.getInstance(), level = _f.level, detail = _f.detail;
    var vertexKeyFrameMeta = createKeyFrameMeta();
    var fragmentKeyFrameMeta = createKeyFrameMeta();
    var enableVertexTexture = detail.maxVertexUniforms > 0;
    var speedOverLifetime = ((_b = props.positionOverLifetime) !== null && _b !== void 0 ? _b : {}).speedOverLifetime;
    var vertex_lookup_texture = 0;
    var shaderCacheId = 0;
    if (enableVertexTexture) {
        marcos.push(['ENABLE_VERTEX_TEXTURE', true]);
    }
    if (speedOverLifetime) {
        marcos.push(['SPEED_OVER_LIFETIME', true]);
        shaderCacheId |= 1 << 1;
        getKeyFrameMetaByRawValue(vertexKeyFrameMeta, speedOverLifetime);
    }
    var sprite = props.textureSheetAnimation;
    if (sprite && sprite.animate) {
        marcos.push(['USE_SPRITE', true]);
        shaderCacheId |= 1 << 2;
    }
    var filter = undefined;
    if (props.filter && props.filter.name !== FILTER_NAME_NONE) {
        marcos.push(['USE_FILTER', true]);
        shaderCacheId |= 1 << 3;
        var f = createFilterShaders(props.filter).find(function (f) { return f.isParticle; });
        if (!f) {
            throw Error("particle filter ".concat(props.filter.name, " not implement"));
        }
        filter = f;
        (_c = f.uniforms) === null || _c === void 0 ? void 0 : _c.forEach(function (val) { return getKeyFrameMetaByRawValue(vertexKeyFrameMeta, val); });
        // filter = processFilter(props.filter, fragmentKeyFrameMeta, vertexKeyFrameMeta, options);
    }
    var colorOverLifetime = props.colorOverLifetime;
    if (colorOverLifetime && colorOverLifetime.color) {
        marcos.push(['COLOR_OVER_LIFETIME', true]);
        shaderCacheId |= 1 << 4;
    }
    var opacity = colorOverLifetime && colorOverLifetime.opacity;
    if (opacity) {
        getKeyFrameMetaByRawValue(vertexKeyFrameMeta, opacity);
    }
    var positionOverLifetime = props.positionOverLifetime;
    var useOrbitalVel;
    ['x', 'y', 'z'].forEach(function (pro, i) {
        var defL = 0;
        var linearPro = 'linear' + pro.toUpperCase();
        var orbitalPro = 'orbital' + pro.toUpperCase();
        if (positionOverLifetime === null || positionOverLifetime === void 0 ? void 0 : positionOverLifetime[linearPro]) {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, positionOverLifetime[linearPro]);
            defL = 1;
            shaderCacheId |= 1 << (7 + i);
        }
        marcos.push(["LINEAR_VEL_".concat(pro.toUpperCase()), defL]);
        var defO = 0;
        if (positionOverLifetime === null || positionOverLifetime === void 0 ? void 0 : positionOverLifetime[orbitalPro]) {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, positionOverLifetime[orbitalPro]);
            defO = 1;
            shaderCacheId |= 1 << (10 + i);
            useOrbitalVel = true;
        }
        marcos.push(["ORB_VEL_".concat(pro.toUpperCase()), defO]);
    });
    if (positionOverLifetime === null || positionOverLifetime === void 0 ? void 0 : positionOverLifetime.asMovement) {
        marcos.push(['AS_LINEAR_MOVEMENT', true]);
        shaderCacheId |= 1 << 5;
    }
    if (useOrbitalVel) {
        if (positionOverLifetime === null || positionOverLifetime === void 0 ? void 0 : positionOverLifetime.asRotation) {
            marcos.push(['AS_ORBITAL_MOVEMENT', true]);
            shaderCacheId |= 1 << 6;
        }
    }
    var sizeOverLifetime = props.sizeOverLifetime;
    getKeyFrameMetaByRawValue(vertexKeyFrameMeta, sizeOverLifetime === null || sizeOverLifetime === void 0 ? void 0 : sizeOverLifetime.x);
    if (sizeOverLifetime === null || sizeOverLifetime === void 0 ? void 0 : sizeOverLifetime.separateAxes) {
        marcos.push(['SIZE_Y_BY_LIFE', 1]);
        shaderCacheId |= 1 << 14;
        getKeyFrameMetaByRawValue(vertexKeyFrameMeta, sizeOverLifetime === null || sizeOverLifetime === void 0 ? void 0 : sizeOverLifetime.y);
    }
    var rot = props.rotationOverLifetime;
    if (rot === null || rot === void 0 ? void 0 : rot.z) {
        getKeyFrameMetaByRawValue(vertexKeyFrameMeta, rot === null || rot === void 0 ? void 0 : rot.z);
        shaderCacheId |= 1 << 15;
        marcos.push(['ROT_Z_LIFETIME', 1]);
    }
    if (rot === null || rot === void 0 ? void 0 : rot.separateAxes) {
        if (rot.x) {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, rot.x);
            shaderCacheId |= 1 << 16;
            marcos.push(['ROT_X_LIFETIME', 1]);
        }
        if (rot.y) {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, rot.y);
            shaderCacheId |= 1 << 17;
            marcos.push(['ROT_Y_LIFETIME', 1]);
        }
    }
    if (rot === null || rot === void 0 ? void 0 : rot.asRotation) {
        marcos.push(['ROT_LIFETIME_AS_MOVEMENT', 1]);
        shaderCacheId |= 1 << 18;
    }
    getKeyFrameMetaByRawValue(vertexKeyFrameMeta, positionOverLifetime === null || positionOverLifetime === void 0 ? void 0 : positionOverLifetime.gravityOverLifetime);
    var forceOpt = positionOverLifetime === null || positionOverLifetime === void 0 ? void 0 : positionOverLifetime.forceTarget;
    if (forceOpt) {
        marcos.push(['FINAL_TARGET', true]);
        shaderCacheId |= 1 << 19;
        getKeyFrameMetaByRawValue(vertexKeyFrameMeta, positionOverLifetime.forceCurve);
    }
    var HALF_FLOAT = detail.halfFloatTexture;
    if (HALF_FLOAT && fragmentKeyFrameMeta.max) {
        shaderCacheId |= 1 << 20;
    }
    var maxVertexUniforms = detail.maxVertexUniforms;
    var vertexCurveTexture = vertexKeyFrameMeta.max + vertexKeyFrameMeta.curves.length - 32 > maxVertexUniforms;
    if (getConfig(RENDER_PREFER_LOOKUP_TEXTURE)) {
        vertexCurveTexture = true;
    }
    if (level === 2) {
        vertexKeyFrameMeta.max = -1;
        // vertexKeyFrameMeta.index = getSlot(vertexKeyFrameMeta.index);
        if (fragmentKeyFrameMeta.index > 0) {
            fragmentKeyFrameMeta.max = -1;
            // fragmentKeyFrameMeta.index = getSlot(fragmentKeyFrameMeta.index);
        }
    }
    if (vertexCurveTexture && HALF_FLOAT && enableVertexTexture) {
        vertex_lookup_texture = 1;
    }
    var shaderCache = ['-p:', renderMode, shaderCacheId, vertexKeyFrameMeta.index, vertexKeyFrameMeta.max, fragmentKeyFrameMeta.index, fragmentKeyFrameMeta.max].join('+');
    var shader = {
        fragment: particleFrag,
        vertex: "#define LOOKUP_TEXTURE_CURVE ".concat(vertex_lookup_texture, "\n").concat(particleVert),
        shared: true,
        cacheId: shaderCache,
        marcos: marcos,
        name: "particle#".concat(item.name),
    };
    if (filter) {
        shader.fragment = shader.fragment.replace(/#pragma\s+FILTER_FRAG/, (_d = filter.fragment) !== null && _d !== void 0 ? _d : '');
        shader.vertex = shader.vertex.replace(/#pragma\s+FILTER_VERT/, filter.vertex || 'void filterMain(float t){}\n');
        shader.cacheId += '+' + ((_e = props.filter) === null || _e === void 0 ? void 0 : _e.name);
    }
    marcos.push(['VERT_CURVE_VALUE_COUNT', vertexKeyFrameMeta.index], ['FRAG_CURVE_VALUE_COUNT', fragmentKeyFrameMeta.index], ['VERT_MAX_KEY_FRAME_COUNT', vertexKeyFrameMeta.max], ['FRAG_MAX_KEY_FRAME_COUNT', fragmentKeyFrameMeta.max]);
    return { shader: shader, vertex: vertexKeyFrameMeta.index, fragment: fragmentKeyFrameMeta.index };
}
function modifyMaxKeyframeShader(shader, maxVertex, maxFrag) {
    var _a;
    var shaderIds = (_a = shader.cacheId) === null || _a === void 0 ? void 0 : _a.split('+');
    shaderIds[3] = maxVertex;
    shaderIds[5] = maxFrag;
    shader.cacheId = shaderIds.join('+');
    if (!shader.marcos) {
        return;
    }
    for (var i = 0; i < shader.marcos.length; i++) {
        var marco = shader.marcos[i];
        if (marco[0] === 'VERT_CURVE_VALUE_COUNT') {
            marco[1] = maxVertex;
        }
        else if (marco[0] === 'FRAG_CURVE_VALUE_COUNT') {
            marco[1] = maxFrag;
            break;
        }
    }
}

var LinkNode = /** @class */ (function () {
    function LinkNode(content) {
        this.content = content;
    }
    return LinkNode;
}());
var Link = /** @class */ (function () {
    function Link(sort) {
        this.sort = sort;
        this.length = 0;
    }
    Link.prototype.findNodeByContent = function (filter) {
        var node = this.first;
        if (node) {
            do {
                if (filter(node.content)) {
                    return node;
                }
                // @ts-expect-error
                // eslint-disable-next-line no-cond-assign
            } while (node = node.next);
        }
    };
    Link.prototype.insertNode = function (a, next) {
        var b = a.next;
        a.next = next;
        next.pre = a;
        next.next = b;
        if (b) {
            b.pre = next;
        }
        // a -> next -> b
    };
    Link.prototype.shiftNode = function (content) {
        var node = new LinkNode(content);
        this.length++;
        if (this.length === 1) {
            return this.first = this.last = node;
        }
        var current = this.first;
        while (current) {
            if (this.sort(current.content, node.content) <= 0) {
                if (current.next) {
                    current = current.next;
                }
                else {
                    this.insertNode(current, node);
                    return this.last = node;
                }
            }
            else {
                if (current.pre) {
                    this.insertNode(current.pre, node);
                }
                else {
                    this.first = node;
                    node.next = current;
                    current.pre = node;
                }
                return node;
            }
        }
    };
    Link.prototype.pushNode = function (content) {
        var node = new LinkNode(content);
        this.length++;
        if (this.length === 1) {
            return this.last = this.first = node;
        }
        var current = this.last;
        while (current) {
            if (this.sort(node.content, current.content) <= 0) {
                if (this.first === current) {
                    current.pre = node;
                    node.next = current;
                    return this.first = node;
                }
                else {
                    // @ts-expect-error
                    current = current.pre;
                }
            }
            else {
                this.insertNode(current, node);
                if (current === this.last) {
                    this.last = node;
                }
                return node;
            }
        }
    };
    Link.prototype.removeNode = function (node) {
        var current = this.first;
        this.length--;
        if (current === node) {
            // @ts-expect-error
            var a = this.first = current.next;
            if (a) {
                a.pre = null;
            }
        }
        else if ((current = this.last) === node) {
            // @ts-expect-error
            var a = this.last = current.pre;
            if (a) {
                a.next = null;
            }
        }
        else if (node) {
            var pre = node.pre;
            var next = node.next;
            // @ts-expect-error
            pre.next = next;
            if (next) {
                next.pre = pre;
            }
        }
        node.pre = null;
        node.next = null;
    };
    Link.prototype.forEach = function (func, thisObj) {
        var node = this.first;
        var i = 0;
        if (node) {
            do {
                func.call(thisObj || this, node.content, i++);
                // @ts-expect-error
                // eslint-disable-next-line no-cond-assign
            } while (node = node.next);
        }
    };
    Link.prototype.forEachReverse = function (func, thisObj) {
        var node = this.last;
        var i = this.length - 1;
        if (node) {
            do {
                func.call(thisObj || this, node.content, i--);
                // @ts-expect-error
                // eslint-disable-next-line no-cond-assign
            } while (node = node.pre);
        }
    };
    return Link;
}());

var Cone = /** @class */ (function () {
    function Cone(props) {
        var _this = this;
        Object.keys(props).forEach(function (key) {
            _this[key] = props[key];
        });
    }
    Cone.prototype.generate = function (opt) {
        var arc = getArcAngle(this.arc, this.arcMode, opt);
        var a = arc * DEG2RAD;
        var x = Math.cos(a) * this.radius;
        var y = Math.sin(a) * this.radius;
        var position = [x, y, 0];
        var l = Math.tan(this.angle * DEG2RAD);
        var dir = vecDot([], position, l);
        // dir + [0,0,1]
        dir[2] += 1;
        return {
            position: vecDot(position, position, random(0, 1)),
            direction: vecNormalize(dir, dir),
        };
    };
    return Cone;
}());
function getArcAngle(arc, arcMode, opt) {
    if (arcMode === ShapeArcMode$1.RANDOM) {
        arc = random(0, arc);
    }
    else if (arcMode === ShapeArcMode$1.UNIDIRECTIONAL_CYCLE) {
        var d = opt.index % (opt.total + 1);
        arc = arc / opt.total * d;
    }
    else if (arcMode === ShapeArcMode$1.BIDIRECTIONAL_CYCLE) {
        var d = opt.index / (opt.total + 1);
        var i = d - Math.floor(d);
        arc = arc * ((Math.floor(d) % 2) ? (1 - i) : i);
    }
    else if (arcMode === ShapeArcMode$1.UNIFORM_BURST) {
        arc = arc * opt.burstIndex / opt.burstCount;
    }
    return arc;
}

var Circle = /** @class */ (function () {
    function Circle(props) {
        var _this = this;
        Object.keys(props).forEach(function (key) {
            _this[key] = props[key];
        });
    }
    Circle.prototype.generate = function (opt) {
        var arc = getArcAngle(this.arc, this.arcMode, opt) * DEG2RAD;
        var direction = [Math.cos(arc), Math.sin(arc), 0];
        var radius = this.radius;
        return {
            direction: direction,
            position: direction.map(function (n) { return n * radius; }),
        };
    };
    return Circle;
}());
var Rectangle = /** @class */ (function () {
    function Rectangle(arg) {
        this._d = (arg.width || 1) / 2;
        this._h = (arg.height || 1) / 2;
    }
    Rectangle.prototype.generate = function (opt) {
        var x = random(-this._d, this._d);
        var y = random(-this._h, this._h);
        return {
            direction: [0, 0, 1],
            position: [x, y, 0],
        };
    };
    return Rectangle;
}());
var RectangleEdge = /** @class */ (function () {
    function RectangleEdge(arg) {
        this._d = (arg.width || 1) / 2;
        this._h = (arg.height || 1) / 2;
        this.arcMode = arg.arcMode;
        this.arc = arg.arc;
    }
    RectangleEdge.prototype.generate = function (opt) {
        var arc = getArcAngle(this.arc, this.arcMode, opt) * DEG2RAD;
        var direction = [Math.cos(arc), Math.sin(arc), 0];
        var w = this._d;
        var h = this._h;
        var r0 = Math.atan2(h, w);
        var tan = Math.tan(arc);
        var position;
        if (arc < r0) {
            position = [w, w * tan, 0];
        }
        else if (arc >= r0 && arc < Math.PI - r0) {
            position = [h / tan, h, 0];
        }
        else if (arc < Math.PI + r0) {
            position = [-w, -w * tan, 0];
        }
        else if (arc < Math.PI * 2 - r0) {
            position = [-h / tan, -h, 0];
        }
        else {
            position = [w, w * tan, 0];
        }
        return {
            direction: direction,
            position: position,
        };
    };
    return RectangleEdge;
}());
var Edge = /** @class */ (function () {
    function Edge(arg) {
        this._d = (arg.width || 1) / 2;
        this.arcMode = arg.arcMode;
    }
    Edge.prototype.generate = function (opt) {
        var x = this.arcMode === ShapeArcMode$1.UNIFORM_BURST ? ((opt.burstIndex % opt.burstCount) / (opt.burstCount - 1)) : random(0, 1);
        return {
            direction: [0, 1, 0],
            position: [this._d * (x - 0.5), 0, 0],
        };
    };
    return Edge;
}());

var tempMat3$2 = [];
var Donut = /** @class */ (function () {
    function Donut(props) {
        var _this = this;
        Object.keys(props).forEach(function (key) {
            _this[key] = props[key];
        });
    }
    Donut.prototype.generate = function (opt) {
        var dradius = this.donutRadius;
        var center = this.radius - dradius;
        var angle = random(0, Math.PI * 2);
        var arc = getArcAngle(this.arc, this.arcMode, opt) * DEG2RAD;
        var rot = mat3FromRotationZ(tempMat3$2, arc);
        var direction = [Math.cos(angle), Math.sin(angle), 0];
        var position = [center + Math.cos(angle) * dradius, 0, Math.sin(angle) * dradius];
        return {
            direction: vec3MulMat3(direction, direction, rot),
            position: vec3MulMat3(position, position, rot),
        };
    };
    return Donut;
}());

var tempMat3$1 = [];
var Sphere = /** @class */ (function () {
    function Sphere(props) {
        var _this = this;
        Object.keys(props).forEach(function (key) {
            _this[key] = props[key];
        });
    }
    Sphere.prototype.getHorizontalAngle = function () {
        return random(-90, 90);
    };
    Sphere.prototype.generate = function (opt) {
        var rz = getArcAngle(this.arc, this.arcMode, opt) * DEG2RAD;
        var rh = this.getHorizontalAngle() * DEG2RAD;
        var radius = this.radius;
        var point = [Math.cos(rh), 0, Math.sin(rh)];
        var mat3 = mat3FromRotationZ(tempMat3$1, rz);
        var p = vec3MulMat3(point, point, mat3);
        return {
            position: p.map(function (a) { return a * radius; }),
            direction: p,
        };
    };
    return Sphere;
}());
var Hemisphere = /** @class */ (function (_super) {
    __extends(Hemisphere, _super);
    function Hemisphere() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Hemisphere.prototype.getHorizontalAngle = function () {
        return random(0, 90);
    };
    return Hemisphere;
}(Sphere));

var TextureShape = /** @class */ (function () {
    function TextureShape(arg) {
        var detail = arg.detail || { anchors: [0.5, 0.5], block: [0, 0] };
        this.anchors = new Float32Array(detail.anchors);
        this.width = arg.width || 1;
        this.height = arg.height || 1;
        this.block = detail.block;
        this.arcMode = arg.arcMode;
        this.random = clamp$1(arg.random || 0, 0, 1);
    }
    TextureShape.prototype.generate = function (opt) {
        var anchors = this.anchors;
        var pointCount = (anchors.length / 2 - 1);
        var index = Math.floor(getArcAngle(pointCount, this.arcMode, opt));
        var pointX = (anchors[index * 2] + this.block[0] * this.random * Math.random()) % 1 - 0.5;
        var pointY = (anchors[index * 2 + 1] + this.block[1] * this.random * Math.random()) % 1 - 0.5;
        var dir = [pointX, pointY, 0];
        return {
            position: [pointX * this.width, pointY * this.height, 0],
            direction: vecNormalize(dir, dir),
        };
    };
    return TextureShape;
}());

var _a$5;
var ShapeNone = /** @class */ (function () {
    function ShapeNone() {
    }
    ShapeNone.prototype.generate = function () {
        return {
            position: [0, 0, 0],
            direction: [0, 0, 0],
        };
    };
    return ShapeNone;
}());
var map$1 = (_a$5 = {},
    _a$5[ShapeType$1.NONE] = ShapeNone,
    _a$5[ShapeType$1.CONE] = Cone,
    _a$5[ShapeType$1.SPHERE] = Sphere,
    _a$5[ShapeType$1.HEMISPHERE] = Hemisphere,
    _a$5[ShapeType$1.CIRCLE] = Circle,
    _a$5[ShapeType$1.DONUT] = Donut,
    _a$5[ShapeType$1.RECTANGLE] = Rectangle,
    _a$5[ShapeType$1.EDGE] = Edge,
    _a$5[ShapeType$1.RECTANGLE_EDGE] = RectangleEdge,
    _a$5[ShapeType$1.TEXTURE] = TextureShape,
    _a$5);
function createShape(shapeOpts) {
    if (!shapeOpts) {
        return new ShapeNone();
    }
    var opts = __assign$1({ radius: 1, arc: 360, angle: 0, arcMode: ShapeArcMode$1.RANDOM }, shapeOpts);
    var type = shapeOpts.type;
    var Ctrl = map$1[type];
    if (!Ctrl) {
        throw Error('invalid shape:' + type);
    }
    var ret = new Ctrl(opts);
    if (type !== ShapeType$1.NONE) {
        var _a = shapeOpts, alignSpeedDirection = _a.alignSpeedDirection, _b = _a.upDirection, upDirection = _b === void 0 ? [0, 0, 1] : _b;
        ret.alignSpeedDirection = alignSpeedDirection;
        ret.upDirection = vecNormalize(upDirection);
    }
    return ret;
}

/**
 * Earcut.js from: https://github.com/mapbox/earcut/tree/v2.2.2
 */

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);

        // filter collinear points around the cuts
        filterPoints(outerNode, outerNode.next);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node$1(a.i, a.x, a.y),
        b2 = new Node$1(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node$1(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node$1(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

var indexBase = 0;
function earcut(data, holeIndices, dim, ib) {
    dim = dim || 2;
    indexBase = ib || 0;
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var outerNode = linkedList(data, 0, outerLen, dim, true);
    var triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) {
        return triangles;
    }
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) {
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    }
    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) {
                minX = x;
            }
            if (y < minY) {
                minY = y;
            }
            if (x > maxX) {
                maxX = x;
            }
            if (y > maxY) {
                maxY = y;
            }
        }
        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    hackEarcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function hackEarcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) {
        return;
    }
    // interlink polygon nodes in z-order
    if (!pass && invSize) {
        indexCurve(ear, minX, minY, invSize);
    }
    var stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim + indexBase);
            triangles.push(ear.i / dim + indexBase);
            triangles.push(next.i / dim + indexBase);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering triangles and slicing again
            if (!pass) {
                hackEarcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                // if this didn't work, try curing all small self-intersections locally
            }
            else if (pass === 1) {
                ear = hackCureLocalIntersections(filterPoints(ear), triangles, dim);
                hackEarcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                // as a last resort, try splitting the remaining polygon into two
            }
            else if (pass === 2) {
                hackSplitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
// go through all polygon nodes and cure small local self-intersections
function hackCureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim + indexBase);
            triangles.push(p.i / dim + indexBase);
            triangles.push(b.i / dim + indexBase);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    } while (p !== start);
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function hackSplitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);
                // filter colinear triangles around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                hackEarcutLinked(a, triangles, dim, minX, minY, invSize);
                hackEarcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

var POINT_INDEX = 2;
function getGeometryTriangles(geometry, options) {
    var s = geometry.s, p = geometry.p;
    var segments = s;
    var points = p;
    var pointCount = 0;
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        pointCount += segment.length - 1;
    }
    var pointData = new Float32Array(pointCount * SPRITE_VERTEX_STRIDE);
    var _a = options.indexBase, indexBase = _a === void 0 ? 0 : _a, uvTransform = options.uvTransform;
    var index = 0;
    var dx = 0, dy = 0, sw = 1, sh = 1, r;
    if (uvTransform) {
        dx = uvTransform[0];
        dy = uvTransform[1];
        r = uvTransform[4];
        sw = r ? uvTransform[3] : uvTransform[2];
        sh = r ? uvTransform[2] : uvTransform[3];
    }
    var temp = [0, 0];
    var angle = r === 0 ? 0 : -Math.PI / 2;
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        var p0 = points[i];
        var p1 = points[i + 1] || points[0];
        var keys = segment;
        var point = [0, 0];
        for (var j = 0; j < keys.length - 1; j++) {
            var key = keys[j];
            getBezier2DValue(point, key, p0, p1, p0[4], p0[5], p1[2], p1[3]);
            setPoint(point[0], point[1]);
        }
    }
    var indices = earcut(Array.from(pointData), null, SPRITE_VERTEX_STRIDE, indexBase);
    return { aPoint: pointData, index: new Uint16Array(indices) };
    function setPoint(x, y) {
        pointData[index++] = x / 2;
        pointData[index++] = y / 2;
        if (uvTransform) {
            temp[0] = x;
            temp[1] = y;
            rotateVec2(temp, temp, angle);
            pointData[index++] = dx + (temp[0] + 1) / 2 * sw;
            pointData[index++] = dy + (temp[1] + 1) / 2 * sh;
        }
        else {
            pointData[index++] = (x + 1) / 2;
            pointData[index++] = (y + 1) / 2;
        }
        index += POINT_INDEX;
    }
}
function getGeometryByShape(shape, uvTransform) {
    var datas = [];
    // TODO: gs 字段是否要兼容
    var geometries = shape.gs ? shape.gs : [shape.g];
    var indexBase = 0;
    var aPoint = 0;
    var index = 0;
    for (var i = 0; i < geometries.length; i++) {
        var geometry = geometries[i];
        var data = getGeometryTriangles(geometry, { indexBase: indexBase, uvTransform: uvTransform });
        indexBase += data.aPoint.length / 5;
        datas.push(data);
        aPoint += data.aPoint.length;
        index += data.index.length;
    }
    if (datas.length === 1) {
        return datas[0];
    }
    var aPointData = new Float32Array(aPoint);
    var indexData = new Uint16Array(index);
    // @ts-expect-error
    for (var i = 0, pointIndex = 0, idx = 0; i < datas[i]; i++) {
        var data = datas[i];
        aPointData.set(data.aPoint, pointIndex);
        pointIndex += data.aPoint.length;
        indexData.set(data.index, idx);
        idx += data.index.length;
    }
    return {
        aPoint: aPointData,
        index: indexData,
    };
}
function rotateVec2(out, vec2, angleInRad) {
    var c = Math.cos(angleInRad);
    var s = Math.sin(angleInRad);
    var x = vec2[0];
    var y = vec2[1];
    out[0] = c * x + s * y;
    out[1] = -s * x + c * y;
    return out;
}
function getBezier2DValue(out, t, p0, p1, cpx0, cpy0, cpx1, cpy1) {
    var ddt = 1 - t;
    var a = ddt * ddt * ddt;
    var b = 3 * t * ddt * ddt;
    var c = 3 * t * t * ddt;
    var d = t * t * t;
    out[0] = a * p0[0] + b * cpx0 + c * cpx1 + d * p1[0];
    out[1] = a * p0[1] + b * cpy0 + c * cpy1 + d * p1[1];
    return out;
}

var Burst = /** @class */ (function () {
    function Burst(opts) {
        var time = opts.time, interval = opts.interval, count = opts.count, cycles = opts.cycles, probability = opts.probability;
        this.time = +time || 0;
        this.interval = +interval || 1;
        this.count = count instanceof ValueGetter ? count : createValueGetter(count);
        this.cycles = +cycles || Infinity;
        this.probability = isNaN(probability) ? 1 : +probability;
        this.reset();
    }
    Burst.prototype.getGeneratorOptions = function (timePassed, lifetime) {
        var dt = timePassed - this.time - this.now;
        if (dt > this.interval * this.index && this.internalCycles > 0) {
            this.internalCycles--;
            this.index++;
            return Math.random() <= this.probability ? {
                index: this.index,
                total: 1 / this.interval,
                count: this.count.getValue(lifetime),
                cycleIndex: this.cycles - this.internalCycles - 1,
            } : null;
        }
    };
    Burst.prototype.reset = function () {
        this.internalCycles = this.cycles;
        this.index = 0;
        this.now = 0;
    };
    Burst.prototype.clone = function () {
        return new Burst(this);
    };
    return Burst;
}());

var tmp0 = [];
var tmp1 = [];
var TrailMesh = /** @class */ (function () {
    function TrailMesh(props) {
        this.pointStart = [];
        var colorOverLifetime = props.colorOverLifetime, colorOverTrail = props.colorOverTrail, maxTrailCount = props.maxTrailCount, _a = props.opacityOverLifetime, opacityOverLifetime = _a === void 0 ? createValueGetter(1) : _a, widthOverTrail = props.widthOverTrail, pcpt = props.pointCountPerTrail, name = props.name; props.shaderCachePrefix; var occlusion = props.occlusion, blending = props.blending, maskMode = props.maskMode; props.mask; var order = props.order, _b = props.textureMap, textureMap = _b === void 0 ? [0, 0, 1, 1] : _b, texture = props.texture, transparentOcclusion = props.transparentOcclusion, minimumVertexDistance = props.minimumVertexDistance, lifetime = props.lifetime, matrix = props.matrix;
        var detail = GPUCapability.getInstance().detail;
        var pointCountPerTrail = Math.max(pcpt, 2);
        var keyFrameMeta = createKeyFrameMeta();
        var enableVertexTexture = detail.maxVertexTextures > 0;
        var uniformValues = {};
        // const lookUpTexture = getConfig(RENDER_PREFER_LOOKUP_TEXTURE) ? 1 : 0;
        var lookUpTexture = 0;
        var marcos = [
            ['ENABLE_VERTEX_TEXTURE', enableVertexTexture],
            ['LOOKUP_TEXTURE_CURVE', lookUpTexture],
            ['ENV_EDITOR', getConfig(RUNTIME_ENV) === PLAYER_OPTIONS_ENV_EDITOR],
        ];
        var useAttributeTrailStart = maxTrailCount > 64;
        var shaderCacheId = 0;
        if (colorOverLifetime) {
            marcos.push(['COLOR_OVER_LIFETIME', true]);
            shaderCacheId |= 1;
            uniformValues.uColorOverLifetime = Texture.createWithData(imageDataFromGradient(colorOverLifetime));
        }
        if (colorOverTrail) {
            marcos.push(['COLOR_OVER_TRAIL', true]);
            shaderCacheId |= 1 << 2;
            uniformValues.uColorOverTrail = Texture.createWithData(imageDataFromGradient(colorOverTrail));
        }
        if (useAttributeTrailStart) {
            marcos.push(['ATTR_TRAIL_START', 1]);
            shaderCacheId |= 1 << 3;
        }
        else {
            uniformValues.uTrailStart = new Float32Array(maxTrailCount);
        }
        uniformValues.uOpacityOverLifetimeValue = opacityOverLifetime.toUniform(keyFrameMeta);
        var uWidthOverTrail = widthOverTrail.toUniform(keyFrameMeta);
        marcos.push(['VERT_CURVE_VALUE_COUNT', keyFrameMeta.index], ['VERT_MAX_KEY_FRAME_COUNT', keyFrameMeta.max]);
        if (enableVertexTexture && lookUpTexture) {
            var tex = generateHalfFloatTexture(CurveValue.getAllData(keyFrameMeta, true), keyFrameMeta.index, 1);
            uniformValues.uVCurveValueTexture = tex;
        }
        else {
            uniformValues.uVCurveValues = CurveValue.getAllData(keyFrameMeta);
        }
        var level = GPUCapability.getInstance().level;
        var vertex = createShaderWithMarcos(marcos, trailVert, exports.ShaderType.vertex);
        var fragment = createShaderWithMarcos(marcos, particleFrag, exports.ShaderType.fragment);
        var mtl = ({
            shader: {
                vertex: vertex,
                fragment: fragment,
                marcos: marcos,
                glslVersion: level === 1 ? exports.GLSLVersion.GLSL1 : exports.GLSLVersion.GLSL3,
                shared: true,
                name: "trail#".concat(name),
                cacheId: "-t:+".concat(shaderCacheId, "+").concat(keyFrameMeta.index, "+").concat(keyFrameMeta.max),
            },
            uniformSemantics: {
                mars_MatrixVP: 'VIEWPROJECTION',
                mars_MatrixInvV: 'VIEWINVERSE',
                mars_ObjectToWorld: 'MODEL',
                uEditorTransform: 'EDITOR_TRANSFORM',
            },
        });
        var maxVertexCount = pointCountPerTrail * maxTrailCount * 2;
        var maxTriangleCount = (pointCountPerTrail - 1) * maxTrailCount;
        var bpe = Float32Array.BYTES_PER_ELEMENT;
        var v12 = 12 * bpe;
        var geometryOptions = {
            attributes: {
                aColor: { size: 4, stride: v12, data: new Float32Array(maxVertexCount * 12) },
                aSeed: { size: 1, stride: v12, offset: 4 * bpe, dataSource: 'aColor' },
                aInfo: { size: 3, stride: v12, offset: 5 * bpe, dataSource: 'aColor' },
                aPos: { size: 4, stride: v12, offset: 8 * bpe, dataSource: 'aColor' },
                //
                aTime: { size: 1, data: new Float32Array(maxVertexCount) },
                //
                aDir: { size: 3, data: new Float32Array(maxVertexCount * 3) },
            },
            indices: { data: new Uint16Array(maxVertexCount * 6) },
            drawCount: maxTriangleCount * 6,
            name: "trail#".concat(name),
            bufferUsage: glContext.DYNAMIC_DRAW,
        };
        if (useAttributeTrailStart) {
            geometryOptions.attributes.aTrailStart = { size: 1, data: new Float32Array(maxVertexCount) };
        }
        else {
            var indexData = new Float32Array(maxVertexCount);
            geometryOptions.attributes.aTrailStartIndex = { size: 1, data: indexData };
            for (var i = 0; i < maxTrailCount; i++) {
                var c = pointCountPerTrail * 2;
                var s = i * c;
                for (var j = 0; j < c; j++) {
                    indexData[s + j] = i;
                }
            }
        }
        var preMulAlpha = getPreMultiAlpha(blending);
        var material = Material.create(mtl);
        material.blending = true;
        material.depthMask = occlusion;
        material.depthTest = true;
        setMaskMode(material, maskMode);
        setBlendMode(material, blending);
        var mesh = this.mesh = Mesh.create({
            name: "MTrail_".concat(name),
            material: material,
            geometry: Geometry.create(geometryOptions),
            priority: order,
        });
        var uMaskTex = texture !== null && texture !== void 0 ? texture : Texture.createWithData();
        Object.keys(uniformValues).map(function (name) {
            var value = uniformValues[name];
            if (value instanceof Texture) {
                material.setTexture(name, value);
            }
            else if (name === 'uTrailStart') {
                material.setFloats('uTrailStart', value);
            }
            else if (name === 'uVCurveValues') {
                var array = [];
                array.push([value[0], value[1], value[2], value[3]]);
                array.push([value[4], value[5], value[6], value[7]]);
                material.setVector4Array(name, array);
            }
            else {
                material.setVector4(name, value);
            }
        });
        material.setFloat('uTime', 0);
        // todo 修改下长度
        material.setVector4('uWidthOverTrail', uWidthOverTrail);
        material.setVector2('uTexOffset', [0, 0]);
        material.setVector4('uTextureMap', textureMap);
        material.setVector4('uParams', [0, pointCountPerTrail - 1, 0, 0]);
        material.setTexture('uMaskTex', uMaskTex);
        material.setVector4('uColorParams', [texture ? 1 : 0, +preMulAlpha, 0, +(occlusion && !transparentOcclusion)]);
        this.maxTrailCount = maxTrailCount;
        this.pointCountPerTrail = pointCountPerTrail;
        this.checkVertexDistance = minimumVertexDistance > 0;
        this.minimumVertexDistance = Math.pow(minimumVertexDistance || 0.001, 2);
        this.useAttributeTrailStart = useAttributeTrailStart;
        this.lifetime = lifetime;
        if (matrix) {
            this.mesh.worldMatrix = matrix;
        }
        this.geometry = mesh.firstGeometry();
        this.trailCursors = new Uint16Array(maxTrailCount);
    }
    Object.defineProperty(TrailMesh.prototype, "time", {
        get: function () {
            return this.mesh.material.getFloat('uTime') || 0;
        },
        set: function (t) {
            this.mesh.material.setFloat('uTime', t !== null && t !== void 0 ? t : 0);
        },
        enumerable: false,
        configurable: true
    });
    TrailMesh.prototype.addPoint = function (trailIndex, point, opt) {
        opt = opt || {};
        var cursor = this.trailCursors[trailIndex];
        var pointCountPerTrail = this.pointCountPerTrail;
        var geometry = this.geometry;
        var segmentPerTrail = pointCountPerTrail - 1;
        var pointIndex = cursor % pointCountPerTrail;
        var previousIndex = (cursor - 1) % pointCountPerTrail;
        var bpreviousIndex = (cursor - 2) % pointCountPerTrail;
        var previousPoint = this.getPoint(trailIndex, previousIndex, tmp0);
        // point too close
        if (previousPoint && this.checkVertexDistance && vecSquareDistance(previousPoint, point) < this.minimumVertexDistance) {
            return;
        }
        var pointStartIndex = trailIndex * pointCountPerTrail + pointIndex;
        var dir = calculateDirection(previousPoint, point);
        var time = opt.time || this.time;
        var info = [Math.random(), opt.lifetime || this.lifetime, cursor];
        var size = opt.size || 1;
        var dirStartIndex = pointStartIndex * 6;
        var dirData = new Float32Array(6);
        dirData.set(dir, 0);
        dirData.set(dir, 3);
        geometry.setAttributeSubData('aDir', dirStartIndex, dirData);
        geometry.setAttributeSubData('aTime', pointStartIndex * 2, new Float32Array([time, time]));
        var color = opt.color || [1, 1, 1, 1];
        var colorData = new Float32Array(24);
        colorData.set(color, 0);
        colorData.set(info, 4);
        colorData[7] = 0;
        colorData.set(point, 8);
        colorData[11] = 0.5 * size;
        colorData.set(color, 12);
        colorData.set(info, 16);
        colorData[19] = 1;
        colorData.set(point, 20);
        colorData[23] = -0.5 * size;
        geometry.setAttributeSubData('aColor', pointStartIndex * 24, colorData);
        if (previousIndex >= 0) {
            var bPreviousPoint = this.getPoint(trailIndex, bpreviousIndex, tmp1);
            var previousDir = new Float32Array(calculateDirection(bPreviousPoint, previousPoint, point));
            var previousDirStartIndex = (trailIndex * pointCountPerTrail + previousIndex) * 6;
            geometry.setAttributeSubData('aDir', previousDirStartIndex, previousDir);
            geometry.setAttributeSubData('aDir', previousDirStartIndex + 3, previousDir);
            var indicesStart = trailIndex * pointCountPerTrail * 2;
            var indicesData = new Uint16Array([
                previousIndex * 2 + indicesStart,
                previousIndex * 2 + 1 + indicesStart,
                pointIndex * 2 + indicesStart,
                pointIndex * 2 + indicesStart,
                previousIndex * 2 + 1 + indicesStart,
                pointIndex * 2 + 1 + indicesStart,
            ]);
            var start = (trailIndex * segmentPerTrail + (cursor - 1) % segmentPerTrail) * 6;
            geometry.setIndexSubData(start, indicesData);
        }
        cursor = ++this.trailCursors[trailIndex];
        var mtl = this.mesh.material;
        var params = mtl.getVector4('uParams');
        var trailStart = info[2];
        if (this.useAttributeTrailStart) {
            var len = pointCountPerTrail * 2;
            var startData = new Float32Array(len);
            for (var i = 0; i < len; i++) {
                startData[i] = trailStart;
            }
            geometry.setAttributeSubData('aTrailStart', trailIndex * startData.length, startData);
        }
        else {
            var value = mtl.getFloats('uTrailStart');
            if (value != undefined) {
                value[trailIndex] = trailStart;
                mtl.setFloats('uTrailStart', value);
            }
        }
        if (params) {
            params[1] = Math.max(params[1], cursor - 1) - Math.max(0, cursor - pointCountPerTrail);
            mtl.setVector4('uParams', params);
        }
    };
    TrailMesh.prototype.getPoint = function (trail, index, out) {
        var pointCountPerTrail = this.pointCountPerTrail;
        if (index >= 0 && index < pointCountPerTrail) {
            var startIndex = (trail * pointCountPerTrail + index) * 24 + 8;
            var data = this.geometry.getAttributeData('aColor');
            out[0] = data[startIndex];
            out[1] = data[1 + startIndex];
            out[2] = data[2 + startIndex];
            return out;
        }
    };
    TrailMesh.prototype.clearAllTrails = function () {
        var geo = this.geometry;
        this.trailCursors = new Uint16Array(this.trailCursors.length);
        // @ts-expect-error
        geo.setIndexData(new Uint16Array(geo.getIndexData().length));
    };
    TrailMesh.prototype.reverseTime = function (time) {
        // FIXME: 可选性
        var data = this.geometry.getAttributeData('aTime');
        for (var i = 0; i < data.length; i++) {
            data[i] -= time;
        }
        this.geometry.setAttributeData('aTime', data);
        this.time -= time;
    };
    TrailMesh.prototype.clearTrail = function (index) {
        if (this.trailCursors[index] !== 0) {
            var pointCountPerTrail = this.pointCountPerTrail;
            var indicesPerTrail = (pointCountPerTrail - 1) * 6;
            var indices = this.geometry.getIndexData();
            indices === null || indices === void 0 ? void 0 : indices.set(new Uint16Array(indicesPerTrail), index * indicesPerTrail);
            this.geometry.setIndexData(indices);
            this.trailCursors[index] = 0;
        }
    };
    TrailMesh.prototype.getPointStartPos = function (index) {
        return this.pointStart[index];
    };
    TrailMesh.prototype.setPointStartPos = function (index, pos) {
        this.pointStart[index] = pos;
    };
    TrailMesh.prototype.onUpdate = function (escapeTime) {
    };
    return TrailMesh;
}());
var tempDir$1 = [0, 0, 0];
var tempDa = [0, 0, 0];
var tempDb = [0, 0, 0];
function calculateDirection(prePoint, point, nextPoint) {
    var dir = tempDir$1;
    if (!prePoint && !nextPoint) {
        return [0, 0, 0];
    }
    else if (!prePoint) {
        vecMinus(dir, nextPoint, point);
    }
    else if (!nextPoint) {
        vecMinus(dir, point, prePoint);
    }
    else {
        vecNormalize(tempDa, vecMinus(tempDa, point, prePoint));
        vecNormalize(tempDb, vecMinus(tempDa, nextPoint, point));
        vecAdd(dir, tempDa, tempDb);
    }
    return vecNormalize(dir, dir);
}
function getTrailMeshShader(trails, particleMaxCount, name) {
    var shaderCacheId = 0;
    var lookUpTexture = getConfig(RENDER_PREFER_LOOKUP_TEXTURE) ? 1 : 0;
    var enableVertexTexture = GPUCapability.getInstance().detail.maxVertexTextures > 0;
    var marcos = [
        ['ENABLE_VERTEX_TEXTURE', enableVertexTexture],
        ['LOOKUP_TEXTURE_CURVE', lookUpTexture],
        ['ENV_EDITOR', getConfig(RUNTIME_ENV) === PLAYER_OPTIONS_ENV_EDITOR],
    ];
    var keyFrameMeta = createKeyFrameMeta();
    if (trails.colorOverLifetime) {
        marcos.push(['COLOR_OVER_LIFETIME', true]);
        shaderCacheId |= 1;
    }
    if (trails.colorOverTrail) {
        marcos.push(['COLOR_OVER_TRAIL', true]);
        shaderCacheId |= 1 << 2;
    }
    var useAttributeTrailStart = particleMaxCount > 64;
    if (useAttributeTrailStart) {
        marcos.push(['ATTR_TRAIL_START', 1]);
        shaderCacheId |= 1 << 3;
    }
    getKeyFrameMetaByRawValue(keyFrameMeta, trails.opacityOverLifetime);
    getKeyFrameMetaByRawValue(keyFrameMeta, trails.widthOverTrail);
    marcos.push(['VERT_CURVE_VALUE_COUNT', keyFrameMeta.index], ['VERT_MAX_KEY_FRAME_COUNT', keyFrameMeta.max]);
    return {
        vertex: trailVert,
        fragment: particleFrag,
        marcos: marcos,
        shared: true,
        name: 'trail#' + name,
        cacheId: "-t:+".concat(shaderCacheId, "+").concat(keyFrameMeta.index, "+").concat(keyFrameMeta.max),
    };
}

var ParticleSystem = /** @class */ (function () {
    function ParticleSystem(props, rendererOptions, vfxItem) {
        var _this = this;
        var _a, _b, _c;
        var composition = vfxItem.composition, endBehavior = vfxItem.endBehavior, name = vfxItem.name;
        if (!composition) {
            return;
        }
        var _d = rendererOptions.cachePrefix, cachePrefix = _d === void 0 ? '' : _d;
        var options = props.options;
        var positionOverLifetime = props.positionOverLifetime;
        var shape = props.shape;
        var duration = vfxItem.duration || 1;
        var gravityModifier = positionOverLifetime.gravityOverLifetime;
        var _textureSheetAnimation = props.textureSheetAnimation;
        var textureSheetAnimation = _textureSheetAnimation ? {
            animationDelay: createValueGetter(_textureSheetAnimation.animationDelay || 0),
            animationDuration: createValueGetter(_textureSheetAnimation.animationDuration || 1),
            cycles: createValueGetter(_textureSheetAnimation.cycles || 1),
            animate: _textureSheetAnimation.animate,
            col: _textureSheetAnimation.col,
            row: _textureSheetAnimation.row,
            total: _textureSheetAnimation.total || _textureSheetAnimation.col * _textureSheetAnimation.row,
        } : null;
        var renderMatrix = mat4create();
        this.worldMat4 = mat4create();
        var startTurbulence = !!(shape && shape.turbulenceX || shape.turbulenceY || shape.turbulenceZ);
        var turbulence;
        if (startTurbulence) {
            turbulence = [
                createValueGetter((_a = shape.turbulenceX) !== null && _a !== void 0 ? _a : 0),
                createValueGetter((_b = shape.turbulenceY) !== null && _b !== void 0 ? _b : 0),
                createValueGetter((_c = shape.turbulenceZ) !== null && _c !== void 0 ? _c : 0),
            ];
        }
        var ctrl = {
            // filter: props.filter,
            renderMatrix: renderMatrix,
            options: {
                particleFollowParent: !!options.particleFollowParent,
                startLifetime: createValueGetter(options.startLifetime),
                startDelay: createValueGetter(options.startDelay || 0),
                startSpeed: createValueGetter(positionOverLifetime.startSpeed || 0),
                startColor: createValueGetter(options.startColor),
                endBehavior: endBehavior,
                duration: duration,
                looping: endBehavior === ItemEndBehavior$1.loop,
                maxCount: (options.maxCount || 0),
                gravityModifier: createValueGetter(gravityModifier || 0).scaleXCoord(duration),
                start3DSize: !!options.start3DSize,
                startTurbulence: startTurbulence,
                turbulence: turbulence,
            },
            shape: createShape(shape),
            emission: {
                rateOverTime: createValueGetter(props.emission.rateOverTime),
                // @ts-expect-error
                burstOffsets: getBurstOffsets(props.emission.burstOffsets),
                bursts: (props.emission.bursts || []).map(function (c) { return new Burst(c); }),
            },
            textureSheetAnimation: textureSheetAnimation,
            name: name,
        };
        if (options.startRotationZ) {
            ctrl.options.startRotation = createValueGetter(options.startRotationZ || 0);
        }
        if (options.startRotationX || options.startRotationY) {
            ctrl.options.start3DRotation = true;
            ctrl.options.startRotationX = createValueGetter(options.startRotationX || 0);
            ctrl.options.startRotationY = createValueGetter(options.startRotationY || 0);
            ctrl.options.startRotationZ = createValueGetter(options.startRotationZ || 0);
        }
        if (options.start3DSize) {
            ctrl.options.startSizeX = createValueGetter(options.startSizeX);
            ctrl.options.startSizeY = createValueGetter(options.startSizeY);
        }
        else {
            ctrl.options.startSize = createValueGetter(options.startSize);
            ctrl.options.sizeAspect = createValueGetter(options.sizeAspect || 1);
        }
        var renderer = props.renderer || {};
        var rotationOverLifetime = {};
        var rotOverLt = props.rotationOverLifetime;
        if (rotOverLt) {
            rotationOverLifetime.asRotation = !!rotOverLt.asRotation;
            rotationOverLifetime.z = rotOverLt.z ? createValueGetter(rotOverLt.z) : createValueGetter(0);
            if (rotOverLt.separateAxes) {
                rotationOverLifetime.x = rotOverLt.x && createValueGetter(rotOverLt.x);
                rotationOverLifetime.y = rotOverLt.y && createValueGetter(rotOverLt.y);
            }
        }
        var forceTarget;
        if (positionOverLifetime.forceTarget) {
            forceTarget = {
                target: positionOverLifetime.target || [0, 0, 0],
                curve: createValueGetter(positionOverLifetime.forceCurve || [ValueType$1.LINE, [[0, 0], [1, 1]]]),
            };
        }
        var linearVelOverLifetime = {
            x: positionOverLifetime.linearX && createValueGetter(positionOverLifetime.linearX || 0),
            y: positionOverLifetime.linearY && createValueGetter(positionOverLifetime.linearY || 0),
            z: positionOverLifetime.linearZ && createValueGetter(positionOverLifetime.linearZ || 0),
            asMovement: positionOverLifetime.asMovement,
        };
        var orbitalVelOverLifetime = {
            x: positionOverLifetime.orbitalX && createValueGetter(positionOverLifetime.orbitalX),
            y: positionOverLifetime.orbitalY && createValueGetter(positionOverLifetime.orbitalY),
            z: positionOverLifetime.orbitalZ && createValueGetter(positionOverLifetime.orbitalZ),
            center: positionOverLifetime.orbCenter,
            asRotation: positionOverLifetime.asRotation,
        };
        var sizeOverLifetime = props.sizeOverLifetime || {};
        var colorOverLifetime = props.colorOverLifetime;
        var order = vfxItem.listIndex;
        var shaderCachePrefix = cachePrefix;
        var sizeOverLifetimeGetter = (sizeOverLifetime === null || sizeOverLifetime === void 0 ? void 0 : sizeOverLifetime.separateAxes) ?
            {
                separateAxes: true,
                x: createValueGetter(sizeOverLifetime.x),
                y: createValueGetter(sizeOverLifetime.y),
            } :
            {
                separateAxes: false,
                x: createValueGetter(('size' in sizeOverLifetime ? sizeOverLifetime.size : sizeOverLifetime.x) || 1),
            };
        var meshOptions = {
            renderFrame: composition.renderFrame,
            listIndex: order,
            // @ts-expect-error
            meshSlots: options.meshSlots,
            // filter: props.filter,
            name: name,
            matrix: renderMatrix,
            filter: props.filter,
            shaderCachePrefix: shaderCachePrefix,
            renderMode: renderer.renderMode || RenderMode$1.BILLBOARD,
            side: renderer.side || SideMode$1.DOUBLE,
            gravityModifier: ctrl.options.gravityModifier,
            gravity: ensureVec3(positionOverLifetime.gravity),
            duration: vfxItem.duration,
            blending: renderer.blending || BlendingMode$1.ALPHA,
            rotationOverLifetime: rotationOverLifetime,
            linearVelOverLifetime: linearVelOverLifetime,
            orbitalVelOverLifetime: orbitalVelOverLifetime,
            speedOverLifetime: positionOverLifetime.speedOverLifetime && createValueGetter(positionOverLifetime.speedOverLifetime),
            // @ts-expect-error
            sprite: textureSheetAnimation,
            occlusion: !!renderer.occlusion,
            transparentOcclusion: !!renderer.transparentOcclusion,
            maxCount: options.maxCount,
            mask: renderer.mask,
            maskMode: renderer.maskMode,
            forceTarget: forceTarget,
            diffuse: renderer.texture,
            sizeOverLifetime: sizeOverLifetimeGetter,
            anchor: renderer.anchor || convertParticleOrigin2Anchor(renderer.particleOrigin),
        };
        if (colorOverLifetime) {
            var color = colorOverLifetime.color, opacity = colorOverLifetime.opacity;
            meshOptions.colorOverLifetime = {};
            if (opacity) {
                meshOptions.colorOverLifetime.opacity = createValueGetter(colorOverLifetime.opacity);
            }
            if (color) {
                if (color[0] === ValueType$1.GRADIENT_COLOR) {
                    // @ts-expect-error
                    meshOptions.colorOverLifetime.color = colorOverLifetime.color[1];
                }
                else if (color[0] === ValueType$1.RGBA_COLOR) {
                    meshOptions.colorOverLifetime.color = Texture.createWithData({
                        data: new Uint8Array(color[1]),
                        width: 1,
                        height: 1,
                    });
                }
                else if (color instanceof Texture) {
                    meshOptions.colorOverLifetime.color = color;
                }
            }
        }
        var uvs = [];
        var textureMap = [0, 0, 1, 1];
        var flip;
        if (props.splits) {
            var s = props.splits[0];
            flip = s[4];
            textureMap = flip ? [s[0], s[1], s[3], s[2]] : [s[0], s[1], s[2], s[3]];
        }
        if (textureSheetAnimation && !textureSheetAnimation.animate) {
            var col = flip ? textureSheetAnimation.row : textureSheetAnimation.col;
            var row = flip ? textureSheetAnimation.col : textureSheetAnimation.row;
            var total = textureSheetAnimation.total || col * row;
            var index$1 = 0;
            for (var x = 0; x < col; x++) {
                for (var y = 0; y < row && index$1 < total; y++, index$1++) {
                    uvs.push([
                        x * textureMap[2] / col + textureMap[0],
                        y * textureMap[3] / row + textureMap[1],
                        textureMap[2] / col,
                        textureMap[3] / row
                    ]);
                }
            }
        }
        else {
            uvs.push(textureMap);
        }
        // @ts-expect-error
        meshOptions.textureFlip = flip;
        ctrl.uvs = uvs;
        ctrl.particleMesh = new ParticleMesh(meshOptions, {
            composition: composition,
        });
        var trails = props.trails;
        if (trails) {
            ctrl.trails = {
                lifetime: createValueGetter(trails.lifetime),
                dieWithParticles: trails.dieWithParticles !== false,
                sizeAffectsWidth: trails.sizeAffectsWidth,
                sizeAffectsLifetime: trails.sizeAffectsLifetime,
                inheritParticleColor: trails.inheritParticleColor,
                parentAffectsPosition: trails.parentAffectsPosition,
            };
            ctrl.trailMesh = new TrailMesh({
                name: vfxItem.name + '_trail',
                // @ts-expect-error
                colorOverLifetime: trails.colorOverLifetime && trails.colorOverLifetime[0] === ValueType$1.GRADIENT_COLOR && trails.colorOverLifetime[1],
                matrix: renderMatrix,
                minimumVertexDistance: trails.minimumVertexDistance || 0.02,
                maxTrailCount: options.maxCount,
                pointCountPerTrail: Math.round(trails.maxPointPerTrail) || 32,
                blending: trails.blending,
                // @ts-expect-error
                texture: trails.texture,
                opacityOverLifetime: createValueGetter(trails.opacityOverLifetime || 1),
                widthOverTrail: createValueGetter(trails.widthOverTrail || 1),
                // @ts-expect-error
                colorOverTrail: trails.colorOverTrail && trails.colorOverTrail[0] === ValueType$1.GRADIENT_COLOR && trails.colorOverTrail[1],
                order: order + (trails.orderOffset || 0),
                shaderCachePrefix: shaderCachePrefix,
                lifetime: ctrl.trails.lifetime,
                occlusion: !!trails.occlusion,
                transparentOcclusion: !!trails.transparentOcclusion,
                // @ts-expect-error
                textureMap: trails.textureMap,
                mask: renderer.mask,
                maskMode: renderer.maskMode,
            });
        }
        Object.keys(ctrl).forEach(function (key) {
            // TODO: 这里给 this.options 赋值的，懵逼！
            // @ts-expect-error
            _this[key] = ctrl[key];
        });
        this.transform = vfxItem.transform;
        var position = __spreadArray([], __read$1(this.transform.position), false);
        var rotation = deepClone(this.transform.rotation);
        var transformPath = props.emitterTransform && props.emitterTransform.path;
        var path;
        if (transformPath) {
            if (transformPath[0] === ValueType$1.CONSTANT_VEC3) {
                vecAdd(position, position, transformPath[1]);
            }
            else {
                path = createValueGetter(transformPath);
            }
        }
        this.transformFormula = {
            position: position,
            rotation: rotation,
            path: path,
        };
        this.updateEmitterTransform(0);
        var meshes = [this.particleMesh.mesh];
        if (this.trailMesh) {
            meshes.push(this.trailMesh.mesh);
        }
        this.meshes = meshes;
        this.reusable = vfxItem.reusable;
        this.setVisible(vfxItem.getVisible());
        var interaction = props.interaction;
        if (interaction) {
            this.interaction = {
                multiple: interaction.multiple,
                radius: interaction.radius,
                behavior: interaction.behavior,
            };
        }
    }
    Object.defineProperty(ParticleSystem.prototype, "timePassed", {
        get: function () {
            return this.lastUpdate - this.loopStartTime;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticleSystem.prototype, "lifetime", {
        get: function () {
            return this.timePassed / this.options.duration;
        },
        enumerable: false,
        configurable: true
    });
    ParticleSystem.prototype.setVisible = function (visible) {
        this.particleMesh.mesh.setVisible(visible);
        if (this.trailMesh) {
            this.trailMesh.mesh.setVisible(visible);
        }
    };
    ParticleSystem.prototype.setParentTransform = function (transform) {
        this.parentTransform = transform;
    };
    ParticleSystem.prototype.getTextures = function () {
        var e_1, _a, e_2, _b;
        var textures = [];
        try {
            // @ts-expect-error
            for (var _c = __values$1(Object.values(this.particleMesh.mesh.material.textures)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var texture = _d.value;
                textures.push(texture);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (this.trailMesh) {
            try {
                // @ts-expect-error
                for (var _e = __values$1(Object.values(this.trailMesh.mesh.material.textures)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var texture = _f.value;
                    textures.push(texture);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        // @ts-expect-error
        return textures;
    };
    ParticleSystem.prototype.start = function () {
        if (!this.started || this.ended) {
            this.reset();
            this.started = true;
            this.ended = false;
        }
    };
    ParticleSystem.prototype.stop = function () {
        this.ended = true;
        this.started = false;
    };
    ParticleSystem.prototype.reset = function () {
        var _a;
        this.particleMesh.clearPoints();
        (_a = this.trailMesh) === null || _a === void 0 ? void 0 : _a.clearAllTrails();
        this.lastUpdate = 0;
        this.loopStartTime = 0;
        this.lastEmitTime = -1 / this.emission.rateOverTime.getValue(0);
        this.generatedCount = 0;
        this.particleLink = new Link(function (a, b) { return a[0] - b[0]; });
        this.emission.bursts.forEach(function (b) { return b.reset(); });
        this.frozen = false;
    };
    ParticleSystem.prototype.onUpdate = function (delta) {
        var _this = this;
        if (this.started && !this.frozen) {
            var now = this.lastUpdate + delta / 1000;
            var particleMesh = this.particleMesh;
            var trailMesh = this.trailMesh;
            var options = this.options;
            var loopStartTime_1 = this.loopStartTime;
            var emission = this.emission;
            this.lastUpdate = now;
            this.upDirectionWorld = null;
            particleMesh.time = now;
            if (trailMesh) {
                trailMesh.time = now;
                trailMesh.onUpdate(delta);
            }
            var link_1 = this.particleLink;
            var emitterLifetime_1 = (now - loopStartTime_1) / options.duration;
            var timePassed_1 = this.timePassed;
            var trailUpdated_1 = false;
            var updateTrail = function () {
                if (_this.trails && !trailUpdated_1) {
                    trailUpdated_1 = true;
                    link_1.forEach(function (_a) {
                        var _b = __read$1(_a, 4), time = _b[0], cursor = _b[1], delay = _b[2], size = _b[3];
                        if (time < timePassed_1) {
                            _this.clearPointTrail(cursor);
                        }
                        else if (timePassed_1 > delay) {
                            _this.updatePointTrail(cursor, emitterLifetime_1, size, delay);
                        }
                    });
                }
            };
            if (!this.ended) {
                var duration_1 = options.duration;
                var lifetime = this.lifetime;
                if (timePassed_1 < duration_1) {
                    var interval = 1 / emission.rateOverTime.getValue(lifetime);
                    var pointCount = Math.floor((timePassed_1 - this.lastEmitTime) / interval);
                    var maxEmissionCount = pointCount;
                    var timeDelta = interval / pointCount;
                    var meshTime = now;
                    var maxCount_1 = options.maxCount;
                    this.updateEmitterTransform(timePassed_1);
                    var shouldSkipGenerate = function () {
                        var first = link_1.first;
                        return _this.emissionStopped || (link_1.length === maxCount_1 && first && (first.content[0] - loopStartTime_1) > timePassed_1);
                    };
                    for (var i = 0; i < maxEmissionCount && i < maxCount_1; i++) {
                        if (shouldSkipGenerate()) {
                            break;
                        }
                        var p = this.createPoint(lifetime);
                        p.delay += meshTime + i * timeDelta;
                        this.addParticle(p, maxCount_1);
                        this.lastEmitTime = timePassed_1;
                    }
                    var bursts = emission.bursts;
                    for (var j = (bursts === null || bursts === void 0 ? void 0 : bursts.length) - 1, cursor = 0; j >= 0 && cursor < maxCount_1; j--) {
                        if (shouldSkipGenerate()) {
                            break;
                        }
                        var burst = bursts[j];
                        var opts = !burst.disabled && burst.getGeneratorOptions(timePassed_1, lifetime);
                        if (opts) {
                            var originVec = [0, 0, 0];
                            var offsets = emission.burstOffsets[j];
                            var burstOffset = (offsets && offsets[opts.cycleIndex]) || originVec;
                            if (burst.once) {
                                this.removeBurst(j);
                            }
                            for (var i = 0; i < opts.count && cursor < maxCount_1; i++) {
                                if (shouldSkipGenerate()) {
                                    break;
                                }
                                var p = this.initPoint(this.shape.generate({
                                    total: opts.total,
                                    index: opts.index,
                                    burstIndex: i,
                                    burstCount: opts.count,
                                }));
                                p.delay += meshTime;
                                cursor++;
                                vecAdd(p.pos, p.pos, burstOffset);
                                this.addParticle(p, maxCount_1);
                            }
                        }
                    }
                }
                else if (options.looping) {
                    now -= duration_1;
                    this.loopStartTime = now;
                    this.lastEmitTime -= duration_1;
                    this.lastUpdate -= duration_1;
                    updateTrail();
                    emission.bursts.forEach(function (b) { return b.reset(); });
                    particleMesh.reverseTime(duration_1);
                    if (trailMesh) {
                        trailMesh.reverseTime(duration_1);
                    }
                    this.particleLink.forEach(function (content) {
                        content[0] -= duration_1;
                        content[2] -= duration_1;
                    });
                    this.onIterate(this);
                }
                else {
                    this.ended = true;
                    this.onEnd(this);
                    var endBehavior = options.endBehavior;
                    if (endBehavior === END_BEHAVIOR_FREEZE$1) {
                        this.frozen = true;
                    }
                }
            }
            else if (!options.looping) {
                if (this.reusable) ;
                else if (END_BEHAVIOR_DESTROY$1 === options.endBehavior) {
                    var node = link_1.last;
                    if (node && (node.content[0] - loopStartTime_1) < timePassed_1) {
                        this.onUpdate = function () { return _this.onDestroy(); };
                    }
                }
            }
            updateTrail();
        }
    };
    ParticleSystem.prototype.updateEmitterTransform = function (time) {
        var parentTransform = this.parentTransform;
        var transform = this.transformFormula;
        var node = this.transform;
        var changed;
        if (parentTransform || transform.path) {
            changed = true;
        }
        if (transform.path) {
            changed = true;
        }
        if (changed) {
            var selfPos = vecFill(tempVec3, 0);
            this.transform.dispose();
            if (transform.position) {
                vecAdd(selfPos, selfPos, this.transformFormula.position);
            }
            if (transform.path) {
                var duration = this.options.duration;
                vecAdd(selfPos, selfPos, transform.path.getValue(time / duration));
            }
            node.setPosition(selfPos[0], selfPos[1], selfPos[2]);
            if (this.options.particleFollowParent && parentTransform) {
                parentTransform.getWorldMatrix(this.particleMesh.mesh.worldMatrix);
                if (this.trailMesh) {
                    parentTransform.getWorldMatrix(this.trailMesh.mesh.worldMatrix);
                }
            }
        }
    };
    ParticleSystem.prototype.onDestroy = function () {
    };
    ParticleSystem.prototype.raycast = function (options) {
        var currentTime = this.timePassed;
        var link = this.particleLink;
        var mesh = this.particleMesh;
        if (!(link && mesh)) {
            return;
        }
        var node = link.last;
        var hitPositions = [];
        var finish = false;
        if (node) {
            do {
                var nodeContent = node.content;
                var cursor = nodeContent[1];
                var temp = [];
                if (nodeContent[0] > currentTime) {
                    var pos = mesh.getPointPosition(cursor);
                    var ray = options.ray;
                    var pass = false;
                    if (ray) {
                        pass = !!intersectRaySphere(temp, ray.center, ray.direction, pos, options.radius);
                    }
                    if (pass) {
                        if (options.removeParticle) {
                            mesh.removePoint(cursor);
                            this.clearPointTrail(cursor);
                            link.removeNode(node);
                            nodeContent[0] = 0;
                            link.shiftNode(node.content);
                        }
                        hitPositions.push(pos);
                        if (!options.multiple) {
                            finish = true;
                        }
                    }
                }
                else {
                    break;
                }
                // @ts-expect-error
            } while ((node = node.pre) && !finish);
        }
        return hitPositions;
    };
    ParticleSystem.prototype.addParticle = function (point, maxCount) {
        var link = this.particleLink;
        var linkContent = [point.delay + point.lifetime, 0, point.delay, point.size[0]];
        var cursor;
        if (link.length < maxCount) {
            cursor = linkContent[1] = link.length;
        }
        else {
            var first = link.first;
            link.removeNode(first);
            cursor = linkContent[1] = first.content[1];
        }
        link.pushNode(linkContent);
        this.particleMesh.setPoint(point, cursor);
        this.clearPointTrail(cursor);
        if (this.parentTransform && this.trailMesh) {
            // @ts-expect-error
            this.trailMesh.setPointStartPos(cursor, this.parentTransform.position);
        }
    };
    ParticleSystem.prototype.clearPointTrail = function (pointIndex) {
        var _a;
        if (this.trails && this.trails.dieWithParticles) {
            (_a = this.trailMesh) === null || _a === void 0 ? void 0 : _a.clearTrail(pointIndex);
        }
    };
    ParticleSystem.prototype.updatePointTrail = function (pointIndex, emitterLifetime, size, startTime) {
        var trails = this.trails;
        var particleMesh = this.particleMesh;
        var position = particleMesh.getPointPosition(pointIndex);
        var color = trails.inheritParticleColor && particleMesh.getPointColor(pointIndex);
        var width = 1;
        var lifetime = trails.lifetime.getValue(emitterLifetime);
        if (trails.sizeAffectsWidth) {
            width *= size;
        }
        if (trails.sizeAffectsLifetime) {
            lifetime *= size;
        }
        if (trails.parentAffectsPosition && this.parentTransform) {
            vecAdd(position, position, this.parentTransform.position);
            // @ts-expect-error
            var pos = this.trailMesh.getPointStartPos(pointIndex);
            if (pos) {
                // @ts-expect-error
                vecMinus(position, position, pos);
            }
        }
        // @ts-expect-error
        this.trailMesh.addPoint(pointIndex, position, {
            // @ts-expect-error
            color: color,
            lifetime: lifetime,
            size: width,
            time: startTime,
        });
    };
    ParticleSystem.prototype.onEnd = function (particle) {
    };
    ParticleSystem.prototype.onIterate = function (particle) {
    };
    ParticleSystem.prototype.initPoint = function (data) {
        var options = this.options;
        var lifetime = this.lifetime;
        var shape = this.shape;
        var speed = options.startSpeed.getValue(lifetime);
        var followParent = this.options.particleFollowParent;
        var matrix4 = followParent ? this.transform.getMatrix() : this.transform.getWorldMatrix(this.worldMat4);
        var pos = vec3MulMat4(data.position, data.position, matrix4);
        var direction = data.direction;
        direction = vecNormalize(tempDir, vec3RotateByMat4(tempDir, direction, matrix4));
        if (options.startTurbulence) {
            for (var i = 0; i < 3; i++) {
                // @ts-expect-error
                tempVec3[i] = options.turbulence[i].getValue(lifetime);
            }
            var mat3 = mat3FromRotation(tempMat3, tempVec3);
            direction = vecNormalize(tempDir, vec3MulMat3(direction, direction, mat3));
        }
        var dirX = tmpDirX;
        var dirY = tmpDirY;
        if (shape.alignSpeedDirection) {
            vecAssign(dirY, direction, 3);
            if (!this.upDirectionWorld) {
                // @ts-expect-error
                this.upDirectionWorld = vec3RotateByMat4([], shape.upDirection, matrix4);
            }
            dirX = vecNormalize(dirX, vec3Cross(dirX, dirY, this.upDirectionWorld));
        }
        else {
            dirX[0] = 1;
            dirX[1] = dirX[2] = 0;
            dirY[1] = 1;
            dirY[0] = dirY[2] = 0;
        }
        var sprite;
        var tsa = this.textureSheetAnimation;
        if (tsa && tsa.animate) {
            sprite = tempSprite;
            sprite[0] = tsa.animationDelay.getValue(lifetime);
            sprite[1] = tsa.animationDuration.getValue(lifetime);
            sprite[2] = tsa.cycles.getValue(lifetime);
        }
        var rot = tempRot;
        if (options.start3DRotation) {
            // @ts-expect-error
            rot = [options.startRotationX.getValue(lifetime), options.startRotationY.getValue(lifetime), options.startRotationZ.getValue(lifetime)];
        }
        else if (options.startRotation) {
            rot = [0, 0, options.startRotation.getValue(lifetime)];
        }
        var color = options.startColor.getValue(lifetime);
        if (color.length === 3) {
            color[3] = 1;
        }
        var size = tempSize;
        if (options.start3DSize) {
            // @ts-expect-error
            size[0] = options.startSizeX.getValue(lifetime);
            // @ts-expect-error
            size[1] = options.startSizeY.getValue(lifetime);
        }
        else {
            // @ts-expect-error
            var n = options.startSize.getValue(lifetime);
            // @ts-expect-error
            var aspect = options.sizeAspect.getValue(lifetime);
            size[0] = n;
            size[1] = n / aspect;
        }
        if (!followParent) {
            // @ts-expect-error
            this.transform.assignWorldTRS(null, null, tempVec3);
            vecMulCombine(size, size, tempVec3);
        }
        return {
            vel: vecDot(tempVel, direction, speed),
            color: color,
            pos: pos,
            delay: options.startDelay.getValue(lifetime),
            lifetime: options.startLifetime.getValue(lifetime),
            size: size,
            // @ts-expect-error
            uv: randomArrItem(this.uvs, true),
            sprite: sprite,
            rot: rot,
            dirY: dirY,
            dirX: dirX,
        };
    };
    ParticleSystem.prototype.addBurst = function (burst, offsets) {
        var willAdd = false;
        if (!this.emission.bursts.includes(burst)) {
            this.emission.bursts.push(burst);
            willAdd = true;
        }
        if (willAdd && offsets instanceof Array) {
            var index = this.emission.bursts.indexOf(burst);
            this.emission.burstOffsets[index] = offsets;
            return index;
        }
        return -1;
    };
    ParticleSystem.prototype.removeBurst = function (index) {
        if (index < this.emission.bursts.length) {
            this.emission.burstOffsets[index] = null;
            this.emission.bursts.splice(index, 1);
        }
    };
    ParticleSystem.prototype.createPoint = function (lifetime) {
        var generator = {
            total: this.emission.rateOverTime.getValue(lifetime),
            index: this.generatedCount,
            burstIndex: 0,
            burstCount: 0,
        };
        this.generatedCount++;
        return this.initPoint(this.shape.generate(generator));
    };
    return ParticleSystem;
}());
// array performance better for small memory than Float32Array
var tempVel = [0, 0, 0];
var tempDir = [0, 0, 0];
var tempSize = [0, 0];
var tempRot = [0, 0, 0];
var tmpDirX = [0, 0, 0];
var tmpDirY = [0, 0, 0];
var tempVec3 = [0, 0, 0];
var tempSprite = [0, 0, 0];
var tempMat3 = [];
function getBurstOffsets(burstOffsets) {
    var ret = {};
    if (Array.isArray(burstOffsets)) {
        burstOffsets.forEach(function (arr) {
            var isArr = arr instanceof Array;
            var index = isArr ? arr[0] : arr.index;
            var offsets = ret[index];
            if (!offsets) {
                offsets = ret[index] = [];
            }
            if (isArr) {
                offsets.push(arr.slice(1, 4));
            }
            else {
                offsets.push([+arr.x, +arr.y, +arr.z]);
            }
        });
    }
    return ret;
}
function randomArrItem(arr, keepArr) {
    var index = Math.floor(Math.random() * arr.length);
    var item = arr[index];
    if (!keepArr) {
        arr.splice(index, 1);
    }
    return item;
}

var ParticleVFXItem = /** @class */ (function (_super) {
    __extends(ParticleVFXItem, _super);
    function ParticleVFXItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ParticleVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.particle;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticleVFXItem.prototype, "contentVisible", {
        get: function () {
            return !this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    ParticleVFXItem.prototype.onConstructed = function (props) {
        this.particle = props.content;
    };
    ParticleVFXItem.prototype.onLifetimeBegin = function (composition, particleSystem) {
        var _this = this;
        if (particleSystem) {
            particleSystem.name = this.name;
            particleSystem.start();
            particleSystem.onDestroy = function () {
                _this.destroyed = true;
            };
        }
        return particleSystem;
    };
    ParticleVFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        var _a;
        if (this.content) {
            var hide = !this.visible;
            if (!hide && this.parentId) {
                var parentData = (_a = this.composition) === null || _a === void 0 ? void 0 : _a.calculateGroup.getRenderData(this.parentId);
                if (parentData) {
                    this.content.setParentTransform(parentData.transform);
                    if (!parentData.visible) {
                        hide = false;
                    }
                }
            }
            if (hide) {
                this.content.setVisible(true);
            }
            else {
                this.content.setVisible(false);
                this.content.onUpdate(dt);
            }
        }
    };
    ParticleVFXItem.prototype.onItemRemoved = function (composition, content) {
        if (content) {
            composition.destroyTextures(content.getTextures());
            content.meshes.forEach(function (mesh) { return mesh.dispose({ material: { textures: exports.DestroyOptions.keep } }); });
        }
    };
    ParticleVFXItem.prototype.stopParticleEmission = function () {
        if (this.content) {
            this.content.emissionStopped = true;
        }
    };
    ParticleVFXItem.prototype.resumeParticleEmission = function () {
        if (this.content) {
            this.content.emissionStopped = false;
        }
    };
    // TODO: 应该没用了
    ParticleVFXItem.prototype.precompile = function () {
        this.createContent();
        //
        // FIXME:renderMesh时会进行initialize也就是AssignRenderer，这是一个兜底的操作，支持前面不assign。
        // 如果要在这里assign，需要引入新的抽象接口和抽象对象。目前来说运行时没问题，就是GPU资源创建时机改了。
        //
        // const particle = this.content;
        // const renderer = this.composition.renderer;
        // particle?.particleMesh.mesh.assignRenderer(renderer.glRenderer);
    };
    ParticleVFXItem.prototype.doCreateContent = function (composition) {
        assertExist(this.particle);
        return new ParticleSystem(this.particle, composition.getRendererOptions(), this);
    };
    ParticleVFXItem.prototype.isEnded = function (now) {
        return _super.prototype.isEnded.call(this, now) && this.destroyed;
    };
    ParticleVFXItem.prototype.getHitTestParams = function (force) {
        var _this = this;
        var _a;
        var interactParams = (_a = this.content) === null || _a === void 0 ? void 0 : _a.interaction;
        if (force || interactParams) {
            return {
                type: exports.HitTestType.custom,
                collect: function (ray) {
                    var _a;
                    return (_a = _this.content) === null || _a === void 0 ? void 0 : _a.raycast({
                        radius: (interactParams === null || interactParams === void 0 ? void 0 : interactParams.radius) || 0.4,
                        multiple: !!(interactParams === null || interactParams === void 0 ? void 0 : interactParams.multiple),
                        removeParticle: (interactParams === null || interactParams === void 0 ? void 0 : interactParams.behavior) === CLICK_BEHAVIOR_DESTROY_PARTICLE,
                        ray: ray,
                    });
                },
            };
        }
    };
    return ParticleVFXItem;
}(VFXItem));

var ParticleLoader = /** @class */ (function (_super) {
    __extends(ParticleLoader, _super);
    function ParticleLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.meshes = [];
        return _this;
    }
    ParticleLoader.precompile = function (compositions, shaderLibrary) {
        var composition = compositions[0];
        // 计算Shader编译的最大合集
        var compileOptions = {
            rotationOverLifetime: {
                x: false,
                y: false,
                z: false,
            },
            positionOverLifetime: {
                speedOverLifetime: false,
                linearX: false,
                linearY: false,
                linearZ: false,
                orbitalX: false,
                orbitalY: false,
                orbitalZ: false,
                forceCurve: false,
            },
            colorOverLifetime: {
                opacity: false,
                color: false,
            },
            sizeOverLifetime: {
                x: false,
                y: false,
            },
        };
        var defValue = {
            colorOverLifetime: {
                opacity: 1,
                color: [ValueType$1.RGBA_COLOR, [255, 255, 255, 255]],
            },
            positionOverLifetime: {
                speedOverLifetime: 1,
            },
            sizeOverLifetime: {
                x: 1,
                y: 1,
            },
        };
        var level = GPUCapability.getInstance().level;
        var pros = [];
        var items = [];
        var shaders = [];
        var maxFragmentCount = 0;
        var maxVertexCount = 0;
        composition.items.forEach(function (item) {
            if (item.type === ItemType$1.particle) {
                items.push(item);
                assignDefValue(item);
                if (level === 2) {
                    Object.keys(compileOptions).forEach(function (name) {
                        var content = compileOptions[name];
                        var target = item.content[name];
                        if (target) {
                            Object.keys(content).forEach(function (pro) {
                                // @ts-expect-error
                                if (target[pro]) {
                                    content[pro] = true;
                                    addItem(pros, name);
                                }
                            });
                        }
                    });
                }
            }
        });
        items.forEach(function (item) {
            var _a, _b;
            var options = item.content;
            if (level === 2) {
                pros.forEach(function (name) {
                    var content = compileOptions[name];
                    // @ts-expect-error
                    var target = options[name] || (options[name] = {});
                    Object.keys(content).forEach(function (pro) {
                        if (content[pro] && !target[pro]) {
                            var df = (defValue[name] && defValue[name][pro]) || 0;
                            target[pro] = isNaN(df) ? df : [ValueType$1.CONSTANT, df];
                        }
                    });
                });
                if (compileOptions.positionOverLifetime.forceCurve) {
                    // @ts-expect-error
                    options.positionOverLifetime.forceTarget = true;
                }
                if (compileOptions.rotationOverLifetime.x || compileOptions.rotationOverLifetime.y) {
                    // @ts-expect-error
                    options.rotationOverLifetime.separateAxes = true;
                }
                if (compileOptions.sizeOverLifetime.y) {
                    // @ts-expect-error
                    options.sizeOverLifetime.separateAxes = true;
                }
            }
            var _c = getParticleMeshShader(item), shader = _c.shader, fragment = _c.fragment, vertex = _c.vertex;
            shaders.push(shader);
            maxFragmentCount = Math.max(maxFragmentCount, fragment);
            maxVertexCount = Math.max(maxVertexCount, vertex);
            // TODO 此处add是否有意义？shader变量似乎没有加到this.shaders数组。
            if (item.content.trails) {
                var shader_1 = getTrailMeshShader(item.content.trails, item.content.options.maxCount, item.name);
                shader_1.vertex = createShaderWithMarcos((_a = shader_1.marcos) !== null && _a !== void 0 ? _a : [], shader_1.vertex, exports.ShaderType.vertex);
                shader_1.fragment = createShaderWithMarcos((_b = shader_1.marcos) !== null && _b !== void 0 ? _b : [], shader_1.fragment, exports.ShaderType.fragment);
                shader_1.glslVersion = level === 2 ? exports.GLSLVersion.GLSL3 : exports.GLSLVersion.GLSL1;
                shaderLibrary.addShader(shader_1);
            }
        });
        shaders.forEach(function (shader) {
            var _a, _b;
            if (level === 2) {
                modifyMaxKeyframeShader(shader, maxVertexCount, maxFragmentCount);
                shader.glslVersion = exports.GLSLVersion.GLSL3;
            }
            else {
                shader.glslVersion = exports.GLSLVersion.GLSL1;
            }
            shader.vertex = createShaderWithMarcos((_a = shader.marcos) !== null && _a !== void 0 ? _a : [], shader.vertex, exports.ShaderType.vertex);
            shader.fragment = createShaderWithMarcos((_b = shader.marcos) !== null && _b !== void 0 ? _b : [], shader.fragment, exports.ShaderType.fragment);
            shaderLibrary.addShader(shader);
        });
        if (level === 2) {
            items.forEach(function (item) {
                // @ts-expect-error
                item.content.options.meshSlots = [maxVertexCount, maxFragmentCount];
            });
        }
        return Promise.resolve();
    };
    ParticleLoader.prototype.onCompositionItemLifeBegin = function (composition, item) {
        if (item instanceof ParticleVFXItem) {
            this.add(item.content);
        }
    };
    ParticleLoader.prototype.onCompositionItemRemoved = function (composition, item) {
        if (item instanceof ParticleVFXItem) {
            if (item.content) {
                this.remove(item.content, composition.renderFrame);
            }
        }
    };
    ParticleLoader.prototype.prepareRenderFrame = function (composition, pipeline) {
        this.meshes.forEach(function (mesh) { return pipeline.addMeshToDefaultRenderPass(mesh); });
        this.meshes.length = 0;
        return false;
    };
    ParticleLoader.prototype.add = function (particle) {
        var _this = this;
        particle.meshes.forEach(function (mesh) { return addItem(_this.meshes, mesh); });
    };
    ParticleLoader.prototype.remove = function (particle, frame) {
        var _this = this;
        particle.meshes.forEach(function (mesh) {
            removeItem(_this.meshes, mesh);
            frame.removeMeshFromDefaultRenderPass(mesh);
        });
    };
    return ParticleLoader;
}(AbstractPlugin));
function assignDefValue(item) {
    if (item.type === ItemType$1.particle) {
        var options = item.content;
        if (!options.rotationOverLifetime) {
            options.rotationOverLifetime = {};
        }
        var rot = options.rotationOverLifetime;
        if (!rot.z) {
            rot.z = [ValueType$1.CONSTANT, 0];
        }
        if (!rot.separateAxes) {
            delete rot.y;
            delete rot.x;
        }
        if (!options.sizeOverLifetime) {
            options.sizeOverLifetime = {};
        }
        var size = options.sizeOverLifetime;
        if (!size.separateAxes) {
            delete size.y;
        }
        if (size.size) {
            size.x = size.size;
            delete size.size;
        }
        if (!size.x) {
            size.x = [ValueType$1.CONSTANT, 1];
        }
    }
}

var CalculateGroup = /** @class */ (function () {
    function CalculateGroup() {
        this.time = 0;
        this.nodes = [];
        this.items = [];
    }
    CalculateGroup.combineRenderData = function (data, parentData) {
        if (parentData) {
            data.transform.update();
            // @ts-expect-error color 是否 optional
            vecMulCombine(data.color, data.color, parentData.color);
            if (!parentData.visible) {
                data.visible = false;
            }
        }
        return data;
    };
    CalculateGroup.prototype.getRenderData = function (id) {
        var _a;
        return (_a = this.itemMap[id]) === null || _a === void 0 ? void 0 : _a.renderData;
    };
    // used by editor
    CalculateGroup.prototype.combineRenderData = function (data, parentData) {
        var clone = {
            transform: new Transform({
                position: data.pos,
                rotation: data.rot,
                scale: data.size,
            }),
            color: data.color.slice(),
            life: 0,
        };
        return CalculateGroup.combineRenderData(clone, parentData);
    };
    CalculateGroup.prototype.buildTree = function (refCountMap) {
        var nodeMap = {};
        var itemMap = {};
        var nodes = this.items.map(function (c) { return nodeMap[c.id] = new Node(itemMap[c.id] = c); });
        var ret = [];
        nodes.forEach(function (node) {
            var item = node.content;
            if (item.parentId) {
                var parentNode = nodeMap[item.parentId];
                if (parentNode) {
                    parentNode.children.push(node);
                    // node.content._transform.parentTransform = parentNode.content._transform;
                }
                else {
                    ret.push(node);
                }
            }
            else {
                ret.push(node);
            }
        });
        Object.values(nodeMap).forEach(function (node) {
            var _a;
            node.content.refCount = node.children.length + 1 + ((_a = refCountMap[node.content.id]) !== null && _a !== void 0 ? _a : 0);
        });
        this.itemMap = itemMap;
        this.nodes = ret;
        this.items = [];
    };
    CalculateGroup.prototype.update = function (dt) {
        var _this = this;
        var updateNode = function (node) {
            var _a;
            var item = node.content;
            var parentData = item.parentId ? _this.getRenderData(item.parentId) : undefined;
            item._transform.dispose();
            item.update(_this.time, parentData);
            (_a = node.children) === null || _a === void 0 ? void 0 : _a.forEach(updateNode);
        };
        this.time += dt / 1000;
        this.nodes.forEach(updateNode);
    };
    CalculateGroup.prototype.addItem = function (item) {
        addItem(this.items, item);
    };
    CalculateGroup.prototype.removeItemRef = function (id) {
        var _this = this;
        var removeItem = function (id) {
            var item = _this.itemMap[id];
            if (item) {
                var refCount = (--item.refCount);
                if (refCount === 0) {
                    delete _this.itemMap[id];
                    Node.removeContent(_this.nodes, item);
                    return item;
                }
            }
        };
        var item = removeItem(id);
        if (item && item.parentId) {
            removeItem(item.parentId);
        }
    };
    return CalculateGroup;
}());
var Node = /** @class */ (function () {
    function Node(content) {
        this.content = content;
        this.children = [];
    }
    Node.removeContent = function (nodes, content) {
        var opt = {
            stopped: false,
            stop: function () {
                opt.stopped = true;
            },
        };
        traverse(nodes, function (node, nodes, index, stop) {
            if (node.content === content) {
                nodes.splice(index, 1);
                stop();
            }
        }, opt);
        function traverse(nodes, func, opt) {
            for (var i = 0; i < nodes.length && !opt.stopped; i++) {
                var node = nodes[i];
                func(node, nodes, i, opt.stop);
                if (!opt.stopped) {
                    traverse(node.children, func, opt);
                }
            }
        }
    };
    return Node;
}());

var CalculateLoader = /** @class */ (function (_super) {
    __extends(CalculateLoader, _super);
    function CalculateLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.order = 0;
        return _this;
    }
    CalculateLoader.prototype.onCompositionReset = function (composition, pipeline) {
        var _a;
        var group = composition.calculateGroup;
        var refCountMap = {};
        var treeMap = composition.loaderData.treeMap = {};
        (_a = composition.items) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {
            var type = item.type, id = item.id, parentId = item.parentId;
            var calculateVFXItem = item;
            if (type === ItemType$1.null) {
                group.addItem(calculateVFXItem.createContent());
                treeMap[id] = calculateVFXItem;
            }
            else if (parentId) {
                if (!refCountMap[parentId]) {
                    refCountMap[parentId] = 1;
                }
                else {
                    refCountMap[parentId]++;
                }
            }
            if (type === VFX_ITEM_TYPE_TREE) {
                treeMap[id] = calculateVFXItem;
            }
        });
        group.buildTree(refCountMap);
    };
    CalculateLoader.prototype.onCompositionUpdate = function (composition, dt) {
        // update all calculate vfx item fist
        Object.values(composition.loaderData.treeMap).forEach(function (item) {
            if (item && item.onUpdateByLoader) {
                item.onUpdateByLoader(dt);
            }
        });
    };
    CalculateLoader.prototype.onCompositionItemLifeBegin = function (composition, item) {
        if (item.type !== ItemType$1.composition) {
            this.setItemsParentTransform(composition.items, item, composition.loaderData.treeMap);
        }
    };
    CalculateLoader.prototype.onCompositionItemRemoved = function (composition, item) {
        var _a;
        var group = composition.calculateGroup;
        delete composition.loaderData.treeMap[item.id];
        if (item.type === ItemType$1.null) {
            group.removeItemRef(item.id);
        }
        else if (item.parentId) {
            group.removeItemRef(item.parentId);
        }
        var itemsToRemove;
        if (item.type === VFX_ITEM_TYPE_TREE || item.type === ItemType$1.null) {
            var willRemove_1 = item.endBehavior === END_BEHAVIOR_DESTROY_CHILDREN$1;
            if (willRemove_1) {
                itemsToRemove = [];
            }
            var keepParent_1 = item.type === ItemType$1.null && !!group.itemMap[item.id];
            (_a = composition.items) === null || _a === void 0 ? void 0 : _a.forEach(function (calculateItem) {
                if (calculateItem.parent === item) {
                    if (!keepParent_1) {
                        setItemParent(calculateItem, undefined);
                        calculateItem.transform.parentTransform = composition.rootTransform;
                    }
                    willRemove_1 && itemsToRemove && addItem(itemsToRemove, calculateItem);
                }
            });
        }
        // @ts-expect-error
        if (!group.itemMap[item.parentId]) {
            setItemParent(item, undefined);
        }
        itemsToRemove === null || itemsToRemove === void 0 ? void 0 : itemsToRemove.forEach(function (item) { return item.dispose(); });
    };
    CalculateLoader.prototype.setItemsParentTransform = function (items, item, treeMap) {
        var _a;
        var id = item.id;
        var pt = (_a = item.composition) === null || _a === void 0 ? void 0 : _a.rootTransform;
        item.transform.parentTransform = pt ? pt : new Transform();
        if (item.type === ItemType$1.null) {
            items.forEach(function (child) {
                if (id === child.parentId && child !== item) {
                    child.transform.parentTransform = item.transform;
                    setItemParent(child, item);
                }
            });
        }
        else if (item.type === VFX_ITEM_TYPE_TREE) {
            var id_1 = item.id;
            var idWithSubfix_1 = id_1 + '^';
            items.forEach(function (child) {
                var parentId = child.parentId;
                if (parentId && item !== child) {
                    if (id_1 === parentId) {
                        setItemParent(child, item);
                    }
                    else if (parentId.indexOf(idWithSubfix_1) === 0) {
                        setItemParent(child, item, item.content.getNodeTransform(parentId.substring(idWithSubfix_1.length)));
                    }
                }
            });
        }
        var parentId = item.parentId;
        var parentItem = parentId && treeMap[getParentIdWithoutSuffix(parentId)];
        if (parentItem && parentItem.lifetimeStarted) {
            if (parentItem.type == ItemType$1.null && parentItem.content.active) {
                pt = parentItem.transform;
            }
            else if (parentItem.type === VFX_ITEM_TYPE_TREE) {
                pt = parentItem.content.getNodeTransform(parentId.substring(parentId.indexOf('^') + 1));
            }
            setItemParent(item, parentItem, pt);
        }
    };
    return CalculateLoader;
}(AbstractPlugin));
function getParentIdWithoutSuffix(id) {
    var idx = id.lastIndexOf('^');
    return idx > -1 ? id.substring(0, idx) : id;
}
function setItemParent(item, parent, parentTransform) {
    item.parent = parent;
    // @ts-expect-error
    item.transform.parentTransform = parentTransform || (parent === null || parent === void 0 ? void 0 : parent.transform);
}

var CalculateItem = /** @class */ (function (_super) {
    __extends(CalculateItem, _super);
    function CalculateItem(props, options, item) {
        var _this = _super.call(this, props, options, item) || this;
        _this.active = false;
        _this.renderData = _this.getRenderData(0, true);
        _this.id = item.id;
        return _this;
    }
    CalculateItem.prototype.initTexture = function (texture) {
        return texture;
    };
    CalculateItem.prototype.willTranslate = function () {
        return true;
    };
    CalculateItem.prototype.getRenderData = function (time, init) {
        var ret = _super.prototype.getRenderData.call(this, time, init);
        if (ret.startSize) {
            var scaling = ret.transform.scale;
            ret.transform.setScale(scaling[0] * ret.startSize[0], scaling[1] * ret.startSize[1], scaling[2] * ret.startSize[2]);
            delete ret.startSize;
        }
        ret.active = this.active;
        return ret;
    };
    CalculateItem.prototype.update = function (time, parentData) {
        this.updateTime(time);
        var data = this.getRenderData(this.time, true);
        this.renderData = CalculateGroup.combineRenderData(data, parentData);
    };
    return CalculateItem;
}(SpriteItem));

var CalculateVFXItem = /** @class */ (function (_super) {
    __extends(CalculateVFXItem, _super);
    function CalculateVFXItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._v_priority = 1;
        _this.childrenVisible = true;
        return _this;
    }
    Object.defineProperty(CalculateVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.null;
        },
        enumerable: false,
        configurable: true
    });
    CalculateVFXItem.prototype.onConstructed = function (props) {
        this.cal = props.content;
        this.relative = props.relative;
        this.onUpdateByLoader = this.onUpdate;
        this.onUpdate = noop;
    };
    CalculateVFXItem.prototype.onLifetimeBegin = function (composition, content) {
        content.active = true;
    };
    CalculateVFXItem.prototype.onItemRemoved = function (composition, content) {
    };
    CalculateVFXItem.prototype.getCurrentRenderData = function () {
        var _a;
        return (_a = this.content) === null || _a === void 0 ? void 0 : _a.renderData;
    };
    CalculateVFXItem.prototype.getHitTestParams = function (force) {
    };
    // hide its children when visible is fasle
    CalculateVFXItem.prototype.getChildrenVisible = function () {
        return this.childrenVisible;
    };
    CalculateVFXItem.prototype.setChildrenVisible = function (visible) {
        if (this.childrenVisible !== visible) {
            this.childrenVisible = !!visible;
            this.handleVisibleChanged(this.visible);
        }
    };
    CalculateVFXItem.prototype.doCreateContent = function (composition) {
        var options = composition.getRendererOptions();
        return new CalculateItem(this.cal, options, this);
    };
    CalculateVFXItem.prototype.handleVisibleChanged = function (visible) {
        if (this.content) {
            this.content.visible = visible || this.childrenVisible;
        }
    };
    return CalculateVFXItem;
}(VFXItem));

// TODO: 改名 TreeItem？
var Tree = /** @class */ (function () {
    function Tree(props, transform) {
        this.transform = transform;
        this.build(props);
    }
    Tree.prototype.getNodes = function () {
        return this.nodes;
    };
    Tree.prototype.getNodeById = function (indexOrInd) {
        var cache = this.cacheMap;
        if (!cache[indexOrInd]) {
            var index_1 = "^".concat(indexOrInd);
            // @ts-expect-error
            cache[indexOrInd] = this.allNodes.find(function (node) { return node.id === index_1; });
        }
        return cache[indexOrInd];
    };
    Tree.prototype.getNodeByName = function (name) {
        var cache = this.cacheMap;
        if (!cache[name]) {
            // @ts-expect-error
            cache[name] = this.allNodes.find(function (node) { return node.name === name; });
        }
        return cache[name];
    };
    /**
     * if node id not found,use tree.transform
     * @param indexOrInd
     */
    Tree.prototype.getNodeTransform = function (indexOrInd) {
        var node = this.getNodeById(indexOrInd);
        return node ? node.transform : this.transform;
    };
    Tree.prototype.build = function (props) {
        var _this = this;
        var topTransform = this.transform;
        var nodes = props.nodes.map(function (node, i) { return ({
            name: node.name || node.id || (i + ''),
            transform: new Transform(node.transform, topTransform),
            id: "^".concat(node.id || i),
            children: [],
            tree: _this,
        }); });
        this.cacheMap = {};
        nodes.forEach(function (node, i) {
            var children = props.nodes[i].children;
            // @ts-expect-error
            node.transform.name = node.name;
            if (children) {
                children.forEach(function (index) {
                    var child = nodes[index];
                    if (child && child !== node) {
                        if (child.transform.parentTransform !== topTransform) {
                            console.error('Node parent has been set.');
                        }
                        child.transform.parentTransform = node.transform;
                        node.children.push(child);
                    }
                });
            }
        });
        this.allNodes = nodes;
        this.nodes = props.children.map(function (i) { return nodes[i]; });
    };
    return Tree;
}());

var TreeVFXItem = /** @class */ (function (_super) {
    __extends(TreeVFXItem, _super);
    function TreeVFXItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TreeVFXItem.prototype, "type", {
        get: function () {
            return VFX_ITEM_TYPE_TREE;
        },
        enumerable: false,
        configurable: true
    });
    TreeVFXItem.prototype.onConstructed = function (props) {
        this.options = props.content.options;
        this.onUpdateByLoader = this.onUpdate;
        this.onUpdate = function () { };
    };
    // FIXME: type
    TreeVFXItem.prototype.onItemUpdate = function (dt, lifetime) {
    };
    TreeVFXItem.prototype.doCreateContent = function () {
        return new Tree(this.options.tree, this.transform);
    };
    return TreeVFXItem;
}(VFXItem));

function cloneMeshWithShader(mesh, shader) {
    var mtlOptions = __assign$1(__assign$1({}, mesh.material.props), { shader: shader });
    var material = mesh.material.clone(mtlOptions);
    material.blending = false;
    material.depthTest = false;
    material.culling = false;
    var ret = Mesh.create({
        geometry: mesh.geometries[0],
        material: material,
    });
    return ret;
}
function cloneSpriteMesh(spriteMesh, pluginSystem, opts) {
    var plugin = pluginSystem.plugins.find(function (p) { return p.name === 'sprite'; });
    var shader = plugin.spriteMeshShaderFromFilter({ mesh: { fragment: opts.fragment } }, {
        ignoreBlend: true,
    });
    return cloneMeshWithShader(spriteMesh, shader);
}

/****************************************************************************************/
/** 高斯滤镜，分3个 pass 组成，分别是高斯 H、高斯 V 和最终合并两个 pass 结果的 copyPass **********/
/****************************************************************************************/
var GaussianPass = /** @class */ (function (_super) {
    __extends(GaussianPass, _super);
    function GaussianPass(type, uTexStep, pluginSystem, fragShader, option) {
        var _this = _super.call(this, option) || this;
        _this.uTexStep = uTexStep;
        _this.pluginSystem = pluginSystem;
        _this.fragShader = fragShader;
        _this.type = type;
        return _this;
    }
    GaussianPass.prototype.configure = function (renderer) {
        this.prePassTexture = renderer.getFrameBuffer().getColorTextures()[0] ? renderer.getFrameBuffer().getColorTextures()[0] : renderer.renderingData.currentFrame.transparentTexture;
        if (this.type === 'H') {
            this.preDefaultPassAttachment.texture = this.prePassTexture;
        }
        this.preDefaultPassTexture = this.preDefaultPassAttachment.texture;
        renderer.setFrameBuffer(this.frameBuffer);
    };
    GaussianPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[0].material.setTexture('uFilterSource', this.preDefaultPassTexture);
        this.meshes[0].material.setVector2('uFilterSourceSize', getTextureSize(this.preDefaultPassTexture));
        this.meshes[1].material.setVector2('uTexStep', this.uTexStep);
        this.meshes[1].material.setTexture('uBlurSource', this.uBlurSource ? this.uBlurSource : this.prePassTexture);
        this.meshes[1].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[1].material.setTexture('uSamplerPre', this.preDefaultPassTexture);
        this.meshes[1].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        var renderQueue = [this.meshes[0], cloneSpriteMesh(this.meshes[1], this.pluginSystem, { fragment: this.fragShader })];
        renderer.renderMeshes(renderQueue);
    };
    return GaussianPass;
}(RenderPass));
/**
 * 滤镜元素的最终渲染 Pass
 */
var CopyPass = /** @class */ (function (_super) {
    __extends(CopyPass, _super);
    function CopyPass(options, preDefaultPassAttachment) {
        var _this = _super.call(this, options) || this;
        if (preDefaultPassAttachment) {
            _this.preDefaultPassAttachment = preDefaultPassAttachment;
        }
        return _this;
    }
    CopyPass.prototype.configure = function (renderer) {
        this.prePassTexture = renderer.getFrameBuffer().getColorTextures()[0];
        if (!this.preDefaultPassAttachment) {
            this.preDefaultPassAttachment = new RenderTargetHandle({});
            this.preDefaultPassAttachment.texture = this.prePassTexture;
        }
        renderer.setFrameBuffer(this.frameBuffer);
    };
    CopyPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[0].material.setTexture('uFilterSource', this.preDefaultPassAttachment.texture);
        this.meshes[0].material.setVector2('uFilterSourceSize', getTextureSize(this.preDefaultPassAttachment.texture));
        this.meshes[1].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[1].material.setTexture('uSamplerPre', this.preDefaultPassAttachment.texture);
        this.meshes[1].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        var renderQueue = [this.meshes[0], this.meshes[1]];
        renderer.renderMeshes(renderQueue);
    };
    return CopyPass;
}(RenderPass));
function createGaussianShader(filter) {
    var radius = filter.radius;
    var f = gaussianFilter({ radius: radius });
    return [
        {
            fragment: copyFrag,
            shaderCacheId: "gaussian-".concat(f.step),
        },
        {
            fragment: f.shader,
            ignoreBlend: true,
        },
    ];
}
function registerGaussianFilter(filter, composition) {
    var radius = filter.radius;
    var level = GPUCapability.getInstance().level;
    var _a = gaussianFilter({ radius: radius }), downSample = _a.downSample, step = _a.step, shader = _a.shader;
    var texWidth = Math.round(composition.width / downSample);
    var texHeight = Math.round(composition.height / downSample);
    if (level === 1) {
        texHeight = nearestPowerOfTwo(texHeight);
        texWidth = nearestPowerOfTwo(texWidth);
    }
    var viewport = [0, 0, texWidth, texHeight];
    var gaussianTextureV = composition.renderFrame.passTextureCache.requestColorAttachmentTexture({
        minFilter: glContext.LINEAR,
        magFilter: glContext.LINEAR,
        name: 'gaussianV',
        width: texWidth,
        height: texHeight,
    });
    var gaussianTextureH = composition.renderFrame.passTextureCache.requestColorAttachmentTexture({
        minFilter: glContext.LINEAR,
        magFilter: glContext.LINEAR,
        name: 'gaussianH',
        width: texWidth,
        height: texHeight,
    });
    // 使用一个attachment对象保存滤镜前的pass渲染结果，传递到后续滤镜pass使用
    var preDefaultPassColorAttachment = new RenderTargetHandle({});
    var gaussianHPass = new GaussianPass('H', [0, step], composition.pluginSystem, shader, {
        name: 'gaussianH',
        viewport: viewport,
        attachments: [{ texture: gaussianTextureH }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    gaussianHPass.preDefaultPassAttachment = preDefaultPassColorAttachment;
    var gaussianVPass = new GaussianPass('V', [step, 0], composition.pluginSystem, shader, {
        name: 'gaussianV',
        viewport: viewport,
        attachments: [{ texture: gaussianTextureV }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    gaussianVPass.preDefaultPassAttachment = preDefaultPassColorAttachment;
    var texturefilter = level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var copyPass = new CopyPass({
        name: 'gaussianCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: texturefilter, magFilter: texturefilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    }, preDefaultPassColorAttachment);
    copyPass.preDefaultPassAttachment = preDefaultPassColorAttachment;
    return {
        mesh: {
            fragment: copyFrag,
            shaderCacheId: "gaussian-".concat(step),
            uniformValues: {
                uFrameSource: gaussianTextureV,
                uTexSize: [texWidth, texHeight],
            },
            materialStates: {
                blending: false,
                culling: false,
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [gaussianHPass, gaussianVPass, copyPass],
        },
    };
}
function gaussianFilter(opts) {
    var downSample = opts.radius <= 3 ? 1 : 2;
    var radius = opts.radius / downSample;
    var maxStep = opts.maxStep || 4;
    while (radius > 10 && downSample < maxStep) {
        downSample *= 2;
        radius = opts.radius / downSample;
    }
    var step = 1 + (opts.radius % downSample) / downSample / downSample;
    radius = Math.floor(radius);
    var floats = getGaussianParams(radius);
    var steps = [];
    for (var i = -radius; i <= radius; i++) {
        var weight = floats[i + radius];
        steps.push("color += texture2D(uBlurSource,getTexCoord(".concat(i.toFixed(1), ")) * ").concat(weight, ";"));
    }
    var ret = {
        shader: "\n  uniform sampler2D uBlurSource;\n  uniform vec2 uTexSize;\n  uniform vec2 uTexStep;\n  #define getTexCoord(i) coord + uTexStep/uTexSize * i\n  vec4 filterMain(vec2 coord,sampler2D tex){\n    vec4 color = vec4(0.);\n    vec2 texCoord;\n    ".concat(steps.join('\n'), "\n\n    return color;\n  }\n  "),
        step: step,
        downSample: downSample,
        radius: radius,
    };
    return ret;
}
function calculateSigma(x, sig) {
    return Math.exp(-(x * x) / (2 * sig * sig)) / Math.sqrt(2 * Math.PI) / sig;
}
function getGaussianParams(radius) {
    var sigma = (radius + 1) / 3.329;
    var nums = [];
    for (var i = -radius; i <= radius; i++) {
        nums.push(calculateSigma(i, sigma));
    }
    return nums;
}

function createDistortionShader(filter) {
    var _a = filter, period = _a.period, waveMovement = _a.waveMovement, strength = _a.strength;
    return [
        {
            fragment: distortionFrag,
            shaderCacheId: 'distortion',
        },
        {
            fragment: distortionFrag,
            vertex: distortionVert,
            isParticle: true,
            uniforms: [period, waveMovement, strength],
        },
    ];
}
function registerDistortionFilter(filter) {
    var _a = filter, _b = _a.center, center = _b === void 0 ? [0.5, 0.5] : _b, _c = _a.direction, direction = _c === void 0 ? [1, 0] : _c, period = _a.period, waveMovement = _a.waveMovement, strength = _a.strength;
    var dir = vecNormalize(direction);
    var uWaveParams = [center[0], center[1], dir[0], dir[1]];
    var uPeriodValue = createValueGetter(period);
    var uMovementValue = createValueGetter(waveMovement);
    var uStrengthValue = createValueGetter(strength);
    var PI2 = Math.PI * 2;
    var textureFilter = GPUCapability.getInstance().level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var distortionPass = new CopyPass({
        name: 'distortionCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: textureFilter, magFilter: textureFilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    return {
        particle: {
            fragment: distortionFrag,
            vertex: distortionVert,
            uniforms: {
                uPeriodValue: uPeriodValue,
                uMovementValue: uMovementValue,
                uStrengthValue: uStrengthValue,
            },
            uniformValues: {
                uWaveParams: uWaveParams,
            },
        },
        mesh: {
            shaderCacheId: 'distortion',
            fragment: distortionFrag,
            materialStates: {
                blending: false,
                culling: false,
            },
            variables: {
                vWaveParams: function (life) {
                    return [
                        uPeriodValue.getValue(life) * PI2,
                        uMovementValue.getValue(life) * PI2,
                        uStrengthValue.getValue(life),
                        0,
                    ];
                },
            },
            uniformValues: {
                uWaveParams: uWaveParams,
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [distortionPass],
        },
    };
}

/******************************************************************************************/
/** Bloom 滤镜，分4个 pass 组成，分别是阈值 Pass、高斯 H、高斯 V 和最终合并 pass 结果的 copyPass ***/
/******************************************************************************************/
function createBloomShader(filter) {
    var _a = filter.radius, radius = _a === void 0 ? 30 : _a;
    var gaussian = gaussianFilter({ radius: radius });
    return [
        {
            fragment: bloomMixVert,
            shaderCacheId: "bloom-".concat(gaussian.step),
        },
        { fragment: bloomThresholdVert, ignoreBlend: true },
        { fragment: gaussian.shader, ignoreBlend: true },
    ];
}
function registerBloomFilter(filter, composition) {
    var _a = filter, _b = _a.radius, radius = _b === void 0 ? 30 : _b, _c = _a.bloomAddon, bloomAddon = _c === void 0 ? 0.4 : _c, _d = _a.colorAddon, colorAddon = _d === void 0 ? 1 : _d, _e = _a.colorThreshold, colorThreshold = _e === void 0 ? [255, 255, 255] : _e;
    var level = GPUCapability.getInstance().level;
    var gaussian = gaussianFilter({ radius: radius });
    var width = Math.round(composition.width / gaussian.downSample);
    var height = Math.round(composition.width / gaussian.downSample);
    if (level === 1) {
        width = nearestPowerOfTwo(width);
        height = nearestPowerOfTwo(height);
    }
    var viewport = [0, 0, width, height];
    // TODO 这里设置的width和height没用，会被viewport覆盖
    var blurTarget = composition.renderFrame.passTextureCache.requestColorAttachmentTexture({
        format: glContext.RGBA,
        magFilter: glContext.LINEAR,
        minFilter: glContext.LINEAR,
        name: 'gaussianV',
        width: width,
        height: height,
    });
    var blurInterMedia = composition.renderFrame.passTextureCache.requestColorAttachmentTexture({
        format: glContext.RGBA,
        magFilter: glContext.LINEAR,
        minFilter: glContext.LINEAR,
        name: 'gaussianH',
        width: width,
        height: height,
    });
    var bloomAddOnGetter = createValueGetter(bloomAddon);
    var colorAddOnGetter = createValueGetter(colorAddon);
    var preDefaultPassColorAttachment = new RenderTargetHandle();
    var thresholdPass = new ThresholdPass({
        name: 'threshold',
        attachments: [{ texture: blurTarget }],
        viewport: viewport,
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    thresholdPass.pluginSystem = composition.pluginSystem;
    thresholdPass.fragShader = bloomThresholdVert;
    thresholdPass.preDefaultPassAttachment = preDefaultPassColorAttachment;
    var gaussianHPass = new BloomGaussianPass('H', [gaussian.step, 0], composition.pluginSystem, gaussian.shader, {
        name: 'gaussianH',
        viewport: viewport,
        attachments: [{ texture: blurInterMedia }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    }, blurTarget);
    gaussianHPass.preDefaultPassAttachment = preDefaultPassColorAttachment;
    var gaussianVPass = new BloomGaussianPass('V', [0, gaussian.step], composition.pluginSystem, gaussian.shader, {
        name: 'gaussianV',
        viewport: viewport,
        attachments: [{ texture: blurTarget }],
    }, blurInterMedia);
    gaussianVPass.preDefaultPassAttachment = preDefaultPassColorAttachment;
    var textureFilter = level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var copyPass = new BloomCopyPass({
        name: 'bloomCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: textureFilter, magFilter: textureFilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    }, preDefaultPassColorAttachment);
    return {
        mesh: {
            name: "bloom-".concat(gaussian.step),
            fragment: bloomMixVert,
            shaderCacheId: "bloom-".concat(gaussian.step),
            variables: {
                uBloomParams: function (life) { return [
                    bloomAddOnGetter.getValue(life),
                    colorAddOnGetter.getValue(life),
                    0,
                    1,
                ]; },
            },
            uniformValues: {
                uColorThreshold: [(colorThreshold[0] / 255) || 1.1, (colorThreshold[1] / 255) || 1.1, (colorThreshold[2] / 255) || 1.1, 0],
                uBloomBlur: blurTarget,
            },
            materialStates: {
                blending: false,
                culling: false,
            },
        },
        onItemRemoved: function () {
            blurTarget.dispose();
            blurInterMedia.dispose();
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [thresholdPass, gaussianHPass, gaussianVPass, copyPass],
        },
    };
}
var ThresholdPass = /** @class */ (function (_super) {
    __extends(ThresholdPass, _super);
    function ThresholdPass(option) {
        return _super.call(this, option) || this;
    }
    ThresholdPass.prototype.configure = function (renderer) {
        var currentFrameBuffer = renderer.getFrameBuffer();
        // 第一个Pass，可能前一个pass没有FBO需要判断一下。
        this.preDefaultPassAttachment.texture = currentFrameBuffer ? currentFrameBuffer.getColorTextures()[0] : renderer.renderingData.currentFrame.transparentTexture;
        renderer.setFrameBuffer(this.frameBuffer);
    };
    ThresholdPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[1].material.setTexture('uSamplerPre', this.preDefaultPassAttachment.texture);
        this.meshes[1].material.setVector2('uTexSize', getTextureSize(this.preDefaultPassAttachment.texture));
        var renderQueue = [cloneSpriteMesh(this.meshes[1], this.pluginSystem, { fragment: this.fragShader })];
        renderer.renderMeshes(renderQueue);
    };
    return ThresholdPass;
}(RenderPass));
var BloomGaussianPass = /** @class */ (function (_super) {
    __extends(BloomGaussianPass, _super);
    function BloomGaussianPass(type, uTexStep, pluginSystem, fragShader, option, uBlurSource) {
        var _this = _super.call(this, option) || this;
        _this.uTexStep = uTexStep;
        _this.pluginSystem = pluginSystem;
        _this.fragShader = fragShader;
        _this.type = type;
        if (uBlurSource) {
            _this.uBlurSource = uBlurSource;
        }
        return _this;
    }
    BloomGaussianPass.prototype.configure = function (renderer) {
        this.prePassTexture = renderer.getFrameBuffer().getColorTextures()[0];
        this.preDefaultPassTexture = this.preDefaultPassAttachment.texture;
        renderer.setFrameBuffer(this.frameBuffer);
        if (!this.uBlurSource) {
            this.uBlurSource = this.prePassTexture;
        }
    };
    BloomGaussianPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[1].material.setVector2('uTexStep', this.uTexStep);
        this.meshes[1].material.setTexture('uBlurSource', this.uBlurSource);
        this.meshes[1].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[1].material.setTexture('uSamplerPre', this.preDefaultPassTexture);
        this.meshes[1].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        this.meshes[1].material.setVector2('uTexSize', getTextureSize(this.uBlurSource));
        var renderQueue = [cloneSpriteMesh(this.meshes[1], this.pluginSystem, { fragment: this.fragShader })];
        renderer.renderMeshes(renderQueue);
    };
    return BloomGaussianPass;
}(RenderPass));
/**
 * Bloom 滤镜元素的最终渲染 Pass
 */
var BloomCopyPass = /** @class */ (function (_super) {
    __extends(BloomCopyPass, _super);
    function BloomCopyPass(options, preDefaultPassAttachment) {
        var _this = _super.call(this, options) || this;
        _this.preDefaultPassAttachment = preDefaultPassAttachment;
        return _this;
    }
    BloomCopyPass.prototype.configure = function (renderer) {
        this.prePassTexture = renderer.getFrameBuffer().getColorTextures()[0];
        renderer.setFrameBuffer(this.frameBuffer);
    };
    BloomCopyPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[0].material.setTexture('uFilterSource', this.preDefaultPassAttachment.texture);
        this.meshes[0].material.setVector2('uFilterSourceSize', getTextureSize(this.preDefaultPassAttachment.texture));
        this.meshes[1].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[1].material.setTexture('uSamplerPre', this.preDefaultPassAttachment.texture);
        this.meshes[1].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        this.meshes[1].material.setVector2('uTexSize', getTextureSize(this.preDefaultPassAttachment.texture));
        var renderQueue = [this.meshes[0], this.meshes[1]];
        renderer.renderMeshes(renderQueue);
    };
    return BloomCopyPass;
}(RenderPass));

var DelayPass = /** @class */ (function (_super) {
    __extends(DelayPass, _super);
    function DelayPass(options) {
        return _super.call(this, options) || this;
    }
    DelayPass.prototype.configure = function (renderer) {
        this.prePassTexture = renderer.getFrameBuffer().getColorTextures()[0];
        renderer.setFrameBuffer(this.frameBuffer);
    };
    DelayPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[0].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[0].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        this.meshes[1].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[1].material.setTexture('uSamplerPre', this.prePassTexture);
        this.meshes[1].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        var renderQueue = [this.meshes[0], this.meshes[1]];
        renderer.renderMeshes(renderQueue);
    };
    return DelayPass;
}(RenderPass));
function createDelayShader() {
    return [{
            fragment: delayFrag,
            shaderCacheId: 'delay',
        }];
}
function registerDelayFilter(filter, composition) {
    var tex = Texture.create({
        sourceType: exports.TextureSourceType.framebuffer,
    });
    // FIXME: renderer 在 MarsComposition 下
    var renderer = composition.renderer;
    var filterParams = [0, 0.96, 0, 0];
    var textureFilter = GPUCapability.getInstance().level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var delayPass = new DelayPass({
        name: 'delayCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: textureFilter, magFilter: textureFilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    return {
        mesh: {
            fragment: delayFrag,
            shaderCacheId: 'delay',
            uniformValues: {
                uLastSource: tex,
            },
            variables: {
                uParams: function () { return filterParams; },
            },
            materialStates: {
                blending: true,
                blendFunction: [glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA, glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA],
                depthTest: false,
                culling: false,
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [delayPass],
        },
        onItemRemoved: function () {
            tex.dispose();
        },
        renderPassDelegate: {
            didEndRenderPass: function (pass) {
                // @ts-expect-error
                renderer.extension.copyTexture(pass.attachments[0].texture, tex);
                filterParams[0] = 2;
            },
        },
    };
}

function createAlphaFrameShader() {
    return [
        { fragment: alphaFrameFrag, shaderCacheId: 'alpha-frame' },
        { fragment: alphaFrameFrag, isParticle: true },
    ];
}
function registerAlphaFrameFilter(filter) {
    var _a = filter, _b = _a.colorRange, colorRange = _b === void 0 ? [0.5, 1] : _b, _c = _a.alphaRange, alphaRange = _c === void 0 ? [0, 0.5] : _c;
    var uTexRange = [alphaRange[0], alphaRange[1] - alphaRange[0], colorRange[0], colorRange[1] - colorRange[0]];
    var textureFilter = GPUCapability.getInstance().level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var alphaFramePass = new CopyPass({
        name: 'alphaFrameCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: textureFilter, magFilter: textureFilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    return {
        particle: {
            fragment: alphaFrameFrag,
            uniformValues: {
                uTexRange: uTexRange,
            },
        },
        mesh: {
            fragment: alphaFrameFrag,
            shaderCacheId: 'alpha-frame',
            materialStates: {
                blending: false,
            },
            uniformValues: {
                uTexRange: uTexRange,
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [alphaFramePass],
        },
    };
}

function createAlphaMaskShader() {
    return [{
            fragment: alphaMaskFrag,
            shaderCacheId: 'alpha-mask',
        }];
}
function registerAlphaMaskFilter(filter) {
    var _a = filter, xOpacity = _a.xOpacity, yOpacity = _a.yOpacity;
    var uAlphaXSample = createSampler(xOpacity);
    var uAlphaYSample = createSampler(yOpacity, true);
    var textureFilter = GPUCapability.getInstance().level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var alphaMaskPass = new CopyPass({
        name: 'alphaMaskCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: textureFilter, magFilter: textureFilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    return {
        mesh: {
            fragment: alphaMaskFrag,
            shaderCacheId: 'alpha-mask',
            materialStates: {
                blending: false,
                depthTest: false,
                culling: false,
            },
            uniformValues: {
                uAlphaXSample: uAlphaXSample,
                uAlphaYSample: uAlphaYSample,
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [alphaMaskPass],
        },
    };
}
function createSampler(value, reverse) {
    var exp = createValueGetter(value || 1);
    var width = value ? 256 : 1;
    var data = new Uint8Array(width);
    for (var i = 0; i < width; i++) {
        var p = i / (width - 1);
        data[i] = Math.round(exp.getValue((reverse ? 1 - p : p)) * 255);
    }
    return Texture.createWithData({ width: width, height: 1, data: data }, { format: glContext.LUMINANCE });
}

var tmpScale = [1, 1, 1];
/**
 * 合成的相机对象，采用透视投影
 */
var Camera = /** @class */ (function () {
    /**
     *
     * @param name - 相机名称
     * @param options
     */
    function Camera(name, options) {
        if (options === void 0) { options = {}; }
        this.name = name;
        this.viewMatrix = mat4create();
        this.projectionMatrix = mat4create();
        this.viewProjectionMatrix = mat4create();
        this.inverseViewMatrix = mat4create();
        this.dirty = true;
        var _a = options.near, near = _a === void 0 ? 0.1 : _a, _b = options.far, far = _b === void 0 ? 20 : _b, _c = options.fov, fov = _c === void 0 ? 60 : _c, _d = options.aspect, aspect = _d === void 0 ? 1 : _d, _e = options.clipMode, clipMode = _e === void 0 ? CameraClipMode$1.portrait : _e, _f = options.position, position = _f === void 0 ? [0, 0, 8] : _f, _g = options.rotation, rotation = _g === void 0 ? [0, 0, 0] : _g;
        this.options = { near: near, far: far, fov: fov, aspect: aspect, clipMode: clipMode, position: position, rotation: rotation };
        this.dirty = true;
        this.updateMatrix();
    }
    Object.defineProperty(Camera.prototype, "near", {
        get: function () {
            return this.options.near;
        },
        /**
         * 设置相机近平面
         * @param near
         */
        set: function (near) {
            if (this.options.near !== near) {
                this.options.near = near;
                this.dirty = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "far", {
        get: function () {
            return this.options.far;
        },
        /**
         * 设置相机远平面
         * @param far
         */
        set: function (far) {
            if (this.options.far !== far) {
                this.options.far = far;
                this.dirty = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "fov", {
        get: function () {
            return this.options.fov;
        },
        /**
         * 设置相机视锥体垂直视野角度
         * @param fov
         */
        set: function (fov) {
            if (this.options.fov !== fov) {
                this.options.fov = fov;
                this.dirty = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "aspect", {
        get: function () {
            return this.options.aspect;
        },
        /**
         * 设置相机视锥体的长宽比
         * @param aspect
         */
        set: function (aspect) {
            if (this.options.aspect !== aspect) {
                this.options.aspect = aspect;
                this.dirty = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "clipMode", {
        get: function () {
            return this.options.clipMode;
        },
        /**
         * 相机的裁剪模式
         * @param clipMode
         */
        set: function (clipMode) {
            if (clipMode !== undefined && this.options.clipMode !== clipMode) {
                this.options.clipMode = clipMode;
                this.dirty = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "position", {
        get: function () {
            return __spreadArray([], __read$1(this.options.position), false);
        },
        /**
         * 设置相机的位置
         * @param value
         */
        set: function (value) {
            var _this = this;
            value.map(function (val, index) {
                if (_this.options.position[index] !== val) {
                    _this.options.position[index] = val;
                    _this.dirty = true;
                }
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "rotation", {
        get: function () {
            return __spreadArray([], __read$1(this.options.rotation), false);
        },
        /**
         * 设置相机的旋转角度
         * @param value
         */
        set: function (value) {
            var _this = this;
            value.map(function (val, index) {
                if (_this.options.rotation[index] !== val) {
                    _this.options.rotation[index] = val;
                    _this.dirty = true;
                    _this.options.quat = undefined;
                }
            });
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取相机的视图变换矩阵
     * @return
     */
    Camera.prototype.getViewMatrix = function () {
        this.updateMatrix();
        return deepClone(this.viewMatrix);
    };
    /**
     * 获取视图变换的逆矩阵
     */
    Camera.prototype.getInverseViewMatrix = function () {
        this.updateMatrix();
        return deepClone(this.inverseViewMatrix);
    };
    /**
     * 获取相机的投影矩阵
     * @return
     */
    Camera.prototype.getProjectionMatrix = function () {
        this.updateMatrix();
        return deepClone(this.projectionMatrix);
    };
    /**
     * 获取相机投影矩阵的逆矩阵
     * @return
     */
    Camera.prototype.getInverseProjectionMatrix = function () {
        this.updateMatrix();
        return deepClone(this.inverseProjectionMatrix);
    };
    /**
     * 获取相机的 VP 矩阵
     * @return
     */
    Camera.prototype.getViewProjectionMatrix = function () {
        this.updateMatrix();
        return deepClone(this.viewProjectionMatrix);
    };
    /**
     * 获取相机 VP 矩阵的逆矩阵
     * @return
     */
    Camera.prototype.getInverseViewProjectionMatrix = function () {
        this.updateMatrix();
        if (!this.inverseViewProjectionMatrix) {
            this.inverseViewProjectionMatrix = mat4invert(mat4create(), this.viewProjectionMatrix);
        }
        return deepClone(this.inverseViewProjectionMatrix);
    };
    /**
     * 根据相机的视图投影矩阵对指定模型矩阵做变换
     * @param out - 结果矩阵
     * @param model - 模型变换矩阵
     */
    Camera.prototype.getModelViewProjection = function (out, model) {
        return mat4multiply(out, this.viewProjectionMatrix, model);
    };
    /**
     * 设置相机的旋转四元数
     * @param value - 旋转四元数
     */
    Camera.prototype.setQuat = function (value) {
        var _this = this;
        if (this.options.quat === undefined) {
            this.options.quat = value;
            this.dirty = true;
        }
        else {
            var quat_1 = this.options.quat;
            value.map(function (val, index) {
                if (quat_1[index] !== val) {
                    quat_1[index] = val;
                    _this.dirty = true;
                }
            });
        }
        if (this.dirty) {
            this.setRotationByQuat(value);
        }
    };
    /**
     * 获取相机旋转对应的四元数
     * @returns
     */
    Camera.prototype.getQuat = function () {
        var quat = this.options.quat;
        if (quat === undefined) {
            quat = [0, 0, 0, 1];
            var rotation = this.options.rotation;
            if (rotation) {
                quatFromRotation(quat, rotation[0], rotation[1], rotation[2]);
            }
            this.options.quat = quat;
        }
        return quat;
    };
    /**
     * 获取相机内部的 options
     * @returns 相机 options
     */
    Camera.prototype.getOptions = function () {
        return this.options;
    };
    /**
     * 复制指定相机元素的属性到当前相机
     * @param camera
     */
    Camera.prototype.copy = function (camera) {
        var near = camera.near, far = camera.far, fov = camera.fov, clipMode = camera.clipMode, aspect = camera.aspect, position = camera.position, rotation = camera.rotation;
        this.near = near;
        this.far = far;
        this.fov = fov;
        this.clipMode = clipMode;
        this.aspect = aspect;
        this.position = position;
        this.rotation = rotation;
        this.updateMatrix();
    };
    /**
     * 更新相机相关的矩阵，获取矩阵前会自动调用
     */
    Camera.prototype.updateMatrix = function () {
        if (this.dirty) {
            var _a = this.options, fov = _a.fov, aspect = _a.aspect, near = _a.near, far = _a.far, clipMode = _a.clipMode, position = _a.position;
            mat4perspective(this.projectionMatrix, fov, aspect, near, far, clipMode === CameraClipMode$1.portrait);
            mat4fromRotationTranslationScale(this.inverseViewMatrix, this.getQuat(), position, tmpScale);
            mat4invert(this.viewMatrix, this.inverseViewMatrix);
            mat4multiply(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix);
            this.inverseViewProjectionMatrix = null;
            this.dirty = false;
        }
    };
    Camera.prototype.setRotationByQuat = function (quat) {
        this.options.rotation = Transform.getRotation([], quat);
    };
    return Camera;
}());

function createCameraMoveShader() {
    return [
        {
            vertex: cameraMoveVert,
            fragment: copyFrag,
            shaderCacheId: 'camera-move',
        },
    ];
}
function registerCameraMoveFilter(filter, composition) {
    var _a = filter.position, position = _a === void 0 ? [0, 0, 0] : _a;
    var params = position;
    if (Number.isFinite(position[0]) && Number.isFinite(position[1])) {
        params = [ValueType$1.CONSTANT_VEC3, position];
    }
    var pos = createValueGetter(params);
    var camera = new Camera('camera_move');
    var cameraPos = [0, 0, 0];
    var textureFilter = GPUCapability.getInstance().level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var cameraPass = new CopyPass({
        name: 'cameraCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: textureFilter, magFilter: textureFilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    return {
        mesh: {
            vertex: cameraMoveVert,
            fragment: copyFrag,
            shaderCacheId: 'camera-move',
            materialStates: {
                blending: false,
                depthTest: false,
                culling: false,
            },
            variables: {
                uMoveCameraViewPro: function (p) {
                    camera.copy(composition.camera);
                    var trans = pos.getValue(p);
                    vecAdd(cameraPos, composition.camera.position, [-trans[0], -trans[1], -trans[2]]);
                    camera.position = cameraPos;
                    return camera.getViewProjectionMatrix();
                },
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [cameraPass],
        },
    };
}

function createLumShader() {
    return [{ fragment: copyFrag }];
}
function registerLumFilter() {
    var texturefilter = GPUCapability.getInstance().level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var lumCopyPass = new CopyPass({
        name: 'lumCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: texturefilter, magFilter: texturefilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    return {
        mesh: {
            fragment: copyFrag,
            uniformValues: {
                uFilterParams: [1, 0, 0, 0],
            },
            materialStates: {
                blending: false,
                depthTest: false,
                culling: false,
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
        },
        prePasses: [lumCopyPass],
        renderPassDelegate: {},
    };
}

var filters = {
    lum: [registerLumFilter, createLumShader],
    // 透明视频
    alphaFrame: [registerAlphaFrameFilter, createAlphaFrameShader],
    // 移动镜头
    cameraMove: [registerCameraMoveFilter, createCameraMoveShader],
    // 渐变滤镜
    alphaMask: [registerAlphaMaskFilter, createAlphaMaskShader],
    // 扭曲滤镜
    distortion: [registerDistortionFilter, createDistortionShader],
    // 发光
    bloom: [registerBloomFilter, createBloomShader],
    // 高斯模糊
    gaussian: [registerGaussianFilter, createGaussianShader],
    // 动作延迟
    delay: [registerDelayFilter, createDelayShader],
};

/*!
 * Name: @ali/specification
 * Description: Mars JSON Specification
 * Author: Ant Group CO., Ltd.
 * Version: v2.0.0-alpha.4
 */

/*********************************************/
/*               元素属性参数类型               */
/*********************************************/
/**
 * 渲染等级
 */
var RenderLevel;
(function (RenderLevel) {
    RenderLevel["S"] = "S";
    RenderLevel["APlus"] = "A+";
    RenderLevel["A"] = "A";
    RenderLevel["BPlus"] = "B+";
    RenderLevel["B"] = "B";
})(RenderLevel || (RenderLevel = {}));
/**
 * 混合模式
 */
var BlendingMode;
(function (BlendingMode) {
    /**
     * 普通混合模式
     */
    BlendingMode[BlendingMode["ALPHA"] = 0] = "ALPHA";
    /**
     * 叠加混合模式
     */
    BlendingMode[BlendingMode["ADD"] = 1] = "ADD";
    /**
     * 相乘混合模式
     */
    BlendingMode[BlendingMode["MULTIPLY"] = 2] = "MULTIPLY";
    /**
     * 亮度混合模式
     */
    BlendingMode[BlendingMode["BRIGHTNESS"] = 3] = "BRIGHTNESS";
    /**
     * 减色混合模式
     */
    BlendingMode[BlendingMode["SUBTRACTION"] = 4] = "SUBTRACTION";
    /**
     * 强光混合模式
     */
    BlendingMode[BlendingMode["STRONG_LIGHT"] = 5] = "STRONG_LIGHT";
    /**
     * 弱光混合模式
     */
    BlendingMode[BlendingMode["WEAK_LIGHT"] = 6] = "WEAK_LIGHT";
    /**
     * 亮度叠加混合模式
     */
    BlendingMode[BlendingMode["SUPERPOSITION"] = 7] = "SUPERPOSITION";
})(BlendingMode || (BlendingMode = {}));
/**
 * 单双面模式
 */
var SideMode;
(function (SideMode) {
    /**
     * 双面模式
     */
    SideMode[SideMode["DOUBLE"] = 1032] = "DOUBLE";
    /**
     * 正面模式
     */
    SideMode[SideMode["FRONT"] = 1028] = "FRONT";
    /**
     * 背面模式
     */
    SideMode[SideMode["BACK"] = 1029] = "BACK";
})(SideMode || (SideMode = {}));
/**
 * 蒙版模式
 */
var MaskMode;
(function (MaskMode) {
    /**
     * 无蒙版
     */
    MaskMode[MaskMode["NONE"] = 0] = "NONE";
    /**
     * 蒙版
     */
    MaskMode[MaskMode["MASK"] = 1] = "MASK";
    /**
     * 被遮挡
     */
    MaskMode[MaskMode["OBSCURED"] = 2] = "OBSCURED";
    /**
     * 被反向遮挡
     */
    MaskMode[MaskMode["REVERSE_OBSCURED"] = 3] = "REVERSE_OBSCURED";
})(MaskMode || (MaskMode = {}));
/**
 * 发射器形状
 */
var ShapeType;
(function (ShapeType) {
    /**
     * 没有类型
     */
    ShapeType[ShapeType["NONE"] = 0] = "NONE";
    /**
     * 圆球
     */
    ShapeType[ShapeType["SPHERE"] = 1] = "SPHERE";
    /**
     * 圆锥
     */
    ShapeType[ShapeType["CONE"] = 2] = "CONE";
    /**
     * 半球
     */
    ShapeType[ShapeType["HEMISPHERE"] = 3] = "HEMISPHERE";
    /**
     * 圆
     */
    ShapeType[ShapeType["CIRCLE"] = 4] = "CIRCLE";
    /**
     * 圆环
     */
    ShapeType[ShapeType["DONUT"] = 5] = "DONUT";
    /**
     * 矩形
     */
    ShapeType[ShapeType["RECTANGLE"] = 6] = "RECTANGLE";
    /**
     * 矩形框
     */
    ShapeType[ShapeType["RECTANGLE_EDGE"] = 7] = "RECTANGLE_EDGE";
    /**
     * 直线
     */
    ShapeType[ShapeType["EDGE"] = 8] = "EDGE";
    /**
     * 贴图
     */
    ShapeType[ShapeType["TEXTURE"] = 9] = "TEXTURE";
})(ShapeType || (ShapeType = {}));
/**
 * 插件类型
 */
var PluginType;
(function (PluginType) {
    /**
     * 陀螺仪
     */
    PluginType[PluginType["GYROSCOPE"] = 0] = "GYROSCOPE";
    /**
     * Spine
     */
    PluginType[PluginType["SPINE"] = 1] = "SPINE";
})(PluginType || (PluginType = {}));
/**
 * 交互类型
 */
var InteractType;
(function (InteractType) {
    /**
     * 点击
     */
    InteractType[InteractType["CLICK"] = 0] = "CLICK";
    /**
     * 消息
     * 前端收到 onMessageItem 回调
     */
    InteractType[InteractType["MESSAGE"] = 1] = "MESSAGE";
    /**
     * 拖拽
     */
    InteractType[InteractType["DRAG"] = 2] = "DRAG";
})(InteractType || (InteractType = {}));
/**
 * 交互行为
 */
var InteractBehavior;
(function (InteractBehavior) {
    /**
     * 无
     */
    InteractBehavior[InteractBehavior["NONE"] = 0] = "NONE";
    /**
     * 通知
     */
    InteractBehavior[InteractBehavior["NOTIFY"] = 1] = "NOTIFY";
    /**
     * 重置播放器
     */
    InteractBehavior[InteractBehavior["RESUME_PLAYER"] = 2] = "RESUME_PLAYER";
    /**
     * 清除元素
     */
    InteractBehavior[InteractBehavior["REMOVE"] = 3] = "REMOVE";
    /**
     * 暂停播放器
     */
    InteractBehavior[InteractBehavior["PAUSE"] = 4] = "PAUSE";
})(InteractBehavior || (InteractBehavior = {}));
/**
 * 元素类型
 */
var ItemType;
(function (ItemType) {
    /**
     * 错误元素
     */
    ItemType["base"] = "0";
    /**
     * 图层元素
     */
    ItemType["sprite"] = "1";
    /**
     * 粒子元素
     */
    ItemType["particle"] = "2";
    /**
     * 空节点元素
     */
    ItemType["null"] = "3";
    /**
     * 交互元素
     */
    ItemType["interact"] = "4";
    /**
     * 插件元素
     */
    ItemType["plugin"] = "5";
    /**
     * 相机元素
     */
    ItemType["camera"] = "6";
    /**
     * 预合成元素
     */
    ItemType["composition"] = "7";
    /**
     * 滤镜图层
     */
    ItemType["filter"] = "8";
    /**
     * Spine 元素
     */
    ItemType["spine"] = "spine";
})(ItemType || (ItemType = {}));
/**
 * 渲染模式
 */
var RenderMode;
(function (RenderMode) {
    /**
     * 广告牌模式
     */
    RenderMode[RenderMode["BILLBOARD"] = 0] = "BILLBOARD";
    /**
     * 网格模式
     */
    RenderMode[RenderMode["MESH"] = 1] = "MESH";
    /**
     * 垂直广告牌模式
     */
    RenderMode[RenderMode["VERTICAL_BILLBOARD"] = 2] = "VERTICAL_BILLBOARD";
    /**
     * 水平广告牌模式
     */
    RenderMode[RenderMode["HORIZONTAL_BILLBOARD"] = 3] = "HORIZONTAL_BILLBOARD";
})(RenderMode || (RenderMode = {}));
/**
 * 变换中心
 */
var ParticleOrigin;
(function (ParticleOrigin) {
    /**
     * 水平和垂直中点
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER"] = 0] = "PARTICLE_ORIGIN_CENTER";
    /**
     * 水平左侧 垂直顶部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_TOP"] = 1] = "PARTICLE_ORIGIN_LEFT_TOP";
    /**
     * 水平左侧 垂直中间
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_CENTER"] = 2] = "PARTICLE_ORIGIN_LEFT_CENTER";
    /**
     * 水平左侧 垂直底部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_BOTTOM"] = 3] = "PARTICLE_ORIGIN_LEFT_BOTTOM";
    /**
     * 水平中间 垂直顶部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER_TOP"] = 4] = "PARTICLE_ORIGIN_CENTER_TOP";
    /**
     * 水平中间 垂直底部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER_BOTTOM"] = 5] = "PARTICLE_ORIGIN_CENTER_BOTTOM";
    /**
     * 水平右侧 垂直顶部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_TOP"] = 6] = "PARTICLE_ORIGIN_RIGHT_TOP";
    /**
     * 水平右侧 垂直中间
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_CENTER"] = 7] = "PARTICLE_ORIGIN_RIGHT_CENTER";
    /**
     * 水平右侧 垂直底部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_BOTTOM"] = 8] = "PARTICLE_ORIGIN_RIGHT_BOTTOM";
})(ParticleOrigin || (ParticleOrigin = {}));

var END_BEHAVIOR_DESTROY = 0;
var END_BEHAVIOR_PAUSE = 1;
var END_BEHAVIOR_FORWARD = 2;
var END_BEHAVIOR_PAUSE_AND_DESTROY = 3;
var END_BEHAVIOR_FREEZE = 4;
var END_BEHAVIOR_RESTART = 5;
var END_BEHAVIOR_DESTROY_CHILDREN = 6;
var CAMERA_CLIP_MODE_VERTICAL = 1;
var CAMERA_CLIP_MODE_NORMAL = 0;

var CameraClipMode;
(function (CameraClipMode) {
    /**
     * 剪裁上下
     */
    CameraClipMode[CameraClipMode["portrait"] = CAMERA_CLIP_MODE_VERTICAL] = "portrait";
    /**
     * 剪裁左右
     */
    CameraClipMode[CameraClipMode["landscape"] = CAMERA_CLIP_MODE_NORMAL] = "landscape";
})(CameraClipMode || (CameraClipMode = {}));
/**
 * 结束行为
 */
var CompositionEndBehavior;
(function (CompositionEndBehavior) {
    /**
     * 销毁
     */
    CompositionEndBehavior[CompositionEndBehavior["destroy"] = END_BEHAVIOR_DESTROY] = "destroy";
    /**
     * 暂停
     */
    CompositionEndBehavior[CompositionEndBehavior["pause"] = END_BEHAVIOR_PAUSE] = "pause";
    /**
     * 重播
     */
    CompositionEndBehavior[CompositionEndBehavior["restart"] = END_BEHAVIOR_RESTART] = "restart";
    /**
     * 无限播放
     */
    CompositionEndBehavior[CompositionEndBehavior["forward"] = END_BEHAVIOR_FORWARD] = "forward";
    /**
     * 销毁并保留最后一帧
     */
    CompositionEndBehavior[CompositionEndBehavior["pause_destroy"] = END_BEHAVIOR_PAUSE_AND_DESTROY] = "pause_destroy";
})(CompositionEndBehavior || (CompositionEndBehavior = {}));

/*********************************************/
/*               基本数值属性参数              */
/*********************************************/
var ValueType;
(function (ValueType) {
    /**
     * 常数
     */
    ValueType[ValueType["CONSTANT"] = 0] = "CONSTANT";
    /**
     * 二维常数向量
     */
    ValueType[ValueType["CONSTANT_VEC2"] = 1] = "CONSTANT_VEC2";
    /**
     * 三维常数向量
     */
    ValueType[ValueType["CONSTANT_VEC3"] = 2] = "CONSTANT_VEC3";
    /**
     * 四维常数向量
     */
    ValueType[ValueType["CONSTANT_VEC4"] = 3] = "CONSTANT_VEC4";
    /**
     * 随机数
     */
    ValueType[ValueType["RANDOM"] = 4] = "RANDOM";
    /**
     * 直线
     */
    ValueType[ValueType["LINE"] = 5] = "LINE";
    /**
     * 曲线
     */
    ValueType[ValueType["CURVE"] = 6] = "CURVE";
    /**
     * 贝塞尔路径
     */
    ValueType[ValueType["BEZIER_PATH"] = 7] = "BEZIER_PATH";
    /**
     * 颜色
     */
    ValueType[ValueType["RGBA_COLOR"] = 8] = "RGBA_COLOR";
    /**
     * 渐变色
     */
    ValueType[ValueType["GRADIENT_COLOR"] = 9] = "GRADIENT_COLOR";
    /**
     * 蒙版形状点集
     */
    ValueType[ValueType["SHAPE_POINTS"] = 10] = "SHAPE_POINTS";
    /**
     * 蒙版形状切分
     */
    ValueType[ValueType["SHAPE_SPLITS"] = 11] = "SHAPE_SPLITS";
    /**
     *直线路径
     */
    ValueType[ValueType["LINEAR_PATH"] = 12] = "LINEAR_PATH";
    /**
     * 多色
     */
    ValueType[ValueType["COLORS"] = 13] = "COLORS";
    /**
     * 二进制指针
     */
    ValueType[ValueType["BINARY"] = 20] = "BINARY";
    /**
     * 贝塞尔曲线
     */
    ValueType[ValueType["BEZIER_CURVE"] = 21] = "BEZIER_CURVE";
    /**
     * 贝塞尔曲线路径
     */
    ValueType[ValueType["BEZIER_CURVE_PATH"] = 22] = "BEZIER_CURVE_PATH";
})(ValueType || (ValueType = {}));
/**
 * 关键帧类型
 */
var BezierKeyframeType;
(function (BezierKeyframeType) {
    BezierKeyframeType[BezierKeyframeType["AUTO"] = 0] = "AUTO";
    BezierKeyframeType[BezierKeyframeType["EASE"] = 1] = "EASE";
    BezierKeyframeType[BezierKeyframeType["EASE_IN"] = 2] = "EASE_IN";
    BezierKeyframeType[BezierKeyframeType["EASE_OUT"] = 3] = "EASE_OUT";
    BezierKeyframeType[BezierKeyframeType["LINE"] = 4] = "LINE";
    BezierKeyframeType[BezierKeyframeType["HOLD"] = 5] = "HOLD";
    BezierKeyframeType[BezierKeyframeType["LINE_OUT"] = 6] = "LINE_OUT";
})(BezierKeyframeType || (BezierKeyframeType = {}));

var ItemEndBehavior;
(function (ItemEndBehavior) {
    ItemEndBehavior[ItemEndBehavior["destroy"] = END_BEHAVIOR_DESTROY] = "destroy";
    ItemEndBehavior[ItemEndBehavior["loop"] = END_BEHAVIOR_RESTART] = "loop";
    ItemEndBehavior[ItemEndBehavior["forward"] = END_BEHAVIOR_FREEZE] = "forward";
})(ItemEndBehavior || (ItemEndBehavior = {}));
var ParentItemEndBehavior;
(function (ParentItemEndBehavior) {
    ParentItemEndBehavior[ParentItemEndBehavior["destroyChildren"] = END_BEHAVIOR_DESTROY_CHILDREN] = "destroyChildren";
})(ParentItemEndBehavior || (ParentItemEndBehavior = {}));

/**
 * 粒子交互行为
 */
var ParticleInteractionBehavior;
(function (ParticleInteractionBehavior) {
    /**
     * 无
     */
    ParticleInteractionBehavior[ParticleInteractionBehavior["none"] = 0] = "none";
    /**
     * 移出粒子
     */
    ParticleInteractionBehavior[ParticleInteractionBehavior["removeParticle"] = 1] = "removeParticle";
})(ParticleInteractionBehavior || (ParticleInteractionBehavior = {}));

var ShapeArcMode;
(function (ShapeArcMode) {
    /**
     * 随机
     */
    ShapeArcMode[ShapeArcMode["RANDOM"] = 0] = "RANDOM";
    /**
     * 单向循环
     */
    ShapeArcMode[ShapeArcMode["UNIDIRECTIONAL_CYCLE"] = 1] = "UNIDIRECTIONAL_CYCLE";
    /**
     * 双向循环
     */
    ShapeArcMode[ShapeArcMode["BIDIRECTIONAL_CYCLE"] = 2] = "BIDIRECTIONAL_CYCLE";
    /**
     * 均匀爆发
     */
    ShapeArcMode[ShapeArcMode["UNIFORM_BURST"] = 3] = "UNIFORM_BURST";
})(ShapeArcMode || (ShapeArcMode = {}));

var ModelBoundingType;
(function (ModelBoundingType) {
    ModelBoundingType[ModelBoundingType["box"] = 2] = "box";
    ModelBoundingType[ModelBoundingType["sphere"] = 3] = "sphere";
})(ModelBoundingType || (ModelBoundingType = {}));

// 材质类型
var MaterialType;
(function (MaterialType) {
    MaterialType["unlit"] = "unlit";
    MaterialType["pbr"] = "pbr";
    // 头发材质，在 pbr 材质基础上扩展
    MaterialType["hair"] = "hair";
})(MaterialType || (MaterialType = {}));
// 混合模式
var MaterialBlending;
(function (MaterialBlending) {
    MaterialBlending[MaterialBlending["opaque"] = 100] = "opaque";
    MaterialBlending[MaterialBlending["masked"] = 101] = "masked";
    MaterialBlending[MaterialBlending["translucent"] = 102] = "translucent";
    MaterialBlending[MaterialBlending["additive"] = 103] = "additive";
})(MaterialBlending || (MaterialBlending = {}));

/**
 * 3D渲染模式：将渲染过程中的中间结果输出，主要用于排查渲染效果问题，支持 pbr 和 unlit 材质
 */
var RenderMode3D;
(function (RenderMode3D) {
    /**
     * 正常渲染
     */
    RenderMode3D["none"] = "none";
    /**
     * 纹理坐标
     */
    RenderMode3D["uv"] = "uv";
    /**
     * 世界坐标法线
     */
    RenderMode3D["normal"] = "normal";
    /**
     * 基础颜色
     */
    RenderMode3D["basecolor"] = "basecolor";
    /**
     * 基础颜色 Alpha
     */
    RenderMode3D["alpha"] = "alpha";
    /**
     * 金属度
     */
    RenderMode3D["metallic"] = "metallic";
    /**
     * 粗超度
     */
    RenderMode3D["roughness"] = "roughness";
    /**
     * 环境遮蔽
     */
    RenderMode3D["ao"] = "ao";
    /**
     * 自发光
     */
    RenderMode3D["emissive"] = "emissive";
})(RenderMode3D || (RenderMode3D = {}));

var TextOverflow;
(function (TextOverflow) {
    // default, display all text, it may decrease letter space size
    TextOverflow[TextOverflow["display"] = 0] = "display";
    // clip overflowed text
    TextOverflow[TextOverflow["clip"] = 1] = "clip";
    // use icon('..') to replace overflowed text
    TextOverflow[TextOverflow["ellipsis"] = 2] = "ellipsis";
})(TextOverflow || (TextOverflow = {}));
var TextAlignment;
(function (TextAlignment) {
    /**
     * text alignment starts from（x,y) to right direction
     * 从(x,y)开始第一个字符，向右边延伸
     */
    TextAlignment[TextAlignment["left"] = 0] = "left";
    /**
     * (x,y) is middle position of text, where (left + right)/2 =(x,y)
     * (x,y) 为文字中间位置，（最左位置 + 最右位置)/2 = (x,y)
     */
    TextAlignment[TextAlignment["middle"] = 1] = "middle";
    /**
     * text alignment ends with（x,y) from left direction
     * 从(x,y)结束最后一个字符，向左边延伸
     */
    TextAlignment[TextAlignment["right"] = 2] = "right";
})(TextAlignment || (TextAlignment = {}));
var FontStyle;
(function (FontStyle) {
    FontStyle[FontStyle["normal"] = 0] = "normal";
    FontStyle[FontStyle["italic"] = 1] = "italic";
    FontStyle[FontStyle["oblique"] = 2] = "oblique";
})(FontStyle || (FontStyle = {}));

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function arrAdd(arr, item) {
    if (!arr.includes(item)) {
        arr.push(item);
        return true;
    }
}
/**
 * @deprecated 请直接使用 Array.prototype.forEach 或 for...of
 * @param object
 * @param callback
 * @returns the mutated input object
 */
function forEach(object, callback, thisObj) {
    if (object) {
        for (var name_1 in object) {
            if (Object.hasOwnProperty.call(object, name_1)) {
                callback.call(thisObj, object[name_1], name_1);
            }
        }
    }
    return object;
}
function ensureFixedNumber(a) {
    if (Number.isFinite(a)) {
        return [ValueType.CONSTANT, a];
    }
    if (a) {
        if (a[0] === 'lines') {
            return [ValueType.LINE, a[1]];
        }
        if (a[0] === 'curve') {
            return [ValueType.CURVE, a[1]];
        }
        if (a[0] === 'static') {
            return [ValueType.CONSTANT, a[1]];
        }
    }
}
function ensureFixedNumberWithRandom(a, p) {
    if (Array.isArray(a) && a[0] === 'random') {
        return [ValueType.CONSTANT, a[1][p]];
    }
    return ensureFixedNumber(a);
}
function ensureRGBAValue(a) {
    if (a && a[0] === 'color') {
        return colorToArr(a[1], true);
    }
    return [1, 1, 1, 1];
}
function ensureColorExpression(a, normalized) {
    if (a) {
        if (a[0] === 'colors') {
            return [ValueType.COLORS, a[1].map(function (color) { return colorToArr(color, normalized); })];
        }
        else if (a[0] === 'gradient') {
            return ensureGradient(a[1], normalized);
        }
        else if (a[0] === 'color') {
            return [ValueType.RGBA_COLOR, colorToArr(a[1], normalized)];
        }
    }
}
function ensureNumberExpression(a) {
    if (a && a[0] === 'random') {
        return [ValueType.RANDOM, a[1]];
    }
    return ensureFixedNumber(a);
}
function ensureValueGetter(a) {
    if (Array.isArray(a) && typeof a[0] === 'string') {
        return ensureNumberExpression(a) || ensureFixedVec3(a) || ensureColorExpression(a) || a;
    }
    return a;
}
function ensureGradient(a, normalized) {
    if (a) {
        var stops_1 = [];
        Object.getOwnPropertyNames(a).forEach(function (p) {
            var stop = parsePercent(p);
            var color = colorToArr(a[p], normalized);
            stops_1.push([stop, color[0], color[1], color[2], color[3]]);
        });
        stops_1 = stops_1.sort(function (a, b) { return a[0] - b[0]; });
        return [ValueType.GRADIENT_COLOR, stops_1];
    }
}
function colorToArr(hex, normalized) {
    var ret;
    if (typeof hex === 'string') {
        hex = hex.replace(/[\s\t\r\n]/g, '');
        var m = /rgba?\(([.\d]+),([.\d]+),([.\d]+),?([.\d]+)?\)/.exec(hex);
        if (m) {
            var a = +m[4];
            ret = [+m[1], +m[2], +m[3], isNaN(a) ? 255 : Math.round(a * 255)];
        }
        else if (/^#[a-f\d]{3}$/i.test(hex)) {
            ret = [parseInt(hex[1] + hex[1], 16), parseInt(hex[2] + hex[2], 16), parseInt(hex[3] + hex[3], 16), 255];
            // eslint-disable-next-line no-cond-assign
        }
        else if (m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)) {
            ret = [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 255] || [0, 0, 0, 255];
        }
    }
    else if (hex instanceof Array) {
        ret = [hex[0], hex[1], hex[2], isNaN(hex[3]) ? 255 : Math.round(hex[3] * 255)];
    }
    if (normalized) {
        // @ts-expect-error
        ret = normalizeColor(ret);
    }
    // @ts-expect-error
    return ret;
}
function normalizeColor(a) {
    if (Array.isArray(a)) {
        return a.map(function (i) { return Number.isFinite(i / 255) ? Number((i / 255).toFixed(6)) : 0; });
    }
}
function parsePercent(c) {
    var match = /^(-)?([\d+.]+)%$/.exec(c);
    if (match) {
        return +match[2] / 100 * (match[1] ? -1 : 1);
    }
    return +c;
}
function getGradientColor(color, normalized) {
    if (Array.isArray(color)) {
        // @ts-expect-error
        return (color[0] === 'gradient' || color[0] === 'color') && ensureGradient(color[1], normalized);
    }
    else {
        return ensureGradient(color, normalized);
    }
}
function ensureFixedVec3(a) {
    if (a) {
        if (a.length === 3) {
            return [ValueType.CONSTANT_VEC3, a];
        }
        if (a[0] === 'path') {
            return [ValueType.LINEAR_PATH, a[1]];
        }
        if (a[0] === 'bezier') {
            return [ValueType.BEZIER_PATH, a[1]];
        }
    }
}
function objectValueToNumber(o) {
    var e_1, _a;
    try {
        for (var _b = __values(Object.entries(o)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
            o[key] = Number(value);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return o;
}
function deleteEmptyValue(o) {
    var e_2, _a;
    try {
        for (var _b = __values(Object.keys(o)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            if (o[key] === undefined) {
                delete o[key];
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return o;
}
var cos = Math.cos;
var sin = Math.sin;
var d2r = Math.PI / 180;
var r2d = 180 / Math.PI;
function quatFromXYZRotation(out, x, y, z) {
    var c1 = cos((x * d2r) / 2);
    var c2 = cos((y * d2r) / 2);
    var c3 = cos((z * d2r) / 2);
    var s1 = sin((x * d2r) / 2);
    var s2 = sin((y * d2r) / 2);
    var s3 = sin((z * d2r) / 2);
    out[0] = s1 * c2 * c3 + c1 * s2 * s3;
    out[1] = c1 * s2 * c3 - s1 * c2 * s3;
    out[2] = c1 * c2 * s3 + s1 * s2 * c3;
    out[3] = c1 * c2 * c3 - s1 * s2 * s3;
    return out;
}
function clamp(v, min, max) {
    return v > max ? max : (v < min ? min : v);
}
function rotationZYXFromQuat(out, quat) {
    var x = quat[0];
    var y = quat[1];
    var z = quat[2];
    var w = quat[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var m11 = 1 - yy - zz, m12 = yx - wz;
    var m21 = yx + wz, m22 = 1 - xx - zz;
    var m31 = zx - wy, m32 = zy + wx, m33 = 1 - xx - yy;
    out[1] = Math.asin(clamp(-m31, -1, 1)) * r2d;
    if (Math.abs(m31) < 0.9999999) {
        out[0] = Math.atan2(m32, m33) * r2d;
        out[2] = Math.atan2(m21, m11) * r2d;
    }
    else {
        out[0] = 0;
        out[2] = Math.atan2(-m12, m22) * r2d;
    }
    return out;
}

function getStandardParticleContent(particle) {
    var _a;
    var options = particle.options;
    var transform = particle.transform;
    var shape = {
        type: ShapeType.NONE,
    };
    if (particle.shape) {
        var shapeType = (_a = particle.shape.shape) === null || _a === void 0 ? void 0 : _a.replace(/([A-Z])/g, '_$1').toUpperCase().replace(/^_/, '');
        shape = __assign(__assign({}, particle.shape), { type: ShapeType[shapeType] });
        if (particle.shape.upDirection) {
            var _b = __read(particle.shape.upDirection, 3), x = _b[0], y = _b[1], z = _b[2];
            if (x === 0 && y === 0 && z === 0) {
                delete shape.upDirection;
            }
        }
    }
    if (options.startTurbulence) {
        shape.turbulenceX = ensureNumberExpression(options.turbulenceX);
        shape.turbulenceY = ensureNumberExpression(options.turbulenceY);
        shape.turbulenceZ = ensureNumberExpression(options.turbulenceZ);
    }
    var emission = particle.emission;
    if (emission.bursts && emission.bursts.length > 0) {
        emission.bursts = emission.bursts.map(function (b) { return objectValueToNumber(b); });
    }
    if (emission.burstOffsets && emission.burstOffsets.length > 0) {
        emission.burstOffsets = emission.burstOffsets.map(function (b) { return objectValueToNumber(b); });
    }
    if (emission.rateOverTime) {
        emission.rateOverTime = ensureNumberExpression(emission.rateOverTime);
    }
    var ret = {
        renderer: particle.renderer,
        shape: shape,
        splits: particle.splits,
        emission: emission,
        options: {
            startLifetime: ensureNumberExpression(options.startLifetime),
            start3DSize: !!options.start3DSize,
            startSize: ensureNumberExpression(options.startSize),
            startSizeX: ensureNumberExpression(options.startSizeX),
            startSizeY: ensureNumberExpression(options.startSizeY),
            sizeAspect: ensureNumberExpression(options.sizeAspect),
            maxCount: options.maxCount,
            startDelay: ensureNumberExpression(options.startDelay),
            startColor: ensureColorExpression(options.startColor, true),
            startRotationZ: ensureNumberExpression(options.startRotation || options.startRotationZ),
            particleFollowParent: options.particleFollowParent,
        },
    };
    if (options.start3DRotation) {
        ret.options.startRotationX = ensureNumberExpression(options.startRotationX);
        ret.options.startRotationY = ensureNumberExpression(options.startRotationY);
    }
    if (particle.filter) {
        var filter_1 = {};
        forEach(particle.filter, function (val, key) {
            // @ts-expect-error
            filter_1[key] = ensureValueGetter(val);
        });
        ret.filter = filter_1;
    }
    if (transform && transform.path) {
        ret.emitterTransform = {
            path: ensureFixedVec3(transform.path),
        };
    }
    var sizeOverLifetime = particle.sizeOverLifetime;
    if (sizeOverLifetime) {
        if (sizeOverLifetime.separateAxes) {
            ret.sizeOverLifetime = {
                separateAxes: true,
                x: ensureNumberExpression(sizeOverLifetime.x),
                y: ensureNumberExpression(sizeOverLifetime.y),
            };
        }
        else {
            ret.sizeOverLifetime = {
                size: ensureNumberExpression(sizeOverLifetime.size),
            };
        }
    }
    var velocityOverLifetime = particle.velocityOverLifetime || {};
    var sol = velocityOverLifetime.speedOverLifetime;
    if (sol) {
        sol = ensureFixedNumber(sol);
    }
    else {
        sol = undefined;
    }
    ret.positionOverLifetime = {
        gravity: options.gravity,
        gravityOverLifetime: ensureFixedNumber(options.gravityModifier),
        startSpeed: ensureNumberExpression(options.startSpeed),
        speedOverLifetime: sol,
        asMovement: velocityOverLifetime.asMovement,
        linearX: ensureNumberExpression(velocityOverLifetime.linearX),
        linearY: ensureNumberExpression(velocityOverLifetime.linearY),
        linearZ: ensureNumberExpression(velocityOverLifetime.linearZ),
        asRotation: velocityOverLifetime.asRotation,
        orbCenter: velocityOverLifetime.orbCenter,
        orbitalX: ensureNumberExpression(velocityOverLifetime.orbitalX),
        orbitalY: ensureNumberExpression(velocityOverLifetime.orbitalY),
        orbitalZ: ensureNumberExpression(velocityOverLifetime.orbitalZ),
        forceTarget: velocityOverLifetime.forceTarget,
        target: velocityOverLifetime.target,
        forceCurve: ensureFixedNumber(velocityOverLifetime.forceCurve),
    };
    deleteEmptyValue(ret.positionOverLifetime);
    var rotationOverLifetime = particle.rotationOverLifetime;
    if (rotationOverLifetime) {
        ret.rotationOverLifetime = {
            separateAxes: rotationOverLifetime.separateAxes,
            asRotation: rotationOverLifetime.asRotation,
            z: ensureNumberExpression(rotationOverLifetime.separateAxes ? rotationOverLifetime.z : rotationOverLifetime.angularVelocity),
        };
        if (rotationOverLifetime.separateAxes) {
            ret.rotationOverLifetime.y = ensureFixedNumber(rotationOverLifetime.y);
            ret.rotationOverLifetime.x = ensureFixedNumber(rotationOverLifetime.x);
        }
    }
    var colorOverLifetime = particle.colorOverLifetime;
    if (colorOverLifetime) {
        var col = ret.colorOverLifetime = {
            opacity: ensureFixedNumber(colorOverLifetime.opacity),
        };
        if (colorOverLifetime.color) {
            col.color = getGradientColor(colorOverLifetime.color);
        }
    }
    var textureSheetAnimation = particle.textureSheetAnimation;
    if (textureSheetAnimation) {
        ret.textureSheetAnimation = {
            row: textureSheetAnimation.row,
            col: textureSheetAnimation.col,
            total: textureSheetAnimation.total,
            animate: textureSheetAnimation.animate,
            cycles: ensureFixedNumber(textureSheetAnimation.cycles),
            animationDelay: ensureFixedNumberWithRandom(textureSheetAnimation.animationDelay, 0),
            animationDuration: ensureFixedNumberWithRandom(textureSheetAnimation.animationDuration, 0),
        };
    }
    var trials = particle.trails;
    if (trials) {
        ret.trails = {
            lifetime: ensureNumberExpression(trials.lifetime),
            dieWithParticles: trials.dieWithParticles,
            maxPointPerTrail: trials.maxPointPerTrail,
            minimumVertexDistance: trials.minimumVertexDistance,
            widthOverTrail: ensureFixedNumber(trials.widthOverTrail),
            colorOverTrail: trials.colorOverTrail && getGradientColor(trials.colorOverTrail, false),
            blending: trials.blending,
            colorOverLifetime: trials.colorOverLifetime && getGradientColor(trials.colorOverLifetime, false),
            inheritParticleColor: trials.inheritParticleColor,
            occlusion: trials.occlusion,
            transparentOcclusion: trials.transparentOcclusion,
            orderOffset: trials.orderOffset,
            sizeAffectsLifetime: trials.sizeAffectsLifetime,
            sizeAffectsWidth: trials.sizeAffectsWidth,
            texture: trials.texture,
            parentAffectsPosition: trials.parentAffectsPosition,
            opacityOverLifetime: ensureNumberExpression(trials.opacityOverLifetime),
        };
    }
    ret.trails && deleteEmptyValue(ret.trails);
    var interaction = particle.interaction;
    if (interaction) {
        ret.interaction = {
            behavior: interaction.behavior,
            radius: interaction.radius,
            multiple: interaction.multiple,
        };
    }
    return ret;
}

function getStandardNullContent(sprite, transform) {
    var _a;
    var opt = sprite.options;
    var velocityOverLifetime = sprite.velocityOverLifetime || {};
    var positionOverLifetime = {
        path: ensureFixedVec3((_a = sprite.transform) === null || _a === void 0 ? void 0 : _a.path),
        gravity: opt.gravity,
        gravityOverLifetime: ensureFixedNumber(opt.gravityModifier),
        direction: opt.direction,
        startSpeed: opt.startSpeed,
        asMovement: velocityOverLifetime.asMovement,
        linearX: ensureFixedNumber(velocityOverLifetime.linearX),
        linearY: ensureFixedNumber(velocityOverLifetime.linearY),
        linearZ: ensureFixedNumber(velocityOverLifetime.linearZ),
        asRotation: velocityOverLifetime.asRotation,
        orbCenter: velocityOverLifetime.orbCenter,
        orbitalX: ensureFixedNumber(velocityOverLifetime.orbitalX),
        orbitalY: ensureFixedNumber(velocityOverLifetime.orbitalY),
        orbitalZ: ensureFixedNumber(velocityOverLifetime.orbitalZ),
        speedOverLifetime: ensureFixedNumber(velocityOverLifetime.speedOverLifetime),
    };
    deleteEmptyValue(positionOverLifetime);
    var ret = {
        options: {
            startColor: ensureRGBAValue(opt.startColor),
        },
        positionOverLifetime: positionOverLifetime,
    };
    if (opt.startSize) {
        transform.scale = [opt.startSize, opt.startSize / (opt.sizeAspect || 1), 1];
    }
    if (opt.startRotation) {
        if (!transform.rotation) {
            transform.rotation = [0, 0, opt.startRotation];
        }
        else {
            transform.rotation[2] += opt.startRotation;
        }
    }
    var rotationOverLifetime = sprite.rotationOverLifetime;
    if (rotationOverLifetime) {
        var rot = ret.rotationOverLifetime = {
            separateAxes: rotationOverLifetime.separateAxes,
            asRotation: rotationOverLifetime.asRotation,
        };
        if (rot.separateAxes) {
            rot.x = ensureFixedNumber(rotationOverLifetime.x);
            rot.y = ensureFixedNumber(rotationOverLifetime.y);
            rot.z = ensureFixedNumber(rotationOverLifetime.z);
        }
        else {
            rot.z = ensureFixedNumber(rotationOverLifetime.angularVelocity);
        }
    }
    var colorOverLifetime = sprite.colorOverLifetime;
    if (colorOverLifetime) {
        var col = ret.colorOverLifetime = {
            opacity: ensureFixedNumber(colorOverLifetime.opacity),
        };
        if (colorOverLifetime.color) {
            col.color = getGradientColor(colorOverLifetime.color);
        }
    }
    var sizeOverLifetime = sprite.sizeOverLifetime;
    if (sizeOverLifetime) {
        ret.sizeOverLifetime = {
            separateAxes: sizeOverLifetime.separateAxes,
            size: ensureFixedNumber(sizeOverLifetime.size),
            x: ensureFixedNumber(sizeOverLifetime.x),
            y: ensureFixedNumber(sizeOverLifetime.y),
            z: ensureFixedNumber(sizeOverLifetime.z),
        };
    }
    return ret;
}
function getStandardSpriteContent(sprite, transform) {
    var ret = getStandardNullContent(sprite, transform);
    var texAni = sprite.textureSheetAnimation;
    if (texAni) {
        ret.textureSheetAnimation = {
            row: texAni.row,
            col: texAni.col,
            total: texAni.total || undefined,
            animate: texAni.animate,
        };
    }
    ret.renderer = sprite.renderer;
    if (sprite.splits) {
        ret.splits = sprite.splits;
    }
    if (sprite.interaction) {
        ret.interaction = sprite.interaction;
    }
    return ret;
}

function getStandardInteractContent(ui) {
    var options = ui.options;
    var option;
    switch (options.type) {
        case 'click': {
            option = {
                type: InteractType.CLICK,
                showPreview: options.showPreview,
                previewColor: options.previewColor && ensureRGBAValue(options.previewColor),
                behavior: options.behavior || InteractBehavior.NOTIFY,
            };
            break;
        }
        case 'drag': {
            option = {
                type: InteractType.DRAG,
                enableInEditor: !!options.enableInEditor,
                dxRange: options.dxRange,
                dyRange: options.dyRange,
                target: options.target,
            };
            break;
        }
        case 'message': {
            option = {
                type: InteractType.MESSAGE,
            };
            break;
        }
    }
    var ret = {
        // @ts-expect-error
        options: option,
    };
    return ret;
}

function getStandardCameraContent(model) {
    var _a, _b;
    var opt = model.options;
    var ret = {
        options: {
            fov: opt.fov,
            far: opt.far,
            near: opt.near,
            clipMode: opt.clipMode,
        },
    };
    var velocityOverLifetime = model.velocityOverLifetime;
    if (velocityOverLifetime || ((_a = model.transform) === null || _a === void 0 ? void 0 : _a.path)) {
        var positionOverLifetime = {
            path: ensureFixedVec3((_b = model.transform) === null || _b === void 0 ? void 0 : _b.path),
            linearX: ensureFixedNumber(velocityOverLifetime === null || velocityOverLifetime === void 0 ? void 0 : velocityOverLifetime.translateX),
            linearY: ensureFixedNumber(velocityOverLifetime === null || velocityOverLifetime === void 0 ? void 0 : velocityOverLifetime.translateY),
            linearZ: ensureFixedNumber(velocityOverLifetime === null || velocityOverLifetime === void 0 ? void 0 : velocityOverLifetime.translateZ),
        };
        deleteEmptyValue(positionOverLifetime);
        ret.positionOverLifetime = positionOverLifetime;
    }
    var rol = model.rotationOverLifetime;
    if (rol) {
        var rotationOverLifetime = {
            separateAxes: rol.separateAxes,
            x: ensureFixedNumber(rol === null || rol === void 0 ? void 0 : rol.rotateX),
            y: ensureFixedNumber(rol === null || rol === void 0 ? void 0 : rol.rotateY),
            z: rol.separateAxes ? ensureFixedNumber(rol === null || rol === void 0 ? void 0 : rol.rotateZ) : ensureFixedNumber(rol.rotation),
        };
        deleteEmptyValue(rotationOverLifetime);
        ret.rotationOverLifetime = rotationOverLifetime;
    }
    return ret;
}

var convertParams = [
    'strength',
    'bloomAddon',
    'colorAddon',
    'period',
    'waveMovement',
    'colorThreshold',
    'xOpacity',
    'yOpacity',
    'feather',
];
var pathParams = [
    'path', 'position',
];
function getStandardFilterContent(filter) {
    var ret = {};
    forEach(filter, function (val, key) {
        if (convertParams.includes(key)) {
            ret[key] = ensureFixedNumber(val);
        }
        else if (pathParams.includes(key)) {
            ret[key] = ensureFixedVec3(val);
        }
        else {
            ret[key] = val;
        }
    });
    return ret;
}

var v0 = /^(\d+)\.(\d+)\.(\d+)(-(\w+)\.\d+)?$/;
var standardVersion = /^(\d+)\.(\d+)$/;
var reverseParticle = false;
function getStandardJSON(json) {
    var _a;
    if (!json || typeof json !== 'object') {
        throw Error('expect a json object');
    }
    if (v0.test(json.version)) {
        reverseParticle = ((_a = (/^(\d+)/).exec(json.version)) === null || _a === void 0 ? void 0 : _a[0]) === '0';
        return getStandardJSONFromV0(json);
    }
    var match = standardVersion.exec(json.version);
    if (match) {
        var main = match[1];
        if (main === '1') {
            return json;
        }
    }
    throw Error('invalid json version ' + json.version);
}
var currentVersion = '1.0';
function getStandardJSONFromV0(json) {
    var _a;
    currentVersion = '1.0';
    var plugins = json.plugins || [];
    if ((_a = json.bins) === null || _a === void 0 ? void 0 : _a.length) {
        currentVersion = '1.3';
    }
    var requires = (json.requires || []).slice();
    var images = json.images.map(function (img, index) { return getStandardImage(img, index, json.imageTags || []); });
    var textures = json.textures || images.map(function (img, i) { return ({ source: i, flipY: true }); });
    var ret = {
        plugins: plugins,
        shapes: json.shapes || [],
        type: 'mars',
        version: currentVersion,
        loaderVersion: json.version,
        compositionId: json.compositionId + '',
        compositions: json.compositions.map(function (comp) { return getStandardComposition(comp, { plugins: plugins, requires: requires }); }),
        images: images,
        imgUsage: json._imgs,
        binUsage: json.binUsage,
        spines: json.spines,
        requires: json.requires,
        textures: textures,
        bins: (json.bins || []).slice(),
    };
    if (json._textures) {
        ret._textures = json._textures;
    }
    return ret;
}
function getStandardImage(image, index, imageTags) {
    var renderLevel = imageTags[index];
    var oriY = image.oriY;
    if (typeof image === 'string') {
        return {
            renderLevel: renderLevel,
            url: image,
            oriY: oriY,
        };
    }
    else if (image.template) {
        return {
            url: image.url,
            template: image.template,
            webp: image.webp,
            renderLevel: renderLevel,
            oriY: oriY,
        };
    }
    else if (image.compressed) {
        return {
            url: image.url,
            oriY: oriY,
            compressed: {
                astc: image.compressed.android,
                pvrtc: image.compressed.iOS,
            },
            webp: image.webp,
            renderLevel: renderLevel,
        };
    }
    else if (image.url) {
        return {
            url: image.url,
            type: image.type,
            webp: image.webp,
            renderLevel: renderLevel,
            oriY: oriY,
            loop: image.loop,
        };
    }
    else if (image && image.sourceType) {
        // mars texture
        return image;
    }
    throw Error('invalid image type');
}
function getStandardComposition(composition, opt) {
    var _a;
    if (opt === void 0) { opt = {}; }
    var ret = {
        id: composition.id + '',
        camera: Object.assign({ clipMode: CAMERA_CLIP_MODE_NORMAL }, composition.camera),
        duration: composition.duration,
        endBehavior: composition.endBehavior,
        items: composition.items.map(function (item) { return getStandardItem(item, opt); }),
        name: composition.name,
    };
    var startTime = composition.startTime || composition.st;
    if (startTime) {
        ret.startTime = startTime;
    }
    var previewSize = (_a = composition.meta) === null || _a === void 0 ? void 0 : _a.previewSize;
    if (previewSize && previewSize[0] === previewSize[1] && previewSize[0] === 0) {
        previewSize = undefined;
    }
    if (previewSize) {
        ret.previewSize = previewSize;
    }
    return ret;
}
var tempQuat = [0, 0, 0, 1];
var stdAnchor = 0.5;
function getStandardItem(item, opt) {
    var _a, _b, _c;
    if (opt === void 0) { opt = {}; }
    var type = ItemType.base;
    var transform;
    var originContent;
    var content;
    var endBehavior = item.endBehavior;
    var renderLevel;
    var pluginName;
    var duration;
    var pn;
    if (item.content) {
        type = item.type || ItemType.plugin;
        pn = item.pn;
        pluginName = item.pluginName;
        content = item.content;
        originContent = item.content;
        if (isNaN(pn) && !pluginName) {
            pluginName = content.options.type;
        }
        if (item.duration) {
            duration = item.duration;
        }
        transform = item.transform || getTransform(originContent.transform);
        if (type === ItemType.filter) {
            if (currentVersion < '1.1') {
                currentVersion = '1.1';
            }
            content = getStandardSpriteContent(originContent, transform);
            // @ts-expect-error
            content.filter = getStandardFilterContent(originContent.filter);
        }
    }
    else if (item.particle) {
        type = ItemType.particle;
        originContent = item.particle;
        transform = getTransform(originContent.transform, reverseParticle, true);
        content = getStandardParticleContent(originContent);
    }
    else if (item.sprite) {
        type = ItemType.sprite;
        originContent = item.sprite;
        transform = getTransform(originContent.transform, false, true);
        content = getStandardSpriteContent(originContent, transform);
    }
    else if (item.cal) {
        type = ItemType.null;
        originContent = item.cal;
        transform = getTransform(originContent.transform, false, true);
        content = getStandardNullContent(originContent, transform);
    }
    else if (item.ui) {
        type = ItemType.interact;
        originContent = item.ui;
        transform = getTransform(originContent.transform);
        content = getStandardInteractContent(originContent);
        transform.scale = [originContent.options.width || 1, originContent.options.height || 1, 1];
    }
    else if (item.model) {
        originContent = item.model;
        if (item.model.options.type === 1) {
            type = ItemType.camera;
            transform = getTransform(originContent.transform);
            content = getStandardCameraContent(originContent);
        }
    }
    if ((_a = content.renderer) === null || _a === void 0 ? void 0 : _a.anchor) {
        var anchor = new Float32Array(content.renderer.anchor);
        if (anchor[0] == stdAnchor && anchor[1] == stdAnchor) {
            delete content.renderer.anchor;
        }
        else if (opt.requires) {
            arrAdd(opt.requires, 'anchor');
        }
    }
    if (originContent) {
        var looping = (_b = originContent.options) === null || _b === void 0 ? void 0 : _b.looping;
        if (looping) {
            if (Array.isArray(looping)) {
                endBehavior = looping[1] ? ItemEndBehavior.loop : ItemEndBehavior.destroy;
            }
            else {
                endBehavior = ItemEndBehavior.loop;
            }
        }
        else {
            endBehavior = endBehavior || ((_c = originContent === null || originContent === void 0 ? void 0 : originContent.options) === null || _c === void 0 ? void 0 : _c.endBehavior) || ItemEndBehavior.destroy;
        }
        if (originContent.options.renderLevel) {
            renderLevel = originContent.options.renderLevel;
        }
        // @ts-expect-error
        if (isNaN(duration)) {
            duration = originContent.options.duration;
        }
    }
    var ret = {
        type: type,
        name: item.name,
        delay: item.delay,
        // @ts-expect-error
        duration: duration,
        id: item.id + '',
        // @ts-expect-error
        transform: transform,
        endBehavior: endBehavior,
        // @ts-expect-error
        renderLevel: renderLevel,
        content: content,
    };
    // @ts-expect-error
    if (pluginName) {
        if (opt.plugins) {
            arrAdd(opt.plugins, pluginName);
            ret.pn = opt.plugins.indexOf(pluginName);
        }
        else {
            ret.pluginName = pluginName;
        }
        // @ts-expect-error
    }
    else if (Number.isInteger(pn)) {
        // @ts-expect-error
        ret.pn = pn;
    }
    if (item.parentId) {
        ret.parentId = item.parentId + '';
    }
    return ret;
    function getTransform(originTransform, inverseRotation, changeOrder) {
        if (originTransform) {
            var transform_1 = {};
            var rotation = originTransform.rotation;
            if (rotation) {
                if (inverseRotation) {
                    transform_1.rotation = [-rotation[0], -rotation[1], -rotation[2]];
                }
                else {
                    transform_1.rotation = [rotation[0], rotation[1], rotation[2]];
                }
                if (changeOrder) {
                    var q = quatFromXYZRotation(tempQuat, transform_1.rotation[0], transform_1.rotation[1], transform_1.rotation[2]);
                    transform_1.rotation = rotationZYXFromQuat([], q);
                }
            }
            var position = originTransform.position;
            if (position) {
                transform_1.position = originTransform.position;
            }
            if (Array.isArray(originTransform.scale)) {
                transform_1.scale = [originTransform.scale[0] || 1, originTransform.scale[1] || 1, originTransform.scale[2] || 1];
            }
            return transform_1;
        }
        return {};
    }
}

var _a$4;
var renderLevelPassSet = (_a$4 = {},
    _a$4[RenderLevel$1.S] = [RenderLevel$1.S, RenderLevel$1.BPlus, RenderLevel$1.APlus],
    _a$4[RenderLevel$1.A] = [RenderLevel$1.A, RenderLevel$1.BPlus, RenderLevel$1.APlus],
    _a$4[RenderLevel$1.B] = [RenderLevel$1.B, RenderLevel$1.BPlus],
    _a$4);
function passRenderLevel(l, renderLevel) {
    if (!l || !renderLevel) {
        return true;
    }
    var arr = renderLevelPassSet[renderLevel];
    if (arr) {
        return arr.includes(l);
    }
    return false;
}

var listOrder = 0;
/**
 *
 */
var VFXItemManager = /** @class */ (function () {
    function VFXItemManager(compositions, compositionId, options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        var composition = compositions.find(function (_a) {
            var id = _a.id;
            return id === compositionId;
        });
        if (!composition) {
            throw new Error('Invalid composition id: ' + compositionId);
        }
        listOrder = 0;
        this.composition = composition;
    }
    VFXItemManager.prototype.getContent = function () {
        var _a = this.composition, id = _a.id, duration = _a.duration, name = _a.name, endBehavior = _a.endBehavior, camera = _a.camera, _b = _a.startTime, startTime = _b === void 0 ? 0 : _b;
        var items = this.assembleItems();
        return {
            id: id,
            duration: duration,
            name: name,
            endBehavior: isNaN(endBehavior) ? END_BEHAVIOR_PAUSE$1 : endBehavior,
            // looping,
            items: items,
            camera: camera,
            startTime: startTime,
        };
    };
    VFXItemManager.prototype.assembleItems = function () {
        var _this = this;
        var items = [];
        var _a = this.options, renderLevel = _a.renderLevel, jsonScene = _a.jsonScene;
        var mask = this.options.mask;
        if (isNaN(mask)) {
            mask = 0;
        }
        this.composition.items.forEach(function (item) {
            var opt = {};
            var visible = item.visible, itemRenderLevel = item.renderLevel, type = item.type;
            if (visible === false) {
                return;
            }
            var content = __assign$1({}, item.content);
            if (content) {
                opt.content = __assign$1({}, content);
                if (passRenderLevel(itemRenderLevel, renderLevel)) {
                    var renderContent = opt.content;
                    opt.type = type;
                    if (renderContent.renderer) {
                        renderContent.renderer = _this.changeTex(renderContent.renderer);
                        if (!renderContent.renderer.mask) {
                            var maskMode = renderContent.renderer.maskMode;
                            if (maskMode === MaskMode$1.MASK) {
                                renderContent.renderer.mask = ++mask;
                            }
                            else if (maskMode === MaskMode$1.OBSCURED || maskMode === MaskMode$1.REVERSE_OBSCURED) {
                                renderContent.renderer.mask = mask;
                            }
                        }
                        var split = renderContent.splits && !renderContent.textureSheetAnimation && renderContent.splits[0];
                        if (Number.isInteger(renderContent.renderer.shape)) {
                            // TODO: scene.shapes 类型问题？
                            renderContent.renderer.shape = getGeometryByShape(jsonScene.shapes[renderContent.renderer.shape], split);
                        }
                        else if (renderContent.renderer.shape && isObject(renderContent.renderer.shape)) {
                            renderContent.renderer.shape = getGeometryByShape(renderContent.renderer.shape, split);
                        }
                    }
                    else {
                        opt.content.renderer = { order: 0 };
                    }
                    if (renderContent.trails) {
                        renderContent.trails = _this.changeTex(renderContent.trails);
                    }
                    if (renderContent.filter) {
                        renderContent.filter = __assign$1({}, renderContent.filter);
                    }
                }
                var name_1 = item.name, _a = item.delay, delay = _a === void 0 ? 0 : _a, id = item.id, parentId = item.parentId, duration = item.duration, endBehavior = item.endBehavior, pluginName = item.pluginName, pn = item.pn, transform = item.transform;
                // FIXME: specification 下定义的 Item 不存在 refCount 类型定义
                // @ts-expect-error
                var refCount = item.refCount;
                var _b = jsonScene.plugins, plugins = _b === void 0 ? [] : _b;
                opt.name = name_1;
                opt.delay = delay;
                opt.id = id;
                if (parentId) {
                    opt.parentId = parentId;
                }
                opt.refCount = refCount;
                opt.duration = duration;
                opt.listIndex = listOrder++;
                opt.endBehavior = endBehavior;
                if (pluginName) {
                    opt.pluginName = pluginName;
                }
                else if (pn !== undefined && Number.isInteger(pn)) {
                    opt.pluginName = plugins[pn];
                }
                if (transform) {
                    opt.transform = transform;
                }
                items.push(opt);
            }
        });
        return items;
    };
    VFXItemManager.prototype.changeTex = function (renderer) {
        var texIdx = renderer.texture;
        var ret = __assign$1({}, renderer);
        if (texIdx !== undefined) {
            // ret._texture = ret.texture;
            ret.texture = this.addTextureUsage(texIdx) || texIdx;
        }
        return ret;
    };
    VFXItemManager.prototype.addTextureUsage = function (texIdx) {
        var _a, _b;
        if (Number.isInteger(texIdx)) {
            var tex = (_a = this.options.textures) === null || _a === void 0 ? void 0 : _a[texIdx];
            var texId = tex === null || tex === void 0 ? void 0 : tex.id;
            // FIXME: imageUsage 取自 scene.imgUsage，类型为 Record<string, number[]>，这里给的 number，类型对不上
            var imageUsage = (_b = this.options.jsonScene.imgUsage) !== null && _b !== void 0 ? _b : {};
            if (texId && imageUsage) {
                // eslint-disable-next-line no-prototype-builtins
                if (!imageUsage.hasOwnProperty(texId)) {
                    imageUsage[texId] = 0;
                }
                imageUsage[texId]++;
                return tex;
            }
        }
    };
    return VFXItemManager;
}());

var TextMetrics = /** @class */ (function () {
    function TextMetrics() {
    }
    TextMetrics.measureFont = function (font) {
        // as this method is used for preparing assets, don't recalculate things if we don't need to
        if (TextMetrics._fonts[font]) {
            return TextMetrics._fonts[font];
        }
        var properties = {
            ascent: 0,
            descent: 0,
            fontSize: 0,
        };
        var canvas = TextMetrics._canvas;
        var context = canvas.getContext('2d', { willReadFrequently: true });
        context.font = font;
        var metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);
        var height = Math.ceil(TextMetrics.HEIGHT_MULTIPLIER * baseline);
        baseline = baseline * TextMetrics.BASELINE_MULTIPLIER | 0;
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;
        var i = 0;
        var idx = 0;
        var stop = false;
        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; ++i) {
            for (var j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx += line;
            }
            else {
                break;
            }
        }
        properties.ascent = baseline - i;
        idx = pixels - line;
        stop = false;
        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; --i) {
            for (var j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx -= line;
            }
            else {
                break;
            }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        TextMetrics._fonts[font] = properties;
        return properties;
    };
    Object.defineProperty(TextMetrics, "_canvas", {
        get: function () {
            var canvas;
            if (getConfig(TEMPLATE_USE_OFFSCREEN_CANVAS)) {
                // @ts-expect-error
                canvas = window._createOffscreenCanvas(10, 10);
                TextMetrics.__canvas = canvas;
            }
            else if (!TextMetrics.__canvas) {
                canvas = document.createElement('canvas');
                canvas.width = canvas.height = 10;
                TextMetrics.__canvas = canvas;
            }
            return TextMetrics.__canvas;
        },
        enumerable: false,
        configurable: true
    });
    TextMetrics._fonts = {};
    TextMetrics.METRICS_STRING = '|ÉqÅ';
    TextMetrics.BASELINE_SYMBOL = 'M';
    TextMetrics.BASELINE_MULTIPLIER = 1.4;
    TextMetrics.HEIGHT_MULTIPLIER = 2.0;
    return TextMetrics;
}());

var genericFontFamilies = [
    'serif',
    'sans-serif',
    'monospace',
    'cursive',
    'fantasy',
    'system-ui',
];
exports.QTextWrapMode = void 0;
(function (QTextWrapMode) {
    QTextWrapMode[QTextWrapMode["Default"] = 0] = "Default";
    QTextWrapMode[QTextWrapMode["Clip"] = 1] = "Clip";
    QTextWrapMode[QTextWrapMode["Ellipsis"] = 2] = "Ellipsis";
})(exports.QTextWrapMode || (exports.QTextWrapMode = {}));
var QText = /** @class */ (function () {
    function QText(text, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        // 文本框在canvas中位置
        this.left = 0;
        this.top = 0;
        this.fontSize = 48;
        this.fontFamily = 'Arial';
        this.color = 'black';
        this.letterSpacing = 0;
        // 文本最大宽度
        this.maxLineWidth = 0;
        this.wrap = exports.QTextWrapMode.Clip;
        // 文字缩放系数
        this.scaleX = 1;
        this.scaleY = 1;
        // 文字旋转角度
        this.angle = 0;
        this.active = true;
        this.padding = 0;
        this.borderColor = '#ffffffff';
        this.borderWidth = 1;
        this.fontProperties = {
            ascent: 0,
            descent: 0,
            fontSize: 0,
        };
        this.fontVariant = 'normal';
        // 锚点位置
        this.originX = 'left';
        this.originY = 'top';
        this.ellipsis = '…';
        this.text = text;
        this.left = (_a = options.left) !== null && _a !== void 0 ? _a : 0;
        this.top = (_b = options.top) !== null && _b !== void 0 ? _b : 0;
        this.maxLineWidth = (_c = options.maxWidth) !== null && _c !== void 0 ? _c : 0;
        this.letterSpacing = (_d = options.letterSpacing) !== null && _d !== void 0 ? _d : 0;
        this.originX = 'left';
        this.originY = 'top';
        this.color = (_e = options.color) !== null && _e !== void 0 ? _e : 'black';
        this.fontFamily = (_f = options.fontFamily) !== null && _f !== void 0 ? _f : 'Arial';
        this.fontSize = (_g = options.fontSize) !== null && _g !== void 0 ? _g : 48;
        this.wrap = (_h = options.wrap) !== null && _h !== void 0 ? _h : exports.QTextWrapMode.Clip;
        // @ts-expect-error
        this.fontStyle = (_j = options.fontStyle) !== null && _j !== void 0 ? _j : 'normal';
        this.textAlign = 'left';
        this.textBaseline = 'alphabetic';
        this.fontWeight = 'normal';
        this.angle = (_k = options.angle) !== null && _k !== void 0 ? _k : 0;
        this.name = options.name || '';
    }
    QText.prototype.update = function () {
        this.updateDimension();
    };
    QText.prototype.render = function () {
        if (this.viewer === undefined) {
            return;
        }
        var ctx = this.viewer.renderContext;
        if (ctx === undefined) {
            return;
        }
        ctx.save();
        // 设置绘制文本时的坐标变换
        this.setRenderTransform(ctx);
        this.renderText(ctx);
        if (this.active) {
            this.drawBorders(ctx);
        }
        ctx.restore();
    };
    QText.prototype.init = function (viewer) {
        this.viewer = viewer;
        this.updateDimension();
    };
    QText.prototype.getLayout = function () {
        var scaleX = this.viewer.scaleX;
        var scaleY = this.viewer.scaleY;
        return {
            x: this.left * scaleX,
            y: this.top * scaleY,
            // @ts-expect-error
            width: this.width * scaleX,
            // @ts-expect-error
            height: this.height * scaleY,
        };
    };
    QText.prototype.updateDimension = function () {
        var viewer = this.viewer;
        var ctx = viewer.renderContext;
        this.configTextStyle(ctx);
        this.configTextLayout(ctx);
        var font = this.getFontDesc();
        this.fontProperties = TextMetrics.measureFont(font);
        if (this.fontProperties.fontSize === 0) {
            this.fontProperties.fontSize = this.fontSize;
            this.fontProperties.ascent = this.fontSize;
        }
        var qChars = this.createCharsFromText(ctx, this.text);
        var textWithLetterSpaceWidth = 0;
        if (qChars.length > 0) {
            var lastChar = qChars[qChars.length - 1];
            textWithLetterSpaceWidth = lastChar.left + lastChar.width;
        }
        this.chars = qChars;
        // 文本加字间距宽度
        this.maxLineWidth = textWithLetterSpaceWidth;
        // 文本框宽高度自适应文本高度
        if (this.height === undefined) {
            // this.height = this.fontSize;
            this.height = this.fontProperties.fontSize;
        }
        if (this.width === undefined) {
            this.width = this.maxLineWidth;
        }
    };
    QText.prototype.configTextStyle = function (ctx) {
        ctx.font = this.getFontDesc();
        ctx.fillStyle = this.color; // 字体颜色
    };
    QText.prototype.getFontDesc = function () {
        // build canvas api font setting from individual components. Convert a numeric this.fontSize to px
        var fontSizeString = typeof this.fontSize === 'number' ? "".concat(this.fontSize, "px") : this.fontSize;
        // Clean-up fontFamily property by quoting each font name
        // this will support font names with spaces
        var fontFamilies = (this.fontFamily).split(',');
        for (var i = fontFamilies.length - 1; i >= 0; i--) {
            // Trim any extra white-space
            var fontFamily = fontFamilies[i].trim();
            // Check if font already contains strings
            if (
            // eslint-disable-next-line no-useless-escape
            !/([\"\'])[^\'\"]+\1/.test(fontFamily) &&
                !genericFontFamilies.includes(fontFamily)) {
                fontFamily = "\"".concat(fontFamily, "\"");
            }
            fontFamilies[i] = fontFamily;
        }
        fontFamilies.push('Arial, Helvetica, sans-serif');
        return "".concat(this.fontStyle, " ").concat(this.fontVariant, " ").concat(this.fontWeight, " ").concat(fontSizeString, " ").concat((fontFamilies).join(','));
    };
    QText.prototype.configTextLayout = function (ctx) {
        ctx.textBaseline = this.textBaseline;
        ctx.textAlign = this.textAlign;
    };
    QText.prototype.setRenderTransform = function (ctx) {
        ctx.scale(this.scaleX, this.scaleY);
        ctx.translate(this.left, this.top);
        // ctx.rotate(this.angle);
    };
    QText.prototype.renderText = function (ctx) {
        // 绘制起点偏移
        var x = 0;
        var y = 0;
        this.drawCharsInTextBox(ctx, {
            min: [x, y],
            // @ts-expect-error
            max: [x + this.width, y + this.height],
        });
    };
    QText.prototype.drawCharsInTextBox = function (ctx, textBox) {
        var qChars = this.chars;
        var textWithLetterSpaceWidth = 0;
        if (qChars.length > 0) {
            var lastChar = qChars[qChars.length - 1];
            textWithLetterSpaceWidth = lastChar.left + lastChar.width;
        }
        var textBoxWidth = textBox.max[0] - textBox.min[0];
        var charOffset = 0;
        if ('left' === this.textAlign) {
            charOffset = 0;
        }
        else if ('center' === this.textAlign) {
            charOffset = 0.5 * (textBoxWidth - textWithLetterSpaceWidth);
        }
        else if ('right' === this.textAlign) {
            charOffset = textBoxWidth - textWithLetterSpaceWidth;
        }
        this.addOffsetToChars(qChars, charOffset);
        var charsInTextBox = this.cloneChars(this.clipCharsWithTextBox(qChars, textBox));
        var needDrawChars = charsInTextBox;
        if (this.wrap === exports.QTextWrapMode.Ellipsis) {
            needDrawChars = this.replaceCharWithEllipsis(ctx, charsInTextBox, textBox);
            if (needDrawChars.length === 0 && qChars.length !== 0) {
                this.addEllipsisToChars(ctx, needDrawChars, textBox);
            }
        }
        this.drawCharsFromLeft(ctx, needDrawChars);
    };
    QText.prototype.addEllipsisToChars = function (ctx, needDrawChars, textBox) {
        var _a, _b, _c;
        var ellipsisWidth = ctx.measureText(this.ellipsis).width;
        if (this.textAlign === 'left') {
            needDrawChars.push({
                char: this.ellipsis,
                left: textBox.min[0],
                top: 0,
                width: ellipsisWidth,
                heigh: (_a = this.height) !== null && _a !== void 0 ? _a : 0,
                font: this.fontFamily,
                fontSize: this.fontSize,
                isEllipsis: true,
                scale: 1,
                index: 0,
            });
        }
        else if (this.textAlign === 'right') {
            needDrawChars.push({
                char: this.ellipsis,
                left: textBox.max[0] - ellipsisWidth,
                top: 0,
                width: ellipsisWidth,
                heigh: (_b = this.height) !== null && _b !== void 0 ? _b : 0,
                font: this.fontFamily,
                fontSize: this.fontSize,
                isEllipsis: true,
                scale: 1,
                index: 0,
            });
        }
        else {
            var x = (textBox.max[0] + textBox.min[0]) * 0.5;
            needDrawChars.push({
                char: this.ellipsis,
                left: x - ellipsisWidth * 0.5,
                top: 0,
                width: ellipsisWidth,
                heigh: (_c = this.height) !== null && _c !== void 0 ? _c : 0,
                font: this.fontFamily,
                fontSize: this.fontSize,
                isEllipsis: true,
                scale: 1,
                index: 0,
            });
        }
    };
    QText.prototype.createCharsFromText = function (ctx, text) {
        var chars = text.split('');
        var x = 0;
        var y = 0;
        if (this.textBaseline === 'top') {
            y = 0;
        }
        else if (this.textBaseline === 'middle') {
            y += this.fontProperties.ascent * 0.5;
        }
        else if (this.textBaseline === 'alphabetic') {
            y += this.fontProperties.ascent;
        }
        var qChars = [];
        for (var i = 0; i < chars.length; ++i) {
            var char = chars[i];
            // in safari width maybe float number
            var charWidth = Math.floor(ctx.measureText(char).width);
            var charHeight = this.fontSize;
            var qChar = {
                left: x,
                top: y,
                width: charWidth,
                heigh: charHeight,
                char: char,
                font: this.fontFamily,
                fontSize: this.fontSize,
                isEllipsis: false,
                scale: 1,
                index: i,
            };
            qChars.push(qChar);
            x += charWidth + this.letterSpacing;
        }
        return qChars;
    };
    QText.prototype.addOffsetToChars = function (chars, offset) {
        chars.forEach(function (qChar) {
            qChar.left += offset;
        });
        return chars;
    };
    QText.prototype.clipCharsWithTextBox = function (chars, textBox) {
        var charsInTextBox = [];
        var error = 0.5;
        for (var i = 0; i < chars.length; ++i) {
            var qChar = chars[i];
            if (qChar.left >= textBox.min[0] &&
                qChar.left + qChar.width < textBox.max[0] + error) {
                charsInTextBox.push(qChar);
            }
        }
        return charsInTextBox;
    };
    QText.prototype.cloneChars = function (chars) {
        return chars.map(function (qChar) {
            return __assign$1({}, qChar);
        });
    };
    QText.prototype.replaceCharWithEllipsis = function (ctx, qCharsInTextBox, textBox) {
        var ellipsisWidth = ctx.measureText(this.ellipsis).width;
        if (qCharsInTextBox.length > 0) {
            if (qCharsInTextBox[0].index !== 0) {
                var ellipsisChar = __assign$1({}, qCharsInTextBox[0]);
                ellipsisChar.char = this.ellipsis;
                ellipsisChar.isEllipsis = true;
                ellipsisChar.width = ellipsisWidth;
                qCharsInTextBox = this.findEllipsisPositionAndReplaceCharsFromLeft(qCharsInTextBox, ellipsisChar, textBox);
            }
            var qCharsInTextBoxLastIndex = qCharsInTextBox.length - 1;
            var qCharsLength = this.chars.length;
            if (qCharsInTextBox[qCharsInTextBoxLastIndex].index !==
                qCharsLength - 1) {
                var ellipsisChar = __assign$1({}, qCharsInTextBox[0]);
                ellipsisChar.char = this.ellipsis;
                ellipsisChar.isEllipsis = true;
                ellipsisChar.width = ellipsisWidth;
                qCharsInTextBox = this.findEllipsisPositionAndReplaceCharsFromRight(qCharsInTextBox, ellipsisChar, textBox);
            }
        }
        return qCharsInTextBox;
    };
    QText.prototype.findEllipsisPositionAndReplaceCharsFromLeft = function (qCharsInTextBox, ellipsis, textBox) {
        var replaceIndex = 0;
        for (var i = 0; i < qCharsInTextBox.length; ++i) {
            var qChar = qCharsInTextBox[i];
            var qCharRight = qChar.left + qChar.width;
            replaceIndex = i;
            if (qCharRight - ellipsis.width >= textBox.min[0]) {
                break;
            }
        }
        var replacedChar = qCharsInTextBox[replaceIndex];
        ellipsis.left = replacedChar.left + replacedChar.width - ellipsis.width;
        for (var i = 0; i < replaceIndex + 1; ++i) {
            qCharsInTextBox.shift();
        }
        return [ellipsis].concat(qCharsInTextBox);
    };
    QText.prototype.findEllipsisPositionAndReplaceCharsFromRight = function (qCharsInTextBox, ellipsis, textBox) {
        var replaceIndex = qCharsInTextBox.length - 1;
        for (var i = replaceIndex; i >= 0; --i) {
            var qChar = qCharsInTextBox[i];
            var ellipsisCharRight = qChar.left + ellipsis.width;
            replaceIndex = i;
            if (ellipsisCharRight <= textBox.max[0]) {
                break;
            }
        }
        ellipsis.left = qCharsInTextBox[replaceIndex].left;
        var qCharsLength = qCharsInTextBox.length;
        for (var i = qCharsLength - 1; i >= replaceIndex; --i) {
            qCharsInTextBox.pop();
        }
        return qCharsInTextBox.concat([ellipsis]);
    };
    QText.prototype.drawCharsFromLeft = function (ctx, chars) {
        var align = ctx.textAlign || 'left';
        ctx.textAlign = 'left';
        for (var i = 0; i < chars.length; ++i) {
            var qChar = chars[i];
            ctx.fillText(qChar.char, qChar.left, qChar.top);
        }
        ctx.textAlign = align;
    };
    QText.prototype.drawBorders = function (ctx) {
        this.padding;
        var strokeWidth = this.borderWidth;
        ctx.strokeStyle = this.borderColor;
        ctx.lineWidth = strokeWidth;
        var w = this.width;
        var h = this.height;
        var x = 0;
        var y = 0;
        if (this.originX === 'center') {
            // @ts-expect-error
            x -= this.width / 2;
        }
        else if (this.originX === 'right') {
            // @ts-expect-error
            x -= this.width;
        }
        if (this.originY === 'center') {
            // @ts-expect-error
            y -= this.height / 2;
        }
        else if (this.originY === 'bottom') {
            // @ts-expect-error
            y -= this.height;
        }
        ctx.strokeRect(x + strokeWidth / 2, y + strokeWidth / 2, 
        // @ts-expect-error
        w - strokeWidth, 
        // @ts-expect-error
        h - strokeWidth);
    };
    return QText;
}());

var QCanvasViewer = /** @class */ (function () {
    function QCanvasViewer(canvas, width, height, scaleX, scaleY, flipY) {
        this.textList = [];
        var renderCanvas;
        if (typeof canvas === 'string') {
            renderCanvas = document.getElementById(canvas);
        }
        else {
            renderCanvas = canvas;
        }
        // canvas缩放比例
        this.scaleX = scaleX !== null && scaleX !== void 0 ? scaleX : 1.0;
        this.scaleY = scaleY !== null && scaleY !== void 0 ? scaleY : 1.0;
        this.flipY = flipY !== null && flipY !== void 0 ? flipY : false;
        // 保存传入canvas宽度和高度信息
        this.width = width;
        this.height = height;
        // canvas的css尺寸
        renderCanvas.style.width = "".concat(width * this.scaleX, "px");
        renderCanvas.style.height = "".concat(height * this.scaleY, "px");
        // canvas的画布尺寸
        // const devicePixelRatio = window.devicePixelRatio ?? 1.0;
        var devicePixelRatio = 1;
        this.devicePixelRatio = devicePixelRatio;
        renderCanvas.width = devicePixelRatio * width * this.scaleX;
        renderCanvas.height = devicePixelRatio * height * this.scaleY;
        renderCanvas.className = 'lower-canvas';
        // renderCanvas.style.position = 'absolute';
        this.renderCanvas = renderCanvas;
        this.renderContext = this.renderCanvas.getContext('2d');
        // 画布坐标系需要进行比缩放（）
        this.renderContext.scale(devicePixelRatio * this.scaleX, devicePixelRatio * this.scaleY);
    }
    QCanvasViewer.prototype.initDimension = function (width, height, scaleX, scaleY) {
        this.width = width;
        this.height = height;
        this.scaleX = scaleX !== null && scaleX !== void 0 ? scaleX : 1.0;
        this.scaleY = scaleY !== null && scaleY !== void 0 ? scaleY : 1.0;
        this.renderCanvas.style.width = "".concat(width * this.scaleX, "px");
        this.renderCanvas.style.height = "".concat(height * this.scaleY, "px");
        // 改变canvas的尺寸会导致重置画布的所有状态
        var devicePixelRatio = this.devicePixelRatio;
        this.renderCanvas.width = devicePixelRatio * width * this.scaleX;
        this.renderCanvas.height = devicePixelRatio * height * this.scaleY;
        if (this.flipY) {
            this.renderContext.translate(0, this.height);
            this.renderContext.scale(1, -1);
        }
        this.renderContext.scale(devicePixelRatio * this.scaleX, devicePixelRatio * this.scaleY);
    };
    QCanvasViewer.prototype.clearText = function () {
        this.textList = [];
    };
    QCanvasViewer.prototype.clearCanvasWithContext = function (ctx) {
        ctx.clearRect(0, 0, this.width, this.height);
    };
    QCanvasViewer.prototype.clearCanvas = function () {
        this.clearCanvasWithContext(this.renderContext);
    };
    QCanvasViewer.prototype.addObject = function (text) {
        text.init(this);
        this.textList.push(text);
    };
    QCanvasViewer.prototype.render = function () {
        // 清空画布
        this.clearCanvasWithContext(this.renderContext);
        this.renderContext.fillStyle = 'rgba(255, 255, 255, 0.0039)';
        this.renderContext.fillRect(0, 0, this.width, this.height);
        var image = this.background;
        if (image && image.width !== undefined && image.height !== undefined) {
            this.renderContext.drawImage(image, 0, 0, image.width, image.height, 0, 0, this.width, this.height);
        }
        for (var i = 0; i < this.textList.length; ++i) {
            this.renderContext.save();
            var text = this.textList[i];
            text.update();
            text.render();
            this.renderContext.restore();
        }
    };
    return QCanvasViewer;
}());

function requestAsync(url, opt) {
    opt = opt || {};
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.responseType = (opt === null || opt === void 0 ? void 0 : opt.responseType) || 'json';
        xhr.addEventListener('load', function () { return resolve(xhr.response); });
        xhr.addEventListener('error', function () { return reject(Error("load ".concat(url, " fail"))); });
        xhr.open((opt === null || opt === void 0 ? void 0 : opt.method) || 'get', url);
        xhr.send(opt === null || opt === void 0 ? void 0 : opt.data);
    });
}
/**
 *
 * @since 2.0.0
 * @param url
 * @param template
 * @param variables
 * @param opts
 * @param flipY
 * @returns
 */
function combineImageTemplate1(url, template, variables, opts, flipY) {
    return __awaiter(this, void 0, void 0, function () {
        var replacedVariables, pendings, name_1, replaceURL, onImage, imageScale, bg, content, fg, canvas;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    replacedVariables = {};
                    pendings = [];
                    opts = opts || {};
                    variables = variables || {};
                    if (template.asImage) {
                        name_1 = template.content.replace(/\$/g, '');
                        replaceURL = variables[name_1] || template.variables[name_1];
                        onImage = function (image) {
                            var canvas = (opts === null || opts === void 0 ? void 0 : opts.canvas) || document.createElement('canvas');
                            var width = canvas.width = template.backgroundWidth;
                            var height = canvas.height = template.backgroundHeight;
                            var ctx = canvas.getContext('2d');
                            ctx === null || ctx === void 0 ? void 0 : ctx.clearRect(0, 0, width, height);
                            if (flipY) {
                                ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, height);
                                ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);
                            }
                            ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
                            return canvas;
                        };
                        if (replaceURL) {
                            return [2 /*return*/, loadImage(replaceURL).then(onImage)];
                        }
                        return [2 /*return*/, loadURL(url).then(onImage)];
                    }
                    imageScale = opts.templateScale || 1;
                    Object.keys(template.variables).forEach(function (name) {
                        var val = template.variables[name];
                        // eslint-disable-next-line no-prototype-builtins
                        if (variables.hasOwnProperty(name)) {
                            // @ts-expect-error
                            val = variables[name];
                        }
                        if (/^image_/.test(name)) {
                            var isArr = val instanceof Array;
                            // @ts-expect-error
                            var first = isArr ? val[0] : val;
                            // @ts-expect-error
                            pendings.push(requestImageBase64(first, isArr && val[1]).then(function (dataURL) { return replacedVariables[name] = dataURL; }));
                        }
                        else {
                            replacedVariables[name] = val;
                        }
                    });
                    return [4 /*yield*/, Promise.all(pendings)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, loadImage(url)];
                case 2:
                    bg = _a.sent();
                    content = template.content
                        .replace(/\$([\w_]+)\$/g, function (str, name) { return replacedVariables[name]; })
                        .replace("width=\"".concat(template.width, "px\""), "width=\"".concat(template.width * imageScale, "px\""))
                        .replace("height=\"".concat(template.height, "px\""), "height=\"".concat(template.height * imageScale, "px\""));
                    return [4 /*yield*/, loadImage("data:image/svg+xml,".concat(encodeURIComponent(content)))];
                case 3:
                    fg = _a.sent();
                    canvas = (opts === null || opts === void 0 ? void 0 : opts.canvas) || document.createElement('canvas');
                    canvas.width = bg.width * imageScale;
                    canvas.height = bg.height * imageScale;
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            // FIXME: 先注释掉setTimeout
                            // fix ios 14 bug, image may not be drawn
                            // setTimeout(() => {
                            var ctx = canvas.getContext('2d');
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            if (flipY) {
                                ctx.translate(0, canvas.height);
                                ctx.scale(1, -1);
                            }
                            ctx.drawImage(bg, 0, 0, bg.width, bg.height, 0, 0, canvas.width, canvas.height);
                            ctx.drawImage(fg, 0, 0, fg.width, fg.height, (template.x || 0) * imageScale, (template.y || 0) * imageScale, template.width * imageScale / template.backgroundWidth * bg.width, template.height * imageScale / template.backgroundHeight * bg.height);
                            resolve(canvas);
                            //}, 0);
                        })];
            }
        });
    });
}
/**
 * @internal
 * @deprecated since 2.0.0 - use `combineImageTemplate1` instead
 */
function combineImageTemplate1Async(url, template, variables, opts, flipY) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            console.warn('The combineImageTemplate1Async function is deprecated. Use combineImageTemplate1 instead.');
            return [2 /*return*/, combineImageTemplate1(url, template, variables, opts, flipY)];
        });
    });
}
function loadURL(url) {
    return isString(url) ? loadImage(url) : Promise.resolve(url);
}
function requestImageBase64(first, alt) {
    return req(first, function (ex) {
        return alt ? req(alt, function () { return first; }) : first;
    });
    function req(val, onError) {
        if (/^(https?:)?\/\//.test(val)) {
            // @ts-expect-error
            return requestAsync(val, { responseType: 'blob' }).then(blobToBase64, onError);
        }
        return Promise.resolve(val);
    }
}
function blobToBase64(blob) {
    return new Promise(function (resolve, reject) {
        var reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onload = function () {
            resolve(reader.result);
        };
        reader.onerror = reject;
    });
}

var DEFAULT_FONTS = [
    'serif',
    'sans-serif',
    'monospace',
    'courier',
];
var defaultWidth = 800;
var defaultHeight = 600;
var viewerCanvasMap = new Map();
var CanvasPool = /** @class */ (function () {
    function CanvasPool() {
        this.elements = [];
    }
    CanvasPool.prototype.getCanvas = function () {
        if (this.elements.length) {
            // @ts-expect-error
            return this.elements.shift();
        }
        if (getConfig(TEMPLATE_USE_OFFSCREEN_CANVAS)) {
            // @ts-expect-error
            return window._createOffscreenCanvas(10, 10);
        }
        else {
            // in hongmeng system,create too many canvas will case render error
            var defCanvas = document.createElement('canvas');
            defCanvas.getContext('2d', { willReadFrequently: true });
            return defCanvas;
        }
    };
    CanvasPool.prototype.saveCanvas = function (cvs) {
        cvs.width = cvs.height = 1;
        if (this.elements.length < 3) {
            addItem(this.elements, cvs);
        }
        else {
            cvs.remove();
        }
    };
    return CanvasPool;
}());
var canvasPool = new CanvasPool();
function getDefaultTemplateCanvasPool() {
    return canvasPool;
}
function getCanvasViewer(width, height, opt) {
    var viewer;
    var scale = (opt === null || opt === void 0 ? void 0 : opt.templateScale) || 1.0;
    var flipY = (opt === null || opt === void 0 ? void 0 : opt.flipY) || false;
    if (opt === null || opt === void 0 ? void 0 : opt.canvas) {
        viewer = viewerCanvasMap.get(opt.canvas);
        if (!viewer) {
            var newViewer = new QCanvasViewer(opt.canvas, width, height, scale, scale, flipY);
            viewerCanvasMap.set(opt.canvas, newViewer);
            viewer = newViewer;
        }
    }
    else {
        var canvas = canvasPool.getCanvas();
        viewer = new QCanvasViewer(canvas, defaultWidth, defaultHeight, scale, scale, flipY);
    }
    return viewer;
}
function convert2QTextList(stringTemplateContent, variables, opt) {
    // 创建文本绘制对象
    var fonts = stringTemplateContent.fonts;
    var qTextList = [];
    stringTemplateContent.texts.forEach(function (text) {
        var _a;
        var textString = text.t;
        var left = text.x;
        var top = text.y;
        // 字体属性
        var font = {
            weight: 400,
            family: 'serif',
            size: 48,
            style: FontStyle$1.normal,
        };
        if (text.f !== undefined) {
            font = fonts[text.f];
        }
        // 文字替换
        var name = text.n;
        // eslint-disable-next-line no-prototype-builtins
        if (name && variables && variables.hasOwnProperty(name)) {
            textString = "".concat(variables[name]);
        }
        // 创建文字对象
        var qtext = new QText(textString, {
            left: left,
            top: top,
            fontSize: font.size,
            fontFamily: font.family,
            fontWeight: "".concat(font.weight),
            fontStyle: 'normal',
            name: name,
        });
        // @ts-expect-error
        if (text.r !== undefined) {
            // @ts-expect-error
            qtext.angle = (text.r * Math.PI / 180);
        }
        qtext.active = (_a = opt === null || opt === void 0 ? void 0 : opt.debug) !== null && _a !== void 0 ? _a : false;
        //文字最大宽度
        if (text.w !== undefined) {
            qtext.width = text.w;
        }
        // 字间距
        if (font.letterSpace !== undefined) {
            qtext.letterSpacing = font.letterSpace;
        }
        // 超过最大宽度行为
        if (text.of === 0) {
            qtext.wrap = exports.QTextWrapMode.Default;
        }
        else if (text.of === 1) {
            qtext.wrap = exports.QTextWrapMode.Clip;
        }
        else if (text.of === 2) {
            qtext.wrap = exports.QTextWrapMode.Ellipsis;
        }
        // 文字颜色
        if (text.c !== undefined) {
            var textColor = stringTemplateContent.colors[text.c][1];
            var alpha = 1.0;
            if (textColor[3] !== undefined) {
                alpha = textColor[3] / 255;
            }
            qtext.color = "rgba(".concat(textColor[0], ", ").concat(textColor[1], ", ").concat(textColor[2], ", ").concat(alpha, ")");
        }
        // 文字对齐方式
        if (text.a === TextAlignment$1.left) {
            qtext.textAlign = 'left';
        }
        else if (text.a === TextAlignment$1.middle) {
            qtext.textAlign = 'center';
        }
        else if (text.a === TextAlignment$1.right) {
            qtext.textAlign = 'right';
        }
        // 文字style
        if (font.style === 0) {
            qtext.fontStyle = 'normal';
        }
        else if (font.style === 1) {
            qtext.fontStyle = 'italic';
        }
        else if (font.style === 2) {
            qtext.fontStyle = 'oblique';
        }
        // 文字weight
        if (font.weight !== undefined) {
            qtext.fontWeight = String(font.weight);
        }
        // 边框颜色
        if (opt === null || opt === void 0 ? void 0 : opt.borderColor) {
            qtext.borderColor = opt.borderColor;
        }
        if ((opt === null || opt === void 0 ? void 0 : opt.borderWidth) !== undefined) {
            qtext.borderWidth = opt.borderWidth;
        }
        qTextList.push(qtext);
    });
    return qTextList;
}
function getBackgroundImage(template, variables) {
    var _a, _b;
    var templateBackground;
    if ((_a = template === null || template === void 0 ? void 0 : template.background) === null || _a === void 0 ? void 0 : _a.name) {
        var name_1 = template.background.name;
        if (variables && variables[name_1]) {
            templateBackground = variables[name_1];
        }
        else if ((_b = template.background) === null || _b === void 0 ? void 0 : _b.url) {
            templateBackground = template.background.url;
        }
    }
    return templateBackground;
}
function drawImageAndTemplate(viewer, image, template, variables, opt) {
    var _a;
    return __awaiter(this, void 0, void 0, function () {
        var templateScale, scaleX, scaleY, drawImage, width, height, templateBackground, _b, stringTemplateContent, qTextList, textLayouts;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!image) {
                        throw Error('image not provided');
                    }
                    templateScale = (opt === null || opt === void 0 ? void 0 : opt.templateScale) || 1;
                    scaleX = templateScale;
                    scaleY = templateScale;
                    drawImage = image;
                    width = image.width;
                    height = image.height;
                    if (!template) return [3 /*break*/, 5];
                    width = template.width;
                    height = template.height;
                    if (image.width !== width || image.height !== height) {
                        //in webgl1 image will resize to pot
                        //so scale template to image size
                        scaleX *= (image.width / template.width);
                        scaleY *= (image.height / template.height);
                    }
                    templateBackground = getBackgroundImage(template, variables);
                    if (!(templateBackground && templateBackground !== image.src)) return [3 /*break*/, 4];
                    if (!isString(templateBackground)) return [3 /*break*/, 2];
                    return [4 /*yield*/, loadImage(templateBackground)];
                case 1:
                    _b = _c.sent();
                    return [3 /*break*/, 3];
                case 2:
                    _b = templateBackground;
                    _c.label = 3;
                case 3:
                    // @ts-expect-error
                    drawImage = _b;
                    _c.label = 4;
                case 4:
                    stringTemplateContent = template.content;
                    if (stringTemplateContent) {
                        qTextList = convert2QTextList(stringTemplateContent, variables, __assign$1(__assign$1({}, opt), { scaleX: scaleX, scaleY: scaleY }));
                        qTextList.forEach(function (qText) {
                            viewer.addObject(qText);
                        });
                    }
                    _c.label = 5;
                case 5:
                    viewer.flipY = (_a = opt === null || opt === void 0 ? void 0 : opt.flipY) !== null && _a !== void 0 ? _a : false;
                    viewer.initDimension(width, height, scaleX, scaleY);
                    // 设置背景图
                    viewer.background = drawImage;
                    // 将文本绘制到canvas上
                    viewer.render();
                    textLayouts = opt === null || opt === void 0 ? void 0 : opt.textLayouts;
                    if (textLayouts) {
                        // 清空数组
                        textLayouts.length = 0;
                        // 返回文本的布局对象
                        viewer.textList.forEach(function (qText) {
                            var layout = qText.getLayout();
                            var textLayout = {
                                x: layout.x,
                                y: layout.y,
                                width: layout.width,
                                height: layout.height,
                            };
                            textLayouts.push(textLayout);
                        });
                    }
                    return [2 /*return*/];
            }
        });
    });
}
function prepareFontResources(template) {
    return __awaiter(this, void 0, void 0, function () {
        var fontDescList, _loop_1, i;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(template.content && template.content.fonts)) return [3 /*break*/, 4];
                    fontDescList = template.content.fonts;
                    _loop_1 = function (i) {
                        var name_2, url, hasFontAdd, source, fontFace;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    name_2 = fontDescList[i].family;
                                    url = fontDescList[i].url;
                                    hasFontAdd = false;
                                    if (DEFAULT_FONTS.includes(name_2)) {
                                        hasFontAdd = true;
                                    }
                                    else {
                                        if (document.fonts !== undefined) {
                                            document.fonts.forEach(function (fontFace) {
                                                if (fontFace.family === name_2) {
                                                    hasFontAdd = true;
                                                }
                                            });
                                        }
                                    }
                                    if (!(!hasFontAdd && url !== undefined && url !== '')) return [3 /*break*/, 2];
                                    source = "url(".concat(url, ")");
                                    if (!(document.fonts !== undefined)) return [3 /*break*/, 2];
                                    fontFace = new FontFace("".concat(name_2), source);
                                    return [4 /*yield*/, fontFace.load()];
                                case 1:
                                    _b.sent();
                                    // @ts-expect-error
                                    document.fonts.add(fontFace);
                                    _b.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    };
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < fontDescList.length)) return [3 /*break*/, 4];
                    return [5 /*yield**/, _loop_1(i)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    ++i;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    });
}
/**
 * @since 2.0.0
 * @param {string|HTMLImageElement} url
 * @param {TemplateContentV2} [template]
 * @param {Record<string, number | string>} [variables]
 * @param {TemplateOptions} [opts]
 * @param {boolean} [flipY]
 * @returns
 */
function combineImageTemplate2(url, template, variables, opts, flipY) {
    return __awaiter(this, void 0, void 0, function () {
        var templateOption, viewer, image;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    templateOption = __assign$1(__assign$1({}, opts), { flipY: flipY });
                    viewer = getCanvasViewer(defaultWidth, defaultWidth, templateOption);
                    if (!(template !== undefined)) return [3 /*break*/, 2];
                    return [4 /*yield*/, prepareFontResources(template)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    // 清空文本
                    viewer.clearText();
                    if (!(typeof url === 'string')) return [3 /*break*/, 5];
                    return [4 /*yield*/, loadImage(url)];
                case 3:
                    image = _a.sent();
                    return [4 /*yield*/, drawImageAndTemplate(viewer, image, template, variables, templateOption)];
                case 4:
                    _a.sent();
                    return [2 /*return*/, getResult(viewer.renderCanvas, opts === null || opts === void 0 ? void 0 : opts.toData)];
                case 5: return [4 /*yield*/, drawImageAndTemplate(viewer, url, template, variables, templateOption)];
                case 6:
                    _a.sent();
                    return [2 /*return*/, getResult(viewer.renderCanvas, opts === null || opts === void 0 ? void 0 : opts.toData)];
            }
        });
    });
}
/**
 * @internal
 * @deprecated since 2.0.0 - use `combineImageTemplate2` instead
 */
function combineImageTemplate2Async(url, template, variables, opts, flipY) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            console.warn('The combineImageTemplate2Async function is deprecated. Use combineImageTemplate2 instead.');
            return [2 /*return*/, combineImageTemplate2(url, template, variables, opts, flipY)];
        });
    });
}
/**
 * @since 2.0.0
 * @param url
 * @param template
 * @param variables
 * @param opts
 * @param flipY
 * @returns
 */
function combineImageTemplate(url, template, variables, opts, flipY) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (template.v === 2) {
                return [2 /*return*/, combineImageTemplate2(url, template, variables, {
                        templateScale: opts === null || opts === void 0 ? void 0 : opts.templateScale,
                        toData: true,
                    }, flipY)];
            }
            return [2 /*return*/, combineImageTemplate1(url, template, variables, opts, flipY)];
        });
    });
}
/**
 * @internal
 * @deprecated since 2.0.0 - use `combineImageTemplate` instead
 */
function combineImageTemplateAsync(url, template, variables, opts, flipY) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            console.warn('The combineImageTemplateAsync function is deprecated. Use combineImageTemplate instead.');
            return [2 /*return*/, combineImageTemplate(url, template, variables, opts, flipY)];
        });
    });
}
// TODO: 无用的函数
function getResult(cvs, toData) {
    if (toData) {
        return Promise.resolve(cvs);
    }
    return Promise.resolve(cvs);
}

var seed$5 = 1;
/**
 * 资源管理器
 * 用于加载和动效中所有的资源文件，包括图片、插件、图层粒子数据等
 */
var AssetManager = /** @class */ (function () {
    /**
     * 构造函数
     * @param options - 场景加载参数
     * @param downloader - 资源下载对象
     */
    function AssetManager(options, downloader) {
        if (options === void 0) { options = {}; }
        if (downloader === void 0) { downloader = new Downloader(); }
        this.options = options;
        this.downloader = downloader;
        /**
         * 图像资源，用于创建和释放GPU纹理资源
         */
        this.assets = {};
        this.id = seed$5++;
        if (!options.pluginData) {
            options.pluginData = {};
        }
        var _a = options.timeout, timeout = _a === void 0 ? 10 : _a;
        this.timeout = timeout;
    }
    /**
     * Mars 场景创建
     * 通过 json 创建出 Mars 的场景对象，并进行提前编译等工作
     * @param url - json 的 URL 链接或者 json 对象
     * @param shaderLibrary - shaderLibrary 对象，用于管理、编译 shader
     * @returns Mars 场景对象
     */
    AssetManager.prototype.loadScene = function (url, shaderLibrary) {
        return __awaiter(this, void 0, void 0, function () {
            var rawJSON, timeLabel, startTime, timeInfos, asyncShaderCompile, loadTimer, cancelLoading, waitPromise, hookTimeInfo, loadResourcePromise;
            var _this = this;
            return __generator(this, function (_a) {
                timeLabel = "Load asset: ".concat(isString(url) ? url : this.id);
                startTime = performance.now();
                timeInfos = [];
                asyncShaderCompile = GPUCapability.getInstance().detail.asyncShaderCompile;
                cancelLoading = false;
                waitPromise = new Promise(function (resolve, reject) {
                    return loadTimer = window.setTimeout(function () {
                        cancelLoading = true;
                        reject("Load time out: ".concat(url));
                    }, _this.timeout * 1000);
                });
                hookTimeInfo = function (label, func) { return __awaiter(_this, void 0, void 0, function () {
                    var st, result;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!!cancelLoading) return [3 /*break*/, 2];
                                st = performance.now();
                                return [4 /*yield*/, func()];
                            case 1:
                                result = _a.sent();
                                timeInfos.push("[".concat(label, ": ").concat((performance.now() - st).toFixed(2), "]"));
                                return [2 /*return*/, result];
                            case 2: throw new Error('load canceled.');
                        }
                    });
                }); };
                loadResourcePromise = function () { return __awaiter(_this, void 0, void 0, function () {
                    var _a, usedImages, jsonScene, _b, bins, images, compositions, _c, loadedBins, loadedImages, loadedTextures, scene, totalTime;
                    var _this = this;
                    return __generator(this, function (_d) {
                        switch (_d.label) {
                            case 0:
                                if (!isObject(url)) return [3 /*break*/, 1];
                                // TODO: 原 JSONLoader contructor 判断是否兼容
                                rawJSON = url;
                                this.baseUrl = location.href;
                                return [3 /*break*/, 3];
                            case 1:
                                // 兼容相对路径
                                url = new URL(url, location.href).href;
                                this.baseUrl = url;
                                return [4 /*yield*/, hookTimeInfo('loadJSON', function () { return _this.loadJSON(url); })];
                            case 2:
                                rawJSON = _d.sent();
                                _d.label = 3;
                            case 3: return [4 /*yield*/, hookTimeInfo('processJSON', function () { return _this.processJSON(rawJSON); })];
                            case 4:
                                _a = _d.sent(), usedImages = _a.usedImages, jsonScene = _a.jsonScene;
                                _b = jsonScene.bins, bins = _b === void 0 ? [] : _b, images = jsonScene.images, compositions = jsonScene.compositions;
                                return [4 /*yield*/, Promise.all([
                                        hookTimeInfo('processBins', function () { return _this.processBins(bins); }),
                                        hookTimeInfo('processImages', function () { return _this.processImages(images, usedImages); }),
                                        hookTimeInfo("".concat(asyncShaderCompile ? 'async' : 'sync', " compile"), function () { return _this.precompile(compositions, shaderLibrary); }),
                                    ])];
                            case 5:
                                _c = __read$1.apply(void 0, [_d.sent(), 2]), loadedBins = _c[0], loadedImages = _c[1];
                                return [4 /*yield*/, hookTimeInfo('processTextures', function () { return _this.processTextures(loadedImages, loadedBins, jsonScene); })];
                            case 6:
                                loadedTextures = _d.sent();
                                scene = {
                                    jsonScene: jsonScene,
                                    images: loadedImages,
                                    textureOptions: loadedTextures,
                                    bins: loadedBins,
                                    storage: {},
                                    pluginSystem: this.pluginSystem,
                                    renderLevel: this.options.renderLevel,
                                    totalTime: 0,
                                    startTime: 0,
                                    url: url,
                                };
                                // 触发插件系统 pluginSystem 的回调 prepareResource
                                return [4 /*yield*/, hookTimeInfo('processPlugins', function () { return _this.pluginSystem.loadResources(scene, _this.options); })];
                            case 7:
                                // 触发插件系统 pluginSystem 的回调 prepareResource
                                _d.sent();
                                totalTime = performance.now() - startTime;
                                console.debug("".concat(timeLabel, ": ").concat(totalTime.toFixed(4), "ms, ").concat(timeInfos.join(' ')));
                                window.clearTimeout(loadTimer);
                                scene.totalTime = totalTime;
                                scene.startTime = startTime;
                                return [2 /*return*/, scene];
                        }
                    });
                }); };
                return [2 /*return*/, Promise.race([waitPromise, loadResourcePromise()])];
            });
        });
    };
    AssetManager.prototype.precompile = function (compositions, shaderLibrary) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!shaderLibrary) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.pluginSystem.precompile(compositions, shaderLibrary)];
                    case 1:
                        _a.sent();
                        if (this.options.pendingCompile) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve) {
                                shaderLibrary.compileAllShaders(function () {
                                    resolve(null);
                                });
                            })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    AssetManager.prototype.processJSON = function (json) {
        return __awaiter(this, void 0, void 0, function () {
            var jsonScene, _a, plugins, sceneCompositions, imgUsage, images, compositions, _b, renderLevel, optCompositions, usedImages, _loop_1, i;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        jsonScene = getStandardJSON(json);
                        _a = jsonScene.plugins, plugins = _a === void 0 ? [] : _a, sceneCompositions = jsonScene.compositions, imgUsage = jsonScene.imgUsage, images = jsonScene.images;
                        this.pluginSystem = new PluginSystem(plugins);
                        return [4 /*yield*/, this.pluginSystem.processRawJSON(jsonScene, this.options)];
                    case 1:
                        _c.sent();
                        compositions = [];
                        _b = this.options, renderLevel = _b.renderLevel, optCompositions = _b.compositions;
                        usedImages = {};
                        if (optCompositions) {
                            _loop_1 = function (i) {
                                var name_1 = optCompositions[i];
                                var comp = sceneCompositions.find(function (c) { return c.name === name_1; });
                                if (comp) {
                                    compositions.push(comp);
                                }
                                else {
                                    throw new Error('composition not found');
                                }
                            };
                            for (i = 0; i < optCompositions.length; i++) {
                                _loop_1(i);
                            }
                        }
                        else {
                            compositions = sceneCompositions;
                        }
                        if (imgUsage) {
                            // TODO: 考虑放到独立的 fix 文件
                            fixOldImageUsage(usedImages, compositions, imgUsage, images, renderLevel);
                        }
                        else {
                            images === null || images === void 0 ? void 0 : images.forEach(function (_, i) {
                                usedImages[i] = true;
                            });
                        }
                        return [2 /*return*/, {
                                usedImages: usedImages,
                                jsonScene: jsonScene,
                            }];
                }
            });
        });
    };
    AssetManager.prototype.processBins = function (bins) {
        return __awaiter(this, void 0, void 0, function () {
            var renderLevel, jobs;
            var _this = this;
            return __generator(this, function (_a) {
                renderLevel = this.options.renderLevel;
                jobs = bins.map(function (bin) {
                    if (bin instanceof ArrayBuffer) {
                        return bin;
                    }
                    if (passRenderLevel(bin.renderLevel, renderLevel)) {
                        return _this.loadBins(bin.url);
                    }
                    throw new Error("Invalid bins source: ".concat(bins));
                });
                return [2 /*return*/, Promise.all(jobs)];
            });
        });
    };
    AssetManager.prototype.processImages = function (images, usage) {
        return __awaiter(this, void 0, void 0, function () {
            var detail, supportedCompressedTexture, _a, useCompressedTexture, variables, baseUrl, jobs;
            var _this = this;
            return __generator(this, function (_b) {
                detail = GPUCapability.getInstance().detail;
                supportedCompressedTexture = detail.compressedTexture;
                _a = this.options, useCompressedTexture = _a.useCompressedTexture, variables = _a.variables;
                baseUrl = this.baseUrl;
                jobs = images.map(function (img, idx) { return __awaiter(_this, void 0, void 0, function () {
                    var png, webp, imageURL, webpURL, template, result, url_1, name_2, templateImage, loop, compressed, src, bufferURL, _a, url, image;
                    var _b, _c, _d;
                    return __generator(this, function (_e) {
                        switch (_e.label) {
                            case 0:
                                if (!usage[idx]) return [3 /*break*/, 19];
                                png = img.url, webp = img.webp;
                                imageURL = new URL(png, baseUrl).href;
                                webpURL = webp && new URL(webp, baseUrl).href;
                                if (!('template' in img)) return [3 /*break*/, 16];
                                template = img.template;
                                result = void 0;
                                if (!('v' in template && template.v === 2 && template.background)) return [3 /*break*/, 9];
                                url_1 = getBackgroundImage(template, variables);
                                if (!(url_1 instanceof Array)) return [3 /*break*/, 6];
                                name_2 = template.background.name;
                                _e.label = 1;
                            case 1:
                                _e.trys.push([1, 3, , 5]);
                                _b = {};
                                return [4 /*yield*/, loadImage(url_1[0])];
                            case 2:
                                result = (_b.image = _e.sent(),
                                    _b.url = url_1[0],
                                    _b);
                                return [3 /*break*/, 5];
                            case 3:
                                _e.sent();
                                _c = {};
                                return [4 /*yield*/, loadImage(url_1[1])];
                            case 4:
                                result = (_c.image = _e.sent(),
                                    _c.url = url_1[1],
                                    _c);
                                return [3 /*break*/, 5];
                            case 5:
                                if (variables) {
                                    variables[name_2] = result.url;
                                }
                                return [3 /*break*/, 8];
                            case 6:
                                if (!(typeof url_1 === 'string')) return [3 /*break*/, 8];
                                _d = {};
                                return [4 /*yield*/, loadImage(url_1)];
                            case 7:
                                result = (_d.image = _e.sent(),
                                    _d.url = url_1,
                                    _d);
                                _e.label = 8;
                            case 8: return [3 /*break*/, 11];
                            case 9: return [4 /*yield*/, loadWebPOptional(imageURL, webpURL)];
                            case 10:
                                // 测试场景：'年兽大爆炸——8个彩蛋t1'
                                result = _e.sent();
                                _e.label = 11;
                            case 11:
                                templateImage = void 0;
                                _e.label = 12;
                            case 12:
                                _e.trys.push([12, 14, , 15]);
                                return [4 /*yield*/, combineImageTemplate(result.image, template, variables, this.options, img.oriY === -1)];
                            case 13:
                                templateImage = _e.sent();
                                return [3 /*break*/, 15];
                            case 14:
                                _e.sent();
                                throw new Error("image template fail: ".concat(imageURL));
                            case 15: return [2 /*return*/, templateImage];
                            case 16:
                                if ('type' in img && img.type === 'video') {
                                    loop = img.loop;
                                    // 视频
                                    return [2 /*return*/, loadVideo(img.url, { loop: loop })];
                                }
                                else if ('compressed' in img && useCompressedTexture && supportedCompressedTexture) {
                                    compressed = img.compressed;
                                    src = void 0;
                                    if (supportedCompressedTexture === COMPRESSED_TEXTURE.ASTC) {
                                        src = compressed.astc;
                                    }
                                    else if (supportedCompressedTexture === COMPRESSED_TEXTURE.PVRTC) {
                                        src = compressed.pvrtc;
                                    }
                                    if (src) {
                                        bufferURL = new URL(src, baseUrl).href;
                                        this.assets[idx] = { url: bufferURL, type: exports.TextureSourceType.compressed };
                                        return [2 /*return*/, this.loadBins(bufferURL)];
                                    }
                                }
                                else if ('sourceType' in img) {
                                    // Mars RI Texture
                                    return [2 /*return*/, img];
                                }
                                else if (img instanceof HTMLImageElement ||
                                    img instanceof HTMLCanvasElement ||
                                    img instanceof HTMLVideoElement) {
                                    return [2 /*return*/, img];
                                }
                                _e.label = 17;
                            case 17: return [4 /*yield*/, loadWebPOptional(imageURL, webpURL)];
                            case 18:
                                _a = _e.sent(), url = _a.url, image = _a.image;
                                this.assets[idx] = { url: url, type: exports.TextureSourceType.image };
                                return [2 /*return*/, image];
                            case 19: return [2 /*return*/, undefined];
                        }
                    });
                }); });
                return [2 /*return*/, Promise.all(jobs)];
            });
        });
    };
    AssetManager.prototype.processTextures = function (images, bins, jsonScene) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var textures, jobs;
            var _this = this;
            return __generator(this, function (_b) {
                textures = (_a = jsonScene.textures) !== null && _a !== void 0 ? _a : images.map(function (img, source) { return ({ source: source }); });
                jobs = textures.map(function (texOpts, idx) {
                    if ('mipmaps' in texOpts) {
                        try {
                            return deserializeMipmapTexture(texOpts, bins, jsonScene.bins);
                        }
                        catch (e) {
                            throw new Error("load texture ".concat(idx, " fails, error message: ").concat(e));
                        }
                    }
                    var source = texOpts.source;
                    var image = images[source];
                    if (image) {
                        var tex = createTextureOptionsBySource(image, _this.assets[idx]);
                        return tex.sourceType === exports.TextureSourceType.compressed ? tex : __assign$1(__assign$1({}, tex), texOpts);
                    }
                    throw new Error("Invalid texture source: ".concat(source));
                });
                return [2 /*return*/, Promise.all(jobs)];
            });
        });
    };
    AssetManager.prototype.loadJSON = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.downloader.downloadJSON(url, resolve, function (status, responseText) {
                            reject("Couldn't load JSON ".concat(url, ": status ").concat(status, ", ").concat(responseText));
                        });
                    })];
            });
        });
    };
    AssetManager.prototype.loadBins = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.downloader.downloadBinary(url, resolve, function (status, responseText) {
                            reject("Couldn't load bins ".concat(url, ": status ").concat(status, ", ").concat(responseText));
                        });
                    })];
            });
        });
    };
    /**
     * 销毁方法
     */
    AssetManager.prototype.dispose = function () {
        var _a;
        for (var key in this.assets) {
            var asset = this.assets[key];
            (_a = asset === null || asset === void 0 ? void 0 : asset.dispose) === null || _a === void 0 ? void 0 : _a.call(asset);
        }
        this.assets = {};
    };
    return AssetManager;
}());
function fixOldImageUsage(usedImages, compositions, imgUsage, images, renderLevel) {
    for (var i = 0; i < compositions.length; i++) {
        var id = compositions[i].id;
        var ids = imgUsage[id];
        if (ids) {
            for (var j = 0; j < ids.length; j++) {
                var id_1 = ids[j];
                var tag = images[id_1].renderLevel;
                if (passRenderLevel(tag, renderLevel)) {
                    usedImages[id_1] = true;
                }
            }
        }
    }
}
function createTextureOptionsBySource(image, sourceFrom) {
    if (image instanceof HTMLImageElement ||
        image instanceof HTMLCanvasElement) {
        return {
            image: image,
            sourceType: exports.TextureSourceType.image,
            sourceFrom: sourceFrom,
            keepImageSource: true,
            minFilter: glContext.LINEAR,
            magFilter: glContext.LINEAR,
        };
    }
    else if (image instanceof HTMLVideoElement) {
        // 视频
        return {
            sourceType: exports.TextureSourceType.video,
            video: image,
            minFilter: glContext.LINEAR,
            magFilter: glContext.LINEAR,
        };
    }
    else if (image instanceof ArrayBuffer) {
        // 压缩纹理
        return __assign$1(__assign$1({}, getKTXTextureOptions(image)), { sourceFrom: sourceFrom });
    }
    else if ('width' in image &&
        'height' in image &&
        'data' in image) {
        return {
            sourceType: exports.TextureSourceType.data,
            data: image,
            wrapS: glContext.CLAMP_TO_EDGE,
            wrapT: glContext.CLAMP_TO_EDGE,
            minFilter: glContext.NEAREST,
            magFilter: glContext.NEAREST,
        };
    }
    throw new Error('Invalid texture options');
}

var CompVFXItem = /** @class */ (function (_super) {
    __extends(CompVFXItem, _super);
    function CompVFXItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CompVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.composition;
        },
        enumerable: false,
        configurable: true
    });
    // getItemById (id: string): VFXItem<any> | undefined {}
    CompVFXItem.prototype.onConstructed = function (props) {
        var _a = props.items, items = _a === void 0 ? [] : _a, _b = props.startTime, startTime = _b === void 0 ? 0 : _b;
        this.itemCacheMap = {};
        this.itemProps = items;
        var endBehavior = this.endBehavior;
        if (endBehavior === END_BEHAVIOR_RESTART$1 ||
            endBehavior === END_BEHAVIOR_PAUSE$1 ||
            endBehavior === END_BEHAVIOR_PAUSE_AND_DESTROY$1) {
            this.freezeOnEnd = true;
        }
        this.startTime = startTime;
        this.startTimeInms = Math.round((this.startTime) * 1000);
        this.itemsToRemove = [];
    };
    CompVFXItem.prototype.getUpdateTime = function (t) {
        var startTime = this.startTimeInms;
        var now = this.timeInms;
        if (t < 0 && (now + t) < startTime) {
            return startTime - now;
        }
        if (this.freezeOnEnd) {
            var remain = this.durInms - now;
            if (remain < t) {
                return remain;
            }
        }
        return Math.round(t);
    };
    CompVFXItem.prototype.onUpdate = function (dt) {
        _super.prototype.onUpdate.call(this, dt);
    };
    CompVFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        var _a;
        var items = this.items;
        if (items) {
            (_a = this.composition) === null || _a === void 0 ? void 0 : _a.updatePluginLoaders(dt);
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if (item) {
                    item.onUpdate(dt);
                    if (!item.composition) {
                        addItem(this.itemsToRemove, item);
                    }
                }
            }
            if (this.itemsToRemove.length) {
                this.itemsToRemove.forEach(function (item) {
                    removeItem(items, item);
                });
                this.itemsToRemove.length = 0;
            }
        }
    };
    CompVFXItem.prototype.doStop = function () {
        if (this.items) {
            this.items.forEach(function (item) { return item.stop(); });
        }
    };
    CompVFXItem.prototype.onItemRemoved = function (renderer) {
        if (this.items) {
            this.items.forEach(function (item) { return item.dispose(); });
            // @ts-expect-error
            this.items = null;
        }
    };
    CompVFXItem.prototype.createContent = function () {
        if (!this.items && this.composition) {
            this.items = this.createItemsWidthOrder(this.composition);
        }
    };
    CompVFXItem.prototype.onLifetimeBegin = function (renderer, content) {
        var _a;
        (_a = this.items) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {
            item.start();
            item.createContent();
        });
    };
    CompVFXItem.prototype.createItemsWidthOrder = function (composition) {
        var ret = [];
        var items = this.itemProps;
        for (var i = 0; i < items.length; i++) {
            var item = createVFXItem(items[i], composition);
            addItemWithOrder(ret, item, '_v_priority');
        }
        return ret;
    };
    CompVFXItem.prototype.removeItem = function (item) {
        var itemIndex = this.items.indexOf(item);
        if (itemIndex > -1) {
            delete this.itemCacheMap[item.id];
            addItem(this.itemsToRemove, item);
            return true;
        }
        return false;
    };
    CompVFXItem.prototype.isEnded = function (now) {
        return now >= this.durInms;
    };
    return CompVFXItem;
}(VFXItem));

var seed$4 = 1;
/**
 * 合成抽象类：Mars 的核心对象，通常一个场景只包含一个合成，可能会有多个合成。
 * 合成中包含了相关的 Item 元素，支持对 Item 元素的创建、更新和销毁。
 * 也负责 Item 相关的动画播放控制，和持有渲染帧数据。
 */
var Composition = /** @class */ (function () {
    /**
     * Composition 构造函数
     * @param props - composition 的创建参数
     */
    function Composition(props) {
        var _a;
        /**
         * 用于保存与当前合成相关的插件数据
         */
        this.loaderData = {};
        // TODO: 待优化
        this.assigned = false;
        /**
         * 销毁状态位
         */
        this.destroyed = false;
        this.lastVideoUpdateTime = 0;
        this.postLoaders = [];
        var content = props.content, camera = props.camera, renderLevel = props.renderLevel, pluginSystem = props.pluginSystem, keepResource = props.keepResource, totalTime = props.totalTime, startTime = props.startTime, keepColorBuffer = props.keepColorBuffer, reusable = props.reusable, rootTransform = props.rootTransform, imageUsage = props.imageUsage, textures = props.textures, event = props.event, width = props.width, height = props.height, shaderLibrary = props.shaderLibrary, scene = props.scene, _b = props.baseRenderOrder, baseRenderOrder = _b === void 0 ? 0 : _b, _c = props.speed, speed = _c === void 0 ? 1 : _c, handleEnd = props.handleEnd, handleMessageItem = props.handleMessageItem, handlePlayerPause = props.handlePlayerPause;
        var vfxItem = new CompVFXItem(content, this);
        this.width = width;
        this.height = height;
        this.shaderLibrary = shaderLibrary;
        this.renderOrder = baseRenderOrder;
        this.id = seed$4++;
        this.speed = speed;
        this.pluginSystem = pluginSystem;
        this.texInfo = imageUsage !== null && imageUsage !== void 0 ? imageUsage : {};
        this.textures = textures;
        this.event = event;
        this.statistic = { loadTime: totalTime, loadStart: startTime, firstFrameTime: 0 };
        this.reusable = reusable;
        this.keepResource = keepResource;
        this.keepColorBuffer = keepColorBuffer;
        this.renderLevel = renderLevel;
        this.handlePlayerPause = handlePlayerPause;
        this.handleMessageItem = handleMessageItem;
        this.handleEnd = handleEnd;
        this.rootTransform = rootTransform !== null && rootTransform !== void 0 ? rootTransform : new Transform();
        vfxItem.transform = this.rootTransform;
        this.autoRefTex = !keepResource && imageUsage && vfxItem.endBehavior !== END_BEHAVIOR_RESTART$1;
        this.content = vfxItem;
        this.name = vfxItem.name;
        this.rootTransform.name = this.name;
        this.camera = new Camera(this.name, __assign$1(__assign$1({}, camera), { aspect: (_a = camera.aspect) !== null && _a !== void 0 ? _a : width / height }));
        this.url = scene.url;
        this.renderer = props.renderer;
        this.assigned = true;
        this.pluginSystem.initializeComposition(this, scene);
        this.createRenderFrame();
        this.reset();
    }
    /**
     * Composition 静态实例初始化函数
     * @param scene - Mars 的场景对象
     * @param options - Composition 的创建参数
     */
    Composition.initialize = function (scene, options) {
        if (options === void 0) { options = {}; }
        var compositionName = options.compositionName, transform = options.transform, speed = options.speed, keepResource = options.keepResource, reusable = options.reusable, baseRenderOrder = options.baseRenderOrder, multipleCompositions = options.multipleCompositions, renderer = options.renderer, gpuCapability = options.gpuCapability, handlePlayerPause = options.handlePlayerPause, handleMessageItem = options.handleMessageItem, handleEnd = options.handleEnd, event = options.event, width = options.width, height = options.height, shaderLibrary = options.shaderLibrary;
        var jsonScene = scene.jsonScene, renderLevel = scene.renderLevel, textureOptions = scene.textureOptions, pluginSystem = scene.pluginSystem, totalTime = scene.totalTime;
        var compositions = jsonScene.compositions, imgUsage = jsonScene.imgUsage;
        var compositionId = jsonScene.compositionId;
        if (compositionName) {
            var comp_1 = getCompositionByName(compositions, compositionName);
            if (!comp_1) {
                throw new Error("composition for name ".concat(compositionName, " not found"));
            }
            compositionId = comp_1.id;
        }
        if (!textureOptions) {
            throw new Error('scene.textures expected');
        }
        var cachedTextures = textureOptions.map(function (option) { return option && (option instanceof Texture ? option : Texture.create(option)); });
        // 缓存创建的Texture对象
        // @ts-expect-error
        scene.textureOptions = cachedTextures;
        var vfxItemManager = new VFXItemManager(compositions, compositionId, {
            mask: 0,
            jsonScene: jsonScene,
            renderLevel: renderLevel,
            textureOptions: textureOptions,
            textures: cachedTextures,
        });
        var content = vfxItemManager.getContent();
        var rootTransform = new Transform(transform);
        // TODO 通过贴图池统一管理texture创建
        cachedTextures === null || cachedTextures === void 0 ? void 0 : cachedTextures.forEach(function (tex) { return tex === null || tex === void 0 ? void 0 : tex.initialize(renderer.engine); });
        scene.images.forEach(function (image, i) {
            if (image instanceof HTMLCanvasElement) {
                getDefaultTemplateCanvasPool().saveCanvas(image);
                // @ts-expect-error
                scene.images[i] = null;
            }
        });
        var willReverse = !!reusable;
        var comp = new Composition({
            baseRenderOrder: baseRenderOrder,
            speed: speed,
            content: content,
            imageUsage: !willReverse && imgUsage,
            keepResource: keepResource,
            textures: cachedTextures,
            renderer: renderer,
            width: width,
            height: height,
            gpuCapability: gpuCapability,
            shaderLibrary: shaderLibrary,
            handlePlayerPause: handlePlayerPause,
            handleMessageItem: handleMessageItem,
            handleEnd: handleEnd,
            pluginSystem: pluginSystem,
            scene: scene,
            event: event,
            totalTime: totalTime,
            renderLevel: renderLevel,
            camera: content.camera,
            reusable: willReverse,
            rootTransform: rootTransform,
            keepColorBuffer: multipleCompositions,
        });
        scene.jsonScene.imgUsage = undefined;
        if (!keepResource) {
            scene.textures = undefined;
            scene.consumed = true;
        }
        return comp;
    };
    Object.defineProperty(Composition.prototype, "items", {
        /**
         * 获取合成中所有元素
         */
        get: function () {
            return this.content.items;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Composition.prototype, "startTime", {
        /**
         * 获取合成开始时间
         */
        get: function () {
            var _a;
            return (_a = this.content.startTime) !== null && _a !== void 0 ? _a : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Composition.prototype, "time", {
        /**
         * 获取合成当前时间
         */
        get: function () {
            return this.content.timeInms / 1000;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Composition.prototype, "isDestroyed", {
        /**
         * 获取销毁状态
         */
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 重新开始合成
     */
    Composition.prototype.restart = function () {
        this.content.reset();
        this.prepareRender();
        this.reset();
        this.content.start();
        this.forwardTime(this.startTime);
        this.content.onUpdate(0);
        this.calculateGroup.update(0);
    };
    // TODO: 待废弃
    Composition.prototype.start = function () {
        this.content.start();
    };
    /**
     *
     */
    Composition.prototype.createRenderFrame = function () {
        this.renderFrame = new RenderFrame({
            camera: this.camera,
            renderer: this.renderer,
            keepColorBuffer: this.keepColorBuffer,
        });
        // TODO 考虑放到构造函数
        this.renderFrame.cachedTextures = this.textures;
    };
    /**
     * 快进/快退指定时间间隔
     * @param timeInSeconds - 需要快进/快退的时间长度（秒），可正可负
     */
    Composition.prototype.forwardTime = function (timeInSeconds) {
        var time = Math.round(timeInSeconds * 1000);
        if (time) {
            var reverse = time < 0;
            var step = 15;
            var t = Math.abs(time);
            for (var ss = reverse ? -step : step; t > step; t -= step) {
                this.update(ss);
            }
            if (t > 0) {
                var ss = reverse ? -t : t;
                this.update(ss);
            }
        }
    };
    /**
     * 重置状态函数
     */
    Composition.prototype.reset = function () {
        var _this = this;
        this.rendererOptions = null;
        this.pluginSystem.plugins.forEach(function (p) { return p.onCompositionWillReset(_this, _this.renderFrame); });
        this.calculateGroup = new CalculateGroup();
        this.content.createContent();
        this.content.onEnd = function () {
            window.setTimeout(function () {
                var _a;
                (_a = _this.handleEnd) === null || _a === void 0 ? void 0 : _a.call(_this, _this);
            }, 0);
        };
        this.pluginSystem.resetComposition(this, this.renderFrame);
    };
    Composition.prototype.prepareRender = function () {
        var _this = this;
        var frame = this.renderFrame;
        this.postLoaders.length = 0;
        this.pluginSystem.plugins.forEach(function (loader) {
            if (loader.prepareRenderFrame(_this, frame)) {
                _this.postLoaders.push(loader);
            }
        });
        this.postLoaders.forEach(function (loader) { return loader.postProcessFrame(_this, frame); });
    };
    /**
     * 是否合成需要重新播放
     * @returns 重新播放合成标志位
     */
    Composition.prototype.shouldRestart = function () {
        var _a = this.content, ended = _a.ended, endBehavior = _a.endBehavior;
        return ended && endBehavior === END_BEHAVIOR_RESTART$1;
    };
    /**
     * 是否合成需要销毁
     * @returns 销毁合成标志位
     */
    Composition.prototype.shouldDispose = function () {
        var _a = this.content, ended = _a.ended, endBehavior = _a.endBehavior;
        return ended && (!endBehavior || endBehavior === END_BEHAVIOR_PAUSE_AND_DESTROY$1);
    };
    /**
     * 合成更新，针对所有 item 的更新
     * @param deltaTime - 更新的时间步长
     */
    Composition.prototype.update = function (deltaTime) {
        if (!this.assigned) {
            return;
        }
        if (this.shouldRestart()) {
            this.restart();
            // restart then tick to avoid flicker
        }
        var time = this.content.getUpdateTime(deltaTime * this.speed);
        this.updateVideo();
        this.calculateGroup.update(time);
        this.content.onUpdate(time);
        this.updateCamera();
        if (this.shouldDispose()) {
            this.dispose();
        }
        else {
            this.prepareRender();
        }
    };
    /**
     * 更新视频数据到纹理
     * @override
     */
    Composition.prototype.updateVideo = function () {
        var _a;
        var now = performance.now();
        // 视频固定30帧更新
        if (now - this.lastVideoUpdateTime > 33) {
            ((_a = this.textures) !== null && _a !== void 0 ? _a : []).forEach(function (tex) { return tex === null || tex === void 0 ? void 0 : tex.uploadCurrentVideoFrame(); });
            this.lastVideoUpdateTime = now;
        }
    };
    /**
     * 更新相机
     * @override
     */
    Composition.prototype.updateCamera = function () {
        this.camera.updateMatrix();
    };
    /**
     * 插件更新，来自 CompVFXItem 的更新调用
     * @param deltaTime - 更新的时间步长
     */
    Composition.prototype.updatePluginLoaders = function (deltaTime) {
        var _this = this;
        this.pluginSystem.plugins.forEach(function (loader) { return loader.onCompositionUpdate(_this, deltaTime); });
    };
    /**
     * 通过名称获取元素
     * @param name - 元素名称
     * @param type - 元素类型
     * @returns 元素对象
     */
    Composition.prototype.getItemByName = function (name, type) {
        var items = this.content && this.content.items;
        if (items) {
            return items.find(function (item) { return item.name === name && (!type || type === item.type); });
        }
    };
    /**
     * Item 的起始和结束事件
     * @param item - 合成元素
     * @param start - 是起始事件
     */
    Composition.prototype.itemLifetimeEvent = function (item, start) {
        var _this = this;
        var func = start ?
            function (p) { return p.onCompositionItemLifeBegin(_this, item); } :
            function (p) { return p.onCompositionItemLifeEnd(_this, item); };
        this.pluginSystem.plugins.forEach(func);
    };
    /**
     *
     * @param x
     * @param y
     * @returns
     */
    Composition.prototype.getHitTestRay = function (x, y) {
        var _a = __read$1(this.renderFrame.editorTransform, 4), a = _a[0], b = _a[1], c = _a[2], d = _a[3];
        return setRayFromCamera((x - c) / a, (y - d) / b, this.camera);
    };
    /**
     * Item 求交测试，返回求交结果列表，x 和 y 是归一化到[-1, 1]区间的值，原点在左上角
     * @param x - 鼠标或触点的 x，已经归一化到[-1, 1]
     * @param y - 鼠标或触点的 y，已经归一化到[-1, 1]
     * @param force - 是否强制求交，没有交互信息的 Item 也要进行求交测试
     * @param options - 最大求交数和求交时的回调
     */
    Composition.prototype.hitTest = function (x, y, force, options) {
        var hitPositions = [];
        var regions = [];
        var _a = __read$1(this.renderFrame.editorTransform, 4), a = _a[0], b = _a[1], c = _a[2], d = _a[3];
        var ray = setRayFromCamera((x - c) / a, (y - d) / b, this.camera);
        var stop = (options === null || options === void 0 ? void 0 : options.stop) || noop;
        var skip = (options === null || options === void 0 ? void 0 : options.skip) || noop;
        var maxCount = (options === null || options === void 0 ? void 0 : options.maxCount) || this.items.length;
        if (this.isDestroyed) {
            return regions;
        }
        for (var i = 0; i < this.items.length && regions.length < maxCount; i++) {
            var item = this.items[i];
            if (item.lifetime >= 0 && item.lifetime <= 1 && !skip(item)) {
                var hitParams = item.getHitTestParams(force);
                if (hitParams) {
                    var success = false;
                    var intersectPoint = [];
                    if (hitParams.type === exports.HitTestType.triangle) {
                        var triangles = hitParams.triangles, backfaceCulling = hitParams.backfaceCulling;
                        for (var j = 0; j < triangles.length; j++) {
                            var triangle = triangles[j];
                            intersectRayTriangle(intersectPoint, ray.center, ray.direction, triangle, backfaceCulling);
                            if (intersectPoint.length) {
                                success = true;
                                hitPositions.push(intersectPoint);
                                break;
                            }
                        }
                    }
                    else if (hitParams.type === exports.HitTestType.box) {
                        var center = hitParams.center, size = hitParams.size;
                        intersectRayBox(intersectPoint, ray.center, ray.direction, center, size);
                        if (intersectPoint.length) {
                            success = true;
                            hitPositions.push(intersectPoint);
                        }
                    }
                    else if (hitParams.type === exports.HitTestType.sphere) {
                        var center = hitParams.center, radius = hitParams.radius;
                        intersectRaySphere(intersectPoint, ray.center, ray.direction, center, radius);
                        if (intersectPoint.length) {
                            success = true;
                            hitPositions.push(intersectPoint);
                        }
                    }
                    else if (hitParams.type === exports.HitTestType.custom) {
                        var tempPosition = hitParams.collect(ray, [x, y]);
                        if (tempPosition && tempPosition.length > 0) {
                            hitPositions.push.apply(hitPositions, __spreadArray([], __read$1(tempPosition), false));
                            success = true;
                        }
                    }
                    if (success) {
                        var region = {
                            id: item.id,
                            name: item.name,
                            position: hitPositions[hitPositions.length - 1],
                            parentId: item.parentId,
                            hitPositions: hitPositions,
                            behavior: hitParams.behavior,
                        };
                        regions.push(region);
                        if (stop(region)) {
                            return regions;
                        }
                    }
                }
            }
        }
        return regions;
    };
    /**
     * InteractItem 生命周期开始时的调用
     * @param item - 交互元素
     * @param type - 交互类型
     */
    Composition.prototype.addInteractiveItem = function (item, type) {
        var _a;
        if (type === InteractType$1.MESSAGE) {
            (_a = this.handleMessageItem) === null || _a === void 0 ? void 0 : _a.call(this, {
                name: item.name,
                phrase: MESSAGE_ITEM_PHRASE_BEGIN,
                id: item.id,
                compositionId: this.id,
            });
            return item.id;
        }
    };
    /**
     * InteractItem 生命周期结束时的调用
     * @param item - 交互元素
     * @param type - 交互类型
     */
    Composition.prototype.removeInteractiveItem = function (item, type) {
        var _a;
        // MESSAGE ITEM的结束行为
        if (type === InteractType$1.MESSAGE) {
            (_a = this.handleMessageItem) === null || _a === void 0 ? void 0 : _a.call(this, {
                name: item.name,
                phrase: MESSAGE_ITEM_PHRASE_END,
                id: item.id,
                compositionId: this.id,
            });
        }
    };
    /**
     * 销毁插件 Item 中保存的纹理数组
     * @param textures - 需要销毁的数组
     */
    Composition.prototype.destroyTextures = function (textures) {
        var _a;
        for (var i = 0; i < textures.length; i++) {
            var texture = textures[i];
            if (!texture) {
                continue;
            }
            if (texture.sourceType === exports.TextureSourceType.data && !(this.texInfo[texture.id])) {
                if (texture !== ((_a = this.rendererOptions) === null || _a === void 0 ? void 0 : _a.emptyTexture) &&
                    texture !== this.renderFrame.transparentTexture) {
                    texture.dispose();
                }
                continue;
            }
            if (this.autoRefTex) {
                // texInfo的类型有点不明确，改成<string, number>不会提前删除texture
                var c = --this.texInfo[texture.id];
                if (!c) {
                    texture.dispose();
                }
            }
        }
    };
    /**
     * 销毁 Item
     * @param item - 需要销毁的 item
     */
    Composition.prototype.destroyItem = function (item) {
        var _this = this;
        if (this.content.removeItem(item)) {
            this.pluginSystem.plugins.forEach(function (loader) { return loader.onCompositionItemRemoved(_this, item); });
        }
    };
    Composition.prototype.lost = function (e) {
        this.videoState = this.textures.map(function (tex) {
            if ('video' in tex.source) {
                tex.source.video.pause();
                return tex.source.video.currentTime;
            }
        });
        this.textures.map(function (tex) { return tex.dispose(); });
        this.dispose();
    };
    /**
     * 合成对象销毁
     */
    Composition.prototype.dispose = function () {
        var _this = this;
        var _a, _b;
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        var textureDisposes = {};
        var textures = this.textures;
        if (textures) {
            if (this.keepResource) {
                textures.forEach(function (tex) {
                    if (tex === null || tex === void 0 ? void 0 : tex.dispose) {
                        textureDisposes[tex.id] = tex.dispose;
                        tex.dispose = noop;
                    }
                });
            }
            else {
                textures.forEach(function (tex) { return tex && tex.dispose(); });
            }
        }
        this.content.dispose();
        this.textures = [];
        // FIXME: 注意这里增加了renderFrame销毁
        this.renderFrame.dispose();
        (_a = this.rendererOptions) === null || _a === void 0 ? void 0 : _a.emptyTexture.dispose();
        (_b = this.pluginSystem) === null || _b === void 0 ? void 0 : _b.destroyComposition(this);
        this.update = function () { console.error("Update disposed composition: ".concat(_this.name, ".")); };
        this.handlePlayerPause = noop;
        this.dispose = noop;
        if (textures && this.keepResource) {
            textures.forEach(function (tex) { return tex.dispose = textureDisposes[tex.id]; });
        }
    };
    /**
     * 编辑器使用的 transform 修改方法
     * @param scale - 缩放比例
     * @param dx - x偏移量
     * @param dy - y偏移量
     */
    Composition.prototype.setEditorTransform = function (scale, dx, dy) {
        this.renderFrame.editorTransform = [scale, scale, dx, dy];
    };
    /**
     * 卸载贴图纹理方法，减少内存
     */
    Composition.prototype.offloadTexture = function () {
        if (!this.textureOffloaded) {
            this.textures.forEach(function (tex) { return tex && tex.offloadData(); });
            this.textureOffloaded = true;
        }
    };
    Composition.prototype.getRendererOptions = function () {
        if (!this.rendererOptions) {
            this.rendererOptions = {
                emptyTexture: this.renderFrame.emptyTexture,
                cachePrefix: '-',
            };
        }
        return this.rendererOptions;
    };
    /**
     * 重新加载纹理
     */
    Composition.prototype.reloadTexture = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.textureOffloaded) return [3 /*break*/, 2];
                        return [4 /*yield*/, Promise.all(this.textures.map(function (tex) { return tex === null || tex === void 0 ? void 0 : tex.reloadData(); }))];
                    case 1:
                        _a.sent();
                        this.textureOffloaded = false;
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    return Composition;
}());
/**
 * 根据 id 查找对应的合成，可能找不到
 * @param compositions - 合成列表
 * @param id - 目标合成 id
 */
function getComposition(compositions, id) {
    return compositions.find(function (f) { return f.id === id; });
}
/**
 * 根据名称查找对应的合成，可能找不到
 * @param compositions - 合成列表
 * @param name - 目标合成名称
 */
function getCompositionByName(compositions, name) {
    return compositions.find(function (comp) { return comp.name === name; });
}

/**
 * Engine 基类，负责维护所有 GPU 资源的销毁
 */
var Engine = /** @class */ (function () {
    function Engine() {
        this.destroyed = false;
        this.textures = [];
        this.materials = [];
        this.geometries = [];
        this.meshes = [];
        this.renderPasses = [];
    }
    Engine.prototype.addTexture = function (tex) {
        if (this.destroyed) {
            return;
        }
        addItem(this.textures, tex);
    };
    Engine.prototype.removeTexture = function (tex) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.textures, tex);
    };
    Engine.prototype.addMaterial = function (mat) {
        if (this.destroyed) {
            return;
        }
        addItem(this.materials, mat);
    };
    Engine.prototype.removeMaterial = function (mat) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.materials, mat);
    };
    Engine.prototype.addGeometry = function (geo) {
        if (this.destroyed) {
            return;
        }
        addItem(this.geometries, geo);
    };
    Engine.prototype.removeGeometry = function (geo) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.geometries, geo);
    };
    Engine.prototype.addMesh = function (mesh) {
        if (this.destroyed) {
            return;
        }
        addItem(this.meshes, mesh);
    };
    Engine.prototype.removeMesh = function (mesh) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.meshes, mesh);
    };
    Engine.prototype.addRenderPass = function (pass) {
        if (this.destroyed) {
            return;
        }
        addItem(this.renderPasses, pass);
    };
    Engine.prototype.removeRenderPass = function (pass) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.renderPasses, pass);
    };
    Object.defineProperty(Engine.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    Engine.prototype.getShaderLibrary = function () {
        return this.renderer.getShaderLibrary();
    };
    /**
     * 销毁所有缓存的资源
     */
    Engine.prototype.dispose = function () {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        var info = [];
        if (this.renderPasses.length > 0) {
            info.push("Pass ".concat(this.renderPasses.length));
        }
        if (this.meshes.length > 0) {
            info.push("Mesh ".concat(this.meshes.length));
        }
        if (this.geometries.length > 0) {
            info.push("Geom ".concat(this.geometries.length));
        }
        if (this.textures.length > 0) {
            info.push("Tex ".concat(this.textures.length));
        }
        if (info.length > 0) {
            console.warn("Release GPU memory: ".concat(info.join(', ')));
        }
        this.renderPasses.forEach(function (pass) {
            pass.dispose();
        });
        this.meshes.forEach(function (mesh) {
            mesh.dispose();
        });
        this.geometries.forEach(function (geo) {
            geo.dispose();
        });
        this.materials.forEach(function (mat) {
            mat.dispose();
        });
        this.textures.forEach(function (tex) {
            tex.dispose();
        });
        this.textures = [];
        this.materials = [];
        this.geometries = [];
        this.meshes = [];
        this.renderPasses = [];
        // @ts-expect-error
        this.renderer = null;
    };
    return Engine;
}());

registerPlugin('camera', CameraVFXItemLoader, CameraVFXItem, true);
registerPlugin('sprite', SpriteLoader, SpriteVFXItem, true);
registerPlugin('particle', ParticleLoader, ParticleVFXItem, true);
registerPlugin('cal', CalculateLoader, CalculateVFXItem, true);
registerPlugin('interact', InteractLoader, InteractVFXItem, true);
registerPlugin('filter', SpriteLoader, FilterSpriteVFXItem, true);
registerPlugin(VFX_ITEM_TYPE_TREE, CalculateLoader, TreeVFXItem, true);
registerFilters(filters);

var GLMesh = /** @class */ (function (_super) {
    __extends(GLMesh, _super);
    function GLMesh(props) {
        var _this = this;
        var material = props.material, geometry = props.geometry, _a = props.name, name = _a === void 0 ? '<unnamed>' : _a, _b = props.priority, priority = _b === void 0 ? 0 : _b, _c = props.worldMatrix, worldMatrix = _c === void 0 ? [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] : _c;
        _this = _super.call(this, name) || this;
        _this.visible = false;
        _this.geometries = [geometry];
        _this.material = material;
        _this.priority = priority;
        _this.worldMatrix = worldMatrix;
        return _this;
    }
    GLMesh.prototype.initialize = function (engine) {
        this.geometries.forEach(function (geometry) {
            geometry.initialize(engine);
        });
        this.material.initialize(engine);
        this.engine = engine;
        this.engine.addMesh(this);
        this.renderer = this.engine.getGLRendererInternal();
    };
    GLMesh.prototype.getVisible = function () {
        return this.visible;
    };
    GLMesh.prototype.setVisible = function (visible) {
        this.visible = visible;
    };
    GLMesh.prototype.render = function (renderer) {
        var e_1, _a;
        var renderingData = renderer.renderingData;
        var material = this.material;
        if (!material) {
            console.warn('Mesh ' + this.name + ' 没有绑定材质。');
            return;
        }
        material.initialize(renderer.engine);
        var program = material.shader.program;
        if (!program) {
            console.warn('Material ' + material.name + ' 的shader着色器程序未初始化。');
            return;
        }
        if (renderingData.currentCamera) {
            material.setMatrix('mars_MatrixInvV', renderingData.currentCamera.getInverseViewMatrix());
            material.setMatrix('mars_MatrixV', renderingData.currentCamera.getViewMatrix());
            material.setMatrix('mars_MatrixVP', renderingData.currentCamera.getViewProjectionMatrix());
        }
        material.setMatrix('mars_ObjectToWorld', this.worldMatrix);
        if (renderingData.currentFrame.editorTransform) {
            material.setVector4('uEditorTransform', renderingData.currentFrame.editorTransform);
        }
        material.use(renderer);
        try {
            for (var _b = __values$1(this.geometries), _c = _b.next(); !_c.done; _c = _b.next()) {
                var geometry = _c.value;
                var geo = geometry;
                // 执行 Geometry 的载入后初始化或数据刷新
                if (geo.isInitialized) {
                    geo.flush();
                }
                else {
                    geo.initialize(renderer.engine);
                }
                var vao = program.setupAttributes(geo);
                renderer.glRenderer.drawGeometry(geo);
                vao === null || vao === void 0 ? void 0 : vao.unbind();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    GLMesh.prototype.setMaterial = function (mtl, destroy) {
        if (destroy !== exports.DestroyOptions.keep) {
            this.material.dispose(destroy);
        }
        this.material = mtl;
    };
    GLMesh.prototype.setGeometries = function (geos, destroy) {
        var _this = this;
        var geometries = this.geometries;
        if (destroy !== exports.DestroyOptions.keep) {
            geometries.forEach(function (geometry) { return geometry.dispose(); });
        }
        geometries.length = 0;
        geos.forEach(function (geometry) {
            if (_this.engine) {
                geometry.initialize(_this.engine);
            }
            geometries.push(geometry);
        });
    };
    GLMesh.prototype.firstGeometry = function () {
        return this.geometries[0];
    };
    GLMesh.prototype.restore = function () {
    };
    GLMesh.prototype.dispose = function (options) {
        /**
         * 正常情况不会dispose两次，如果出现dispose两次可能是出错了
         * 但是目前的设计是支持dispose两次，并传入不同的DestroyOptions参数
         *
         * 现在修改成支持多次dispose，只有第一次起作用，后面的直接忽略。
         */
        if (this.destroyed) {
            //console.error('call mesh.destroy multiple times', this);
            return;
        }
        if ((options === null || options === void 0 ? void 0 : options.geometries) !== exports.DestroyOptions.keep) {
            this.geometries.forEach(function (geometry) {
                geometry.dispose();
            });
        }
        this.geometries.length = 0;
        var materialDestroyOption = options === null || options === void 0 ? void 0 : options.material;
        if (materialDestroyOption !== exports.DestroyOptions.keep) {
            this.material.dispose(materialDestroyOption);
        }
        this.initialize = throwDestroyedError$1;
        this.destroyed = true;
        if (this.engine !== undefined) {
            this.engine.removeMesh(this);
            this.engine = undefined;
        }
    };
    return GLMesh;
}(Mesh));

var _a$3, _b$1;
var FORMAT_HALF_FLOAT = (_a$3 = {},
    _a$3[glContext.RGBA] = 34842,
    _a$3[glContext.RGB] = 34843,
    _a$3[glContext.ALPHA] = 33325,
    _a$3[glContext.RED] = 33325,
    _a$3[glContext.LUMINANCE_ALPHA] = 33327,
    _a$3[glContext.LUMINANCE] = 33325,
    _a$3);
var FORMAT_FLOAT = (_b$1 = {},
    _b$1[glContext.RGBA] = 34836,
    _b$1[glContext.RGB] = 34837,
    _b$1[glContext.ALPHA] = 33326,
    _b$1[glContext.RED] = 33326,
    _b$1[glContext.LUMINANCE_ALPHA] = 33328,
    _b$1[glContext.LUMINANCE] = 33326,
    _b$1);
var GLTexture = /** @class */ (function (_super) {
    __extends(GLTexture, _super);
    function GLTexture(source) {
        var _this = _super.call(this) || this;
        _this.initialized = false;
        var opts = _this.assembleOptions(source);
        var sourceType = opts.sourceType, sourceFrom = opts.sourceFrom, _a = opts.name, name = _a === void 0 ? '' : _a;
        _this.source = opts;
        _this.sourceType = sourceType;
        _this.sourceFrom = sourceFrom;
        _this.name = name;
        return _this;
    }
    /** 绑定当前Texture对象。*/
    GLTexture.prototype.bind = function (force) {
        this.pipelineContext.bindTexture(this.target, this.textureBuffer, force);
    };
    /** 初始化Texture的GPU资源。*/
    GLTexture.prototype.initialize = function (engine) {
        if (this.initialized) {
            return;
        }
        this.engine = engine;
        this.engine.addTexture(this);
        var pipelineContext = this.engine.getGLPipelineContext();
        this.pipelineContext = pipelineContext;
        var gl = pipelineContext.gl;
        var _a = this.source, _b = _a.target, target = _b === void 0 ? gl.TEXTURE_2D : _b, name = _a.name;
        this.textureBuffer = gl.createTexture();
        if (this.textureBuffer) {
            assignInspectorName(this.textureBuffer, name);
        }
        this.target = target;
        this.update(this.source);
        this.release();
        this.initialized = true;
    };
    GLTexture.prototype.clone = function () {
        var clonedTexture = new GLTexture(this.source);
        clonedTexture.sourceFrom = this.sourceFrom;
        clonedTexture.sourceType = this.sourceType;
        clonedTexture.width = this.width;
        clonedTexture.height = this.height;
        return clonedTexture;
    };
    GLTexture.prototype.release = function () {
        var sourceType = this.source.sourceType;
        switch (sourceType) {
            case exports.TextureSourceType.image:
                // @ts-expect-error
                delete this.source.image;
                // @ts-expect-error
                delete this.source.cube;
                break;
            case exports.TextureSourceType.data:
                // @ts-expect-error
                delete this.source.data;
                break;
            case exports.TextureSourceType.compressed:
                // @ts-expect-error
                delete this.source.mipmaps;
                break;
            case exports.TextureSourceType.mipmaps:
                // @ts-expect-error
                delete this.source.mipmaps;
                break;
        }
    };
    GLTexture.prototype.update = function (sourceOptions) {
        var _a, _b;
        var _this = this;
        var _c, _d;
        if (!this.pipelineContext || !this.textureBuffer) {
            this.width = 0;
            this.height = 0;
            return;
        }
        var target = this.target;
        var source = this.source;
        var gl = this.pipelineContext.gl;
        var detail = GPUCapability.getInstance().detail;
        var sourceType = source.sourceType;
        var data = source.data;
        var cube = source.cube;
        var image = source.image;
        var video = source.video;
        var mipmaps = source.mipmaps;
        var cubeMipmaps = source.mipmaps;
        var optionsData = sourceOptions.data;
        var optionsCube = sourceOptions.cube;
        var generateMipmap = sourceOptions.generateMipmap;
        var optionsMipmaps = sourceOptions.mipmaps;
        var _e = source, format = _e.format, type = _e.type, internalFormat = _e.internalFormat;
        var width = 0;
        var height = 0;
        // TODO 原GLState的textureUnitDict参数未处理。
        this.bind(sourceType === exports.TextureSourceType.video);
        // 选择 type 和 format
        if (type === glContext.HALF_FLOAT) {
            type = detail.halfFloatTexture;
            if (!type) {
                console.error('half float texture is not support');
            }
            if (isWebGL2(gl) && internalFormat === format) {
                if (format === glContext.LUMINANCE) {
                    format = glContext.RED;
                }
                internalFormat = FORMAT_HALF_FLOAT[format];
            }
            if (!detail.halfFloatLinear) {
                source.minFilter = source.magFilter = gl.NEAREST;
                console.warn('half float linear not support,change to NEAREST');
            }
        }
        else if (type === gl.FLOAT) {
            type = detail.floatTexture;
            if (!type) {
                console.error('float texture is not support');
            }
            if (isWebGL2(gl) && internalFormat === format) {
                if (format === glContext.LUMINANCE) {
                    format = glContext.RED;
                }
                internalFormat = FORMAT_FLOAT[format];
            }
            if (!detail.floatLinear) {
                source.minFilter = gl.NEAREST;
                source.magFilter = gl.NEAREST;
                console.warn('float linear not support,change to NEAREST');
            }
        }
        // 处理是否RGB透明度相乘和Y轴反转, 默认值都为false。
        if (source.premultiplyAlpha === undefined) {
            source.premultiplyAlpha = false;
        }
        // gl的状态可能在外面被改变了，这里必须重新设置
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, source.premultiplyAlpha);
        if (source.flipY === undefined) {
            source.flipY = false;
        }
        // gl的状态可能在外面被改变了，这里必须重新设置
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, source.flipY);
        // 根据不同的 TextureSourceType 传输对应贴图数据到GPU。
        if (sourceType === exports.TextureSourceType.framebuffer) {
            if (optionsData) {
                width = (_c = optionsData.width) !== null && _c !== void 0 ? _c : 0;
                height = (_d = optionsData.height) !== null && _d !== void 0 ? _d : 0;
                if (width && height && (this.width !== width || this.height !== height)) {
                    gl.texImage2D(target, 0, internalFormat, width, height, 0, format, type, null);
                }
            }
        }
        else if (sourceType === exports.TextureSourceType.data) {
            if (target === gl.TEXTURE_CUBE_MAP) {
                optionsCube.forEach(function (data, key) {
                    var _a = __read$1(_this.texImage2DData(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + key, 0, internalFormat, format, type, data), 2), x = _a[0], y = _a[1];
                    width = Math.max(x, width);
                    height = Math.max(y, height);
                });
            }
            else {
                _a = __read$1(this.texImage2DData(gl, target, 0, internalFormat, format, type, data), 2), width = _a[0], height = _a[1];
            }
        }
        else if (sourceType === exports.TextureSourceType.image || sourceType === exports.TextureSourceType.video) {
            if (target === gl.TEXTURE_CUBE_MAP) {
                cube.forEach(function (image, key) {
                    var _a = __read$1(_this.texImage2D(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + key, 0, internalFormat, format, type, image), 2), x = _a[0], y = _a[1];
                    width = Math.max(x, width);
                    height = Math.max(y, height);
                });
            }
            else if (target === gl.TEXTURE_2D) {
                var imageData = image !== null && image !== void 0 ? image : video;
                _b = __read$1(this.texImage2D(gl, target, 0, internalFormat, format, type, imageData), 2), width = _b[0], height = _b[1];
            }
            if (generateMipmap) {
                if ((isPowerOfTwo(width) && isPowerOfTwo(height)) || isWebGL2(gl)) {
                    gl.generateMipmap(target);
                }
            }
        }
        else if (sourceType === exports.TextureSourceType.mipmaps) {
            var ret_1;
            if (target === gl.TEXTURE_2D) {
                mipmaps.forEach(function (mipmap, level) {
                    var _a;
                    if ('data' in mipmap) {
                        ret_1 = _this.texImage2DData(gl, target, level, internalFormat, format, type, mipmap);
                    }
                    else {
                        ret_1 = _this.texImage2D(gl, target, level, internalFormat, format, type, mipmap);
                    }
                    if (level === 0) {
                        _a = __read$1(ret_1, 2), width = _a[0], height = _a[1];
                    }
                });
            }
            else if (target === gl.TEXTURE_CUBE_MAP) {
                cubeMipmaps.forEach(function (mipmap, level) {
                    mipmap.forEach(function (face, key) {
                        var _a;
                        if ('data' in face) {
                            ret_1 = _this.texImage2DData(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + key, level, internalFormat, format, type, face);
                        }
                        else {
                            ret_1 = _this.texImage2D(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + key, level, internalFormat, format, type, face);
                        }
                        if (level === 0) {
                            _a = __read$1(ret_1, 2), width = _a[0], height = _a[1];
                        }
                    });
                });
            }
        }
        else if (sourceType === exports.TextureSourceType.compressed) {
            if (optionsMipmaps) {
                width = optionsMipmaps[0].width;
                height = optionsMipmaps[0].height;
                optionsMipmaps.forEach(function (mipmap, idx) {
                    gl.compressedTexImage2D(target, idx, internalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                });
            }
        }
        this.width = width;
        this.height = height;
        this.setTextureFilters(gl, target, source);
    };
    GLTexture.prototype.setTextureFilters = function (gl, target, options) {
        var _a = options.anisotropic, anisotropic = _a === void 0 ? 4 : _a, _b = options.wrapS, wrapS = _b === void 0 ? gl.CLAMP_TO_EDGE : _b, _c = options.wrapT, wrapT = _c === void 0 ? gl.CLAMP_TO_EDGE : _c;
        var gpuCapability = GPUCapability.getInstance();
        if (this.target === gl.TEXTURE_2D) {
            gpuCapability.setTextureAnisotropic(gl, this.target, anisotropic);
        }
        var isPot = isWebGL2(gl) || (isPowerOfTwo(this.width) && isPowerOfTwo(this.height));
        var minFiler = isPot ? (options.minFilter || gl.NEAREST) : gl.NEAREST;
        var magFilter = isPot ? (options.magFilter || gl.NEAREST) : gl.NEAREST;
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minFiler);
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, isPot ? wrapS : gl.CLAMP_TO_EDGE);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, isPot ? wrapT : gl.CLAMP_TO_EDGE);
    };
    GLTexture.prototype.texImage2D = function (gl, target, level, internalformat, format, type, image) {
        var _a;
        var _b = this.source, sourceType = _b.sourceType, minFilter = _b.minFilter, magFilter = _b.magFilter; _b.flipY; var wrapS = _b.wrapS, wrapT = _b.wrapT;
        var maxSize = (_a = GPUCapability.getInstance().detail.maxTextureSize) !== null && _a !== void 0 ? _a : 2048;
        var img = image;
        if (sourceType !== exports.TextureSourceType.video) {
            var shouldResize = minFilter !== gl.NEAREST || magFilter !== gl.NEAREST || wrapS !== gl.CLAMP_TO_EDGE || wrapT !== gl.CLAMP_TO_EDGE;
            shouldResize = shouldResize || image.width > maxSize || image.height > maxSize;
            if (shouldResize) {
                img = this.resizeImage(image);
            }
        }
        gl.texImage2D(target, level, internalformat, format, type, img);
        var size = [img.width, img.height];
        if (sourceType === exports.TextureSourceType.video) {
            var _c = image, videoWidth = _c.videoWidth, videoHeight = _c.videoHeight;
            return [videoWidth, videoHeight];
        }
        return size;
    };
    GLTexture.prototype.texImage2DData = function (gl, target, level, internalformat, format, type, data) {
        var bufferView = data.data, width = data.width, height = data.height;
        // Uint8ClampedArray is incompatible in android
        var neoBuffer = format === gl.UNSIGNED_BYTE ? new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength / bufferView.BYTES_PER_ELEMENT) : bufferView;
        gl.texImage2D(target, level, internalformat, width, height, 0, format, type, neoBuffer);
        return [width, height];
    };
    GLTexture.prototype.resizeImage = function (image, targetWidth, targetHeight) {
        var _a;
        var detail = GPUCapability.getInstance().detail;
        var maxSize = (_a = detail.maxTextureSize) !== null && _a !== void 0 ? _a : 2048;
        var gl = this.pipelineContext.gl;
        if (isWebGL2(gl) && (image.width < maxSize && image.height < maxSize)) {
            return image;
        }
        var canvas = resizeImageByCanvas(image, maxSize, targetWidth, targetHeight);
        if (canvas) {
            return canvas;
        }
        return image;
    };
    GLTexture.prototype.reloadData = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.offloaded) return [3 /*break*/, 2];
                        return [4 /*yield*/, getDefaultTextureFactory().reload(this)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    GLTexture.prototype.offloadData = function () {
        if (!(this.initialized && getDefaultTextureFactory().canOffloadTexture(this.source.sourceFrom))) {
            return;
        }
        var target = this.target;
        var gl = this.pipelineContext.gl;
        if (gl && this.textureBuffer) {
            var data = new Uint8Array([255]);
            this.bind();
            if (target === gl.TEXTURE_2D) {
                gl.texImage2D(target, 0, gl.LUMINANCE, 1, 1, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, data);
            }
            else if (target === gl.TEXTURE_CUBE_MAP) {
                var faces = [
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
                    gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                    gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                    gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                ];
                for (var i = 0; i < faces.length; i++) {
                    gl.texImage2D(faces[i], 0, gl.LUMINANCE, 1, 1, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, data);
                }
            }
            // rewrite mipmap
            gl.generateMipmap(target);
            this.width = 1;
            this.height = 1;
        }
        this.offloaded = true;
    };
    GLTexture.prototype.uploadCurrentVideoFrame = function () {
        return __awaiter(this, void 0, void 0, function () {
            var video;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.source.sourceType === exports.TextureSourceType.video &&
                            this.source.video &&
                            this.initialized)) return [3 /*break*/, 3];
                        video = this.source.video;
                        if (!video.paused) return [3 /*break*/, 2];
                        return [4 /*yield*/, video.play()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this.update({ video: this.source.video });
                        return [2 /*return*/, true];
                    case 3: return [2 /*return*/, false];
                }
            });
        });
    };
    GLTexture.prototype.updateSource = function (opts) {
        // @ts-expect-error
        this.source = this.assembleOptions(__assign$1(__assign$1({}, this.source), opts));
        this.sourceType = this.source.sourceType;
        this.sourceFrom = this.source.sourceFrom;
        this.update(this.source);
    };
    GLTexture.prototype.restore = function () {
        // TODO
    };
    GLTexture.prototype.dispose = function () {
        /**
         * 原先Player是允许多次调用dispose，并且不会报错
         * dispose之后assignRenderer会报错
         */
        if (this.pipelineContext && this.textureBuffer) {
            this.pipelineContext.gl.deleteTexture(this.textureBuffer);
        }
        if (this.source.sourceType === exports.TextureSourceType.video &&
            this.source.video &&
            this.initialized) {
            this.source.video.pause();
            this.source.video.src = '';
            this.source.video.load();
        }
        this.width = 0;
        this.height = 0;
        this.textureBuffer = null;
        this.destroyed = true;
        this.update = function () { console.error('this this texture has been destroyed'); };
        this.initialize = throwDestroyedError$1;
        if (this.engine !== undefined) {
            this.engine.removeTexture(this);
            this.engine = undefined;
        }
    };
    return GLTexture;
}(Texture));
function resizeImageByCanvas(image, maxSize, targetWidth, targetHeight) {
    var width = image.width, height = image.height;
    var nw = Math.min(maxSize, targetWidth || nearestPowerOfTwo(width));
    var nh = Math.min(maxSize, targetHeight || nearestPowerOfTwo(height));
    if (nh !== height || nw !== width) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        canvas.width = nw;
        canvas.height = nh;
        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, width, height, 0, 0, nw, nh);
        console.warn("image resize from ".concat(width, "x").concat(height, " to ").concat(nw, "x").concat(nh));
        return canvas;
    }
}
function isPowerOfTwo(value) {
    return (value & (value - 1)) === 0 && value !== 0;
}

var GLVertexArrayObject = /** @class */ (function () {
    function GLVertexArrayObject(gl, name) {
        this.gl = gl;
        this.ready = false;
        this.disposed = false;
        this.vaoExt = this.gl.getExtension('OES_vertex_array_object');
        this.vao = this.createVertexArray(name);
    }
    GLVertexArrayObject.prototype.bind = function () {
        this.bindVertexArray(this.vao);
    };
    GLVertexArrayObject.prototype.unbind = function () {
        this.bindVertexArray(null);
    };
    GLVertexArrayObject.prototype.createVertexArray = function (name) {
        var vao = null;
        if (isWebGL2(this.gl)) {
            vao = this.gl.createVertexArray();
        }
        if (!vao && this.vaoExt) {
            vao = this.vaoExt.createVertexArrayOES();
        }
        if (vao) {
            assignInspectorName(vao, name);
        }
        return vao;
    };
    /**
     * 根据 gpu level 选择对应的绑定函数
     * @param vao
     */
    GLVertexArrayObject.prototype.bindVertexArray = function (vao) {
        var _a;
        if (isWebGL2(this.gl)) {
            this.gl.bindVertexArray(vao);
        }
        else {
            (_a = this.vaoExt) === null || _a === void 0 ? void 0 : _a.bindVertexArrayOES(vao);
        }
    };
    GLVertexArrayObject.prototype.dispose = function () {
        var _a;
        if (isWebGL2(this.gl)) {
            this.gl.deleteVertexArray(this.vao);
        }
        else {
            (_a = this.vaoExt) === null || _a === void 0 ? void 0 : _a.deleteVertexArrayOES(this.vao);
        }
    };
    return GLVertexArrayObject;
}());

var seed$3 = 1;
var GLRendererInternal = /** @class */ (function () {
    function GLRendererInternal(engine) {
        this.textures = [];
        this.renderBuffers = [];
        this.frameBuffers = [];
        this.destroyed = false;
        var d = { width: 1, height: 1, data: new Uint8Array([255]) };
        var pipelineContext = engine.getGLPipelineContext();
        var gl = pipelineContext.gl;
        this.gl = gl;
        this.pipelineContext = pipelineContext;
        this.emptyTexture2D = new GLTexture({
            data: d,
            sourceType: exports.TextureSourceType.data,
            format: gl.LUMINANCE,
            internalFormat: gl.LUMINANCE,
            type: gl.UNSIGNED_BYTE,
        });
        this.emptyTexture2D.initialize(engine);
        this.emptyTextureCube = new GLTexture({
            target: gl.TEXTURE_CUBE_MAP,
            cube: [d, d, d, d, d, d],
            sourceType: exports.TextureSourceType.data,
            format: gl.LUMINANCE,
            internalFormat: gl.LUMINANCE,
            type: gl.UNSIGNED_BYTE,
        });
        this.emptyTextureCube.initialize(engine);
        this.name = 'GLGPURenderer' + seed$3;
        seed$3++;
    }
    Object.defineProperty(GLRendererInternal.prototype, "height", {
        get: function () {
            return this.gl.drawingBufferHeight;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLRendererInternal.prototype, "width", {
        get: function () {
            return this.gl.drawingBufferWidth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLRendererInternal.prototype, "canvas", {
        get: function () {
            return this.gl.canvas;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLRendererInternal.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    GLRendererInternal.prototype.copy2 = function (source, target) {
        var gl = this.gl;
        if (gl) {
            if (!this.sourceFbo) {
                this.sourceFbo = gl.createFramebuffer();
            }
            if (!this.targetFbo) {
                this.targetFbo = gl.createFramebuffer();
            }
            var state = this.pipelineContext;
            var COLOR_ATTACHMENT0 = gl.COLOR_ATTACHMENT0;
            state.bindFramebuffer(gl.FRAMEBUFFER, this.sourceFbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, COLOR_ATTACHMENT0, gl.TEXTURE_2D, source.textureBuffer, 0);
            state.bindFramebuffer(gl.FRAMEBUFFER, this.targetFbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.textureBuffer, 0);
            state.bindFramebuffer(gl.READ_FRAMEBUFFER, this.sourceFbo);
            state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.targetFbo);
            var filter = source.getWidth() === source.getHeight() && target.getWidth() == target.getHeight() ? gl.NEAREST : gl.LINEAR;
            gl.blitFramebuffer(0, 0, source.getWidth(), source.getHeight(), 0, 0, target.getWidth(), target.getHeight(), gl.COLOR_BUFFER_BIT, filter);
            state.bindFramebuffer(gl.FRAMEBUFFER, null);
            state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
            state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        }
    };
    GLRendererInternal.prototype.resetColorAttachments = function (rp, colors) {
        rp.bind();
        rp.resetColorTextures(colors);
    };
    GLRendererInternal.prototype.createGLRenderBuffer = function (renderbuffer) {
        var rb = this.gl.createRenderbuffer();
        if (rb) {
            addItem(this.renderBuffers, renderbuffer);
        }
        return rb;
    };
    GLRendererInternal.prototype.resize = function (width, height) {
        var gl = this.gl;
        if (gl && gl.drawingBufferWidth !== width || gl.drawingBufferHeight !== height) {
            gl.canvas.width = width;
            gl.canvas.height = height;
            gl.viewport(0, 0, width, height);
            this.frameBuffers.forEach(function (frameBuffer) {
                var viewport = frameBuffer.viewport;
                if (!frameBuffer.isCustomViewport) {
                    frameBuffer.resize(viewport[0], viewport[1], width * frameBuffer.viewportScale, height * frameBuffer.viewportScale);
                }
            });
        }
    };
    GLRendererInternal.prototype.drawGeometry = function (geometry) {
        if (!this.gl) {
            console.warn('GLGPURenderer没有绑定gl对象, 无法绘制geometry');
            return;
        }
        var gl = this.gl;
        var indicesBuffer = geometry.indicesBuffer;
        var offset = geometry.drawStart;
        var mode = geometry.mode;
        var count = geometry.drawCount;
        if (indicesBuffer) {
            var type = indicesBuffer.type, elementCount = indicesBuffer.elementCount;
            count = isNaN(count) ? elementCount : count;
            if (count > 0) {
                gl.drawElements(mode, count, type, offset !== null && offset !== void 0 ? offset : 0);
            }
        }
        else if (count > 0) {
            gl.drawArrays(mode, offset, count);
        }
    };
    GLRendererInternal.prototype.createGLFrameBuffer = function (frameBuffer, name) {
        var fbo = this.gl.createFramebuffer();
        if (fbo) {
            addItem(this.frameBuffers, frameBuffer);
            assignInspectorName(fbo, name, name);
        }
        return fbo;
    };
    /**创建包裹VAO对象。 */
    GLRendererInternal.prototype.createVAO = function (name) {
        var ret = new GLVertexArrayObject(this.gl, name);
        return ret;
    };
    GLRendererInternal.prototype.deleteGLTexture = function (texture) {
        if (texture.textureBuffer && !this.destroyed) {
            this.gl.deleteTexture(texture.textureBuffer);
            removeItem(this.textures, texture);
            // @ts-expect-error
            delete texture.textureBuffer;
        }
    };
    GLRendererInternal.prototype.deleteGPUBuffer = function (buffer) {
        if (buffer && !this.destroyed) {
            this.gl.deleteBuffer(buffer.glBuffer);
            // @ts-expect-error
            delete buffer.glBuffer;
        }
    };
    GLRendererInternal.prototype.deleteGLFrameBuffer = function (frameBuffer) {
        if (frameBuffer && !this.destroyed) {
            this.gl.deleteFramebuffer(frameBuffer.fbo);
            removeItem(this.frameBuffers, frameBuffer);
            delete frameBuffer.fbo;
        }
    };
    GLRendererInternal.prototype.deleteGLRenderBuffer = function (renderbuffer) {
        if (renderbuffer && !this.destroyed) {
            this.gl.deleteRenderbuffer(renderbuffer.buffer);
            removeItem(this.renderBuffers, renderbuffer);
            // @ts-expect-error
            delete renderbuffer.buffer;
        }
    };
    GLRendererInternal.prototype.deleteResource = function () {
        var _this = this;
        var gl = this.gl;
        if (gl) {
            gl.deleteFramebuffer(this.sourceFbo);
            gl.deleteFramebuffer(this.targetFbo);
            this.emptyTexture2D.dispose();
            this.emptyTextureCube.dispose();
            this.frameBuffers.forEach(function (fb) { return _this.deleteGLFrameBuffer(fb); });
            this.frameBuffers.length = 0;
            this.renderBuffers.forEach(function (rb) { return _this.deleteGLRenderBuffer(rb); });
            this.renderBuffers.length = 0;
            this.textures.forEach(function (tex) { return _this.deleteGLTexture(tex); });
            this.textures.length = 0;
        }
    };
    GLRendererInternal.prototype.lost = function (e) {
        console.error('gl lost, destroy glRenderer by default', e.target);
        this.deleteResource();
    };
    GLRendererInternal.prototype.dispose = function (haltGL) {
        this.deleteResource();
        var gl = this.gl;
        if (gl && haltGL) {
            var ex = gl.getExtension('WEBGL_lose_context');
            ex === null || ex === void 0 ? void 0 : ex.loseContext();
        }
        // @ts-expect-error safe to assign
        this.emptyTexture2D = this.emptyTextureCube = this.pipelineContext = this.gpu = this.gl = null;
        this.destroyed = true;
    };
    return GLRendererInternal;
}());
function assignInspectorName(obj, name, id) {
    if (name === undefined) {
        return;
    }
    obj.__SPECTOR_Metadata = { name: name };
    if (obj.__SPECTOR_Object_TAG) {
        obj.__SPECTOR_Object_TAG.displayText = name;
        if (id) {
            obj.__SPECTOR_Object_TAG.id = id;
        }
    }
    else {
        obj.__SPECTOR_Object_TAG = {
            displayText: name,
            id: '',
        };
    }
}

var _a$2;
var GLGPUBuffer = /** @class */ (function () {
    function GLGPUBuffer(pipelineContext, props) {
        this.pipelineContext = pipelineContext;
        this.byteLength = 0;
        this.destroyed = false;
        var _a = props.target, target = _a === void 0 ? glContext.ARRAY_BUFFER : _a, _b = props.type, type = _b === void 0 ? glContext.FLOAT : _b, name = props.name, _c = props.usage, usage = _c === void 0 ? glContext.STATIC_DRAW : _c, data = props.data, elementCount = props.elementCount;
        var bytesPerElement = getBytesPerElementByGLType(type);
        this.target = target;
        this.type = type;
        this.usage = usage;
        this.glBuffer = this.createGLBuffer(name);
        this.bytesPerElement = bytesPerElement;
        if (data) {
            this.bufferData(data);
        }
        else if (elementCount) {
            this.bufferData(bytesPerElement * elementCount);
        }
    }
    Object.defineProperty(GLGPUBuffer.prototype, "elementCount", {
        get: function () {
            return this.byteLength / this.bytesPerElement;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLGPUBuffer.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    GLGPUBuffer.prototype.createGLBuffer = function (name) {
        var buffer = this.pipelineContext.gl.createBuffer();
        if (buffer) {
            assignInspectorName(buffer, name);
        }
        return buffer;
    };
    GLGPUBuffer.prototype.bind = function () {
        this.pipelineContext.gl.bindBuffer(this.target, this.glBuffer);
    };
    GLGPUBuffer.prototype.bufferData = function (data) {
        var byteLength = typeof data === 'number' ? data : data.byteLength;
        if (this.pipelineContext) {
            this.byteLength = byteLength;
            var gl = this.pipelineContext.gl;
            var target = this.target;
            gl.bindBuffer(target, this.glBuffer);
            if (byteLength === 0) {
                // ios 12 13 cause error when byteLength == 0
                gl.bufferData(target, 1, this.usage);
            }
            else {
                gl.bufferData(target, byteLength, this.usage);
                if (typeof data !== 'number') {
                    gl.bufferSubData(target, 0, data);
                }
            }
        }
        else {
            this.byteLength = 0;
        }
    };
    GLGPUBuffer.prototype.bufferSubData = function (elementOffset, data) {
        if (this.pipelineContext) {
            var gl = this.pipelineContext.gl;
            var target = this.target;
            var byteOffset = elementOffset * this.bytesPerElement;
            var byteLength = byteOffset + data.byteLength;
            gl.bindBuffer(target, this.glBuffer);
            if (byteLength > this.byteLength) {
                this.byteLength = byteLength;
                gl.bufferData(target, byteLength, this.usage);
            }
            gl.bufferSubData(target, byteOffset, data);
        }
        else {
            this.byteLength = 0;
        }
    };
    GLGPUBuffer.prototype.dispose = function () {
        this.pipelineContext.gl.deleteBuffer(this.glBuffer);
        // @ts-expect-error safe to assign
        this.glBuffer = null;
        this.destroyed = true;
    };
    // for test
    GLGPUBuffer.prototype.readSubData = function (elementOffset, dstBuffer) {
        if (isWebGL2(this.pipelineContext.gl)) {
            this.pipelineContext.gl.getBufferSubData(this.target, elementOffset * this.bytesPerElement, dstBuffer);
            return true;
        }
        return false;
    };
    return GLGPUBuffer;
}());
var map = (_a$2 = {},
    _a$2[glContext.INT] = Int32Array,
    _a$2[glContext.FLOAT] = Float32Array,
    _a$2[glContext.SHORT] = Int16Array,
    _a$2[glContext.BYTE] = Int8Array,
    _a$2[glContext.UNSIGNED_BYTE] = Uint8Array,
    _a$2[glContext.UNSIGNED_INT] = Uint32Array,
    _a$2[glContext.UNSIGNED_SHORT] = Uint16Array,
    _a$2);
function getBytesPerElementByGLType(type) {
    var _a, _b;
    return (_b = (_a = map[type]) === null || _a === void 0 ? void 0 : _a.BYTES_PER_ELEMENT) !== null && _b !== void 0 ? _b : 0;
}

var _a$1;
var INDEX_TYPE_MAP = (_a$1 = {},
    _a$1[Uint8Array.BYTES_PER_ELEMENT] = glContext.UNSIGNED_BYTE,
    _a$1[Uint16Array.BYTES_PER_ELEMENT] = glContext.UNSIGNED_SHORT,
    _a$1[Uint32Array.BYTES_PER_ELEMENT] = glContext.UNSIGNED_INT,
    _a$1);
var seed$2 = 1;
/**
 * 应用层Geometry对象，本身不直接保存GPU资源而是通过geometryInternal成员保存GPU资源。
 *
 */
var GLGeometry = /** @class */ (function (_super) {
    __extends(GLGeometry, _super);
    function GLGeometry(props) {
        var _this = this;
        var _a = props.drawStart, drawStart = _a === void 0 ? 0 : _a, drawCount = props.drawCount, mode = props.mode, indices = props.indices, _b = props.name, name = _b === void 0 ? "MarsGeometry:".concat(seed$2++) : _b, _c = props.bufferUsage, bufferUsage = _c === void 0 ? glContext.STATIC_DRAW : _c;
        _this = _super.call(this, name) || this;
        // 记录了顶点属性与GPUBuffer对应关系
        _this.buffers = {};
        _this.vaos = {};
        _this.indicesReleasable = false;
        _this.attributesName = [];
        _this.destroyed = false;
        _this.initialized = false;
        // 记录顶点属性，需要与Shader中attribute进行关联
        var bufferProps = {};
        var attributesName = [];
        var attributes = {};
        // key为buffer的名字
        var dirtyFlags = {};
        var attributesReleasable = {};
        var usage = bufferUsage;
        _this.drawStart = drawStart;
        _this.drawCount = isNaN(+drawCount) ? NaN : drawCount;
        _this.mode = (isNaN(mode) ? glContext.TRIANGLES : mode);
        Object.keys(props.attributes).forEach(function (name) {
            var attr = props.attributes[name];
            var size = attr.size, stride = attr.stride, offset = attr.offset, normalize = attr.normalize;
            var _a = attr, _b = _a.type, type = _b === void 0 ? glContext.FLOAT : _b, releasable = _a.releasable;
            var data = attr.data;
            if (type && !('dataSource' in attr) && !data) {
                data = generateEmptyTypedArray(type);
            }
            if (data) {
                var glType = data instanceof Float32Array ? glContext.FLOAT : glContext.INT;
                // 使用 AttributeWithData 构造的 attribute
                bufferProps[name] = {
                    data: data,
                    usage: usage,
                    target: glContext.ARRAY_BUFFER,
                    name: name,
                };
                attributes[name] = {
                    size: size,
                    stride: stride,
                    offset: offset,
                    type: type !== null && type !== void 0 ? type : glType,
                    normalize: !!normalize,
                    dataSource: name,
                };
                attributesReleasable[name] = releasable !== null && releasable !== void 0 ? releasable : false;
                dirtyFlags[name] = {
                    dirty: true,
                    discard: true,
                    start: Number.POSITIVE_INFINITY,
                    end: 0,
                };
            }
            else {
                // 使用AttributeWithType构造的attribute
                var dataSource = attr.dataSource;
                if (dataSource) {
                    // 属性共享buffer
                    attributes[name] = {
                        size: size,
                        stride: stride,
                        offset: offset,
                        type: type,
                        dataSource: dataSource,
                        normalize: !!normalize,
                    };
                }
            }
            attributesName.push(name);
        });
        dirtyFlags.index = {
            dirty: true,
            discard: true,
            start: Number.POSITIVE_INFINITY,
            end: 0,
        };
        // 顶点索引
        _this.indices = indices === null || indices === void 0 ? void 0 : indices.data;
        _this.indicesReleasable = (indices === null || indices === void 0 ? void 0 : indices.releasable) === true;
        _this.bufferProps = bufferProps;
        _this.attributes = attributes;
        _this.attributesName = attributesName;
        _this.attributesReleasable = attributesReleasable;
        _this.dirtyFlags = dirtyFlags;
        return _this;
    }
    Object.defineProperty(GLGeometry.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLGeometry.prototype, "isInitialized", {
        get: function () {
            return this.initialized;
        },
        enumerable: false,
        configurable: true
    });
    /**Geometry的GPU资源初始化方法，在绘制前调用。 */
    GLGeometry.prototype.initialize = function (engine) {
        var _this = this;
        if (this.initialized) {
            return;
        }
        this.engine = engine;
        this.engine.addGeometry(this);
        var pipelineContext = this.engine.getGLPipelineContext();
        //创建vbo
        Object.keys(this.bufferProps).forEach(function (name) {
            _this.buffers[name] = new GLGPUBuffer(pipelineContext, _this.bufferProps[name]);
        });
        //创建ibo
        if (this.indices) {
            this.indicesBuffer = this.createIndicesBuffer(pipelineContext, this.indices);
        }
        this.initialized = true;
        //向GPU传输顶点数据
        this.flush();
    };
    GLGeometry.prototype.getAttributeBuffer = function (name) {
        if (!this.initialized) {
            return undefined;
        }
        var key = this.attributes[name].dataSource;
        return this.buffers[key];
    };
    GLGeometry.prototype.setAttributeData = function (name, data) {
        if (this.bufferProps == undefined) {
            return;
        }
        var bufferOption = this.getAttributeBufferOption(name);
        var key = this.attributes[name].dataSource;
        if (bufferOption) {
            var usage = bufferOption.usage, target = bufferOption.target;
            this.bufferProps[key] = {
                data: data,
                usage: usage,
                target: target,
                elementCount: data.length,
            };
            this.dirtyFlags[key].discard = true;
            this.dirtyFlags[key].dirty = true;
        }
    };
    GLGeometry.prototype.getAttributeData = function (name) {
        if (this.bufferProps == undefined) {
            return;
        }
        var bufferOption = this.getAttributeBufferOption(name);
        return bufferOption ? bufferOption.data : undefined;
    };
    GLGeometry.prototype.setAttributeSubData = function (name, offset, data) {
        if (this.bufferProps == undefined) {
            return;
        }
        var attribute = this.getAttributeBufferOption(name);
        if (attribute && attribute.data != undefined) {
            var start = offset;
            var length_1 = offset + data.length;
            if (attribute.data.length < length_1) {
                // @ts-expect-error safe to use
                var newData = new data.constructor(length_1);
                newData.set(attribute.data);
                attribute.data = newData;
                this.dirtyFlags[name].discard = true;
            }
            else if (!this.dirtyFlags[name].discard) {
                var dirtyFlag = this.dirtyFlags[name];
                dirtyFlag.start = Math.min(dirtyFlag.start, start);
                dirtyFlag.end = Math.max(dirtyFlag.end, length_1 - 1);
            }
            attribute.data.set(data, start);
            this.dirtyFlags[name].dirty = true;
        }
    };
    GLGeometry.prototype.getIndexData = function () {
        return this.indices;
    };
    GLGeometry.prototype.setIndexData = function (data) {
        if (data instanceof Uint8Array ||
            data instanceof Uint16Array ||
            data instanceof Uint32Array) {
            this.indices = data;
            this.dirtyFlags['index'].discard = true;
            this.dirtyFlags['index'].dirty = true;
        }
    };
    GLGeometry.prototype.setIndexSubData = function (offset, data) {
        var _a;
        if (this.indices) {
            var start = offset;
            var length_2 = offset + data.length;
            if (this.indices.length < length_2) {
                // @ts-expect-error safe to use
                var newData = new data.constructor(end);
                newData.set(this.indices);
                this.indices = newData;
                this.dirtyFlags['index'].discard = true;
            }
            else if (!this.dirtyFlags['index'].discard) {
                var dirtyFlag = this.dirtyFlags['index'];
                dirtyFlag.start = Math.min(dirtyFlag.start, start);
                dirtyFlag.end = Math.max(dirtyFlag.end, length_2 - 1);
            }
            (_a = this.indices) === null || _a === void 0 ? void 0 : _a.set(data, start);
            this.dirtyFlags['index'].dirty = true;
        }
    };
    GLGeometry.prototype.getAttributeStride = function (name) {
        var attr = this.attributes[name];
        var stride = attr.stride, size = attr.size, type = attr.type;
        return stride ? stride : size * BYTES_TYPE_MAP[type];
    };
    GLGeometry.prototype.getAttributeNames = function () {
        return this.attributesName;
    };
    GLGeometry.prototype.setDrawStart = function (count) {
        this.drawStart = count;
    };
    GLGeometry.prototype.getDrawStart = function () {
        return this.drawStart;
    };
    GLGeometry.prototype.setDrawCount = function (count) {
        this.drawCount = count;
    };
    GLGeometry.prototype.getDrawCount = function () {
        return this.drawCount;
    };
    // 根据attribute的datasource获取js端buffer
    GLGeometry.prototype.getAttributeBufferOption = function (name) {
        var attribute = this.attributes[name];
        return attribute ? this.bufferProps[attribute.dataSource] : undefined;
    };
    GLGeometry.prototype.createIndicesBuffer = function (pipelineContext, data) {
        var type = INDEX_TYPE_MAP[data.BYTES_PER_ELEMENT];
        var indexProps = {
            data: data,
            target: glContext.ELEMENT_ARRAY_BUFFER,
            type: type,
            name: "".concat(this.name, "##index"),
        };
        return new GLGPUBuffer(pipelineContext, indexProps);
    };
    GLGeometry.prototype.flush = function () {
        var _this = this;
        if (!this.initialized) {
            return;
        }
        var attributes = this.attributes;
        var bufferProps = this.bufferProps;
        var indices = this.indices;
        Object.keys(this.dirtyFlags).forEach(function (name) {
            var flag = _this.dirtyFlags[name];
            var buffer;
            var data;
            if (name == 'index') {
                buffer = _this.indicesBuffer;
                data = indices;
            }
            else {
                var bufferName = attributes[name].dataSource;
                buffer = _this.buffers[bufferName];
                data = bufferProps[bufferName].data;
            }
            if ((flag.dirty || flag.discard) && buffer && data) {
                if (flag.discard) {
                    buffer.bufferData(data);
                }
                else {
                    var offset = flag.start * data.BYTES_PER_ELEMENT + data.byteOffset;
                    var length_3 = flag.end - flag.start + 1;
                    // @ts-expect-error safe to use
                    var subData = new data.constructor(data.buffer, offset, length_3);
                    buffer.bufferSubData(flag.start, subData);
                }
                flag.start = Number.POSITIVE_INFINITY;
                flag.end = 0;
                flag.dirty = flag.discard = false;
            }
        });
        // 需要释放的 attributes 数据
        Object.keys(this.attributesReleasable).forEach(function (name) {
            var releasable = _this.attributesReleasable[name];
            var bufferName = attributes[name].dataSource;
            if (bufferProps[bufferName] && releasable) {
                bufferProps[bufferName].data = undefined;
            }
        });
        // 释放 indices buffer
        if (this.indicesReleasable) ;
    };
    GLGeometry.prototype.dispose = function () {
        var _this = this;
        var _a;
        this.drawStart = 0;
        this.drawCount = NaN;
        this.bufferProps = {};
        this.indices = undefined;
        this.attributes = {};
        this.attributesName = [];
        if (this.initialized) {
            Object.keys(this.buffers).forEach(function (name) {
                _this.buffers[name].dispose();
            });
            this.buffers = {};
            (_a = this.indicesBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
            Object.keys(this.vaos).forEach(function (name) {
                var _a;
                (_a = _this.vaos[name]) === null || _a === void 0 ? void 0 : _a.dispose();
                _this.vaos[name] = undefined;
            });
            this.indicesBuffer = undefined;
            if (this.engine !== undefined) {
                this.engine.removeGeometry(this);
                this.engine = undefined;
            }
        }
        this.destroyed = true;
    };
    return GLGeometry;
}(Geometry));

var GLMaterialState = /** @class */ (function () {
    function GLMaterialState() {
        this.reset();
    }
    GLMaterialState.prototype.setBlendColor = function (color) {
        var _a = __read$1(color, 4), r = _a[0], g = _a[1], b = _a[2], a = _a[3];
        if (this.blendColor[0] === r && this.blendColor[1] === g && this.blendColor[2] === b && this.blendColor[3] === a) {
            return;
        }
        this.blendColor[0] = r;
        this.blendColor[1] = g;
        this.blendColor[2] = b;
        this.blendColor[3] = a;
    };
    GLMaterialState.prototype.setBlending = function (value) {
        if (this.blending !== value) {
            this.blending = value;
        }
    };
    GLMaterialState.prototype.setBlendFunctionParameters = function (value) {
        var _a = __read$1(value, 4), blendSrc = _a[0], blendDst = _a[1], blendSrcAlpha = _a[2], blendDstAlpha = _a[3];
        if (this.blendFunctionParameters[0] === blendSrc &&
            this.blendFunctionParameters[1] === blendDst &&
            this.blendFunctionParameters[2] === blendSrcAlpha &&
            this.blendFunctionParameters[3] === blendDstAlpha) {
            return;
        }
        this.blendFunctionParameters[0] = blendSrc;
        this.blendFunctionParameters[1] = blendDst;
        this.blendFunctionParameters[2] = blendSrcAlpha;
        this.blendFunctionParameters[3] = blendDstAlpha;
    };
    GLMaterialState.prototype.setBlendEquationParameters = function (value) {
        var _a = __read$1(value, 2), rgb = _a[0], alpha = _a[1];
        if (this.blendEquationParameters[0] === rgb && this.blendEquationParameters[1] === alpha) {
            return;
        }
        this.blendEquationParameters[0] = rgb;
        this.blendEquationParameters[1] = alpha;
    };
    GLMaterialState.prototype.setDepthTest = function (value) {
        if (this.depthTest === value) {
            return;
        }
        this.depthTest = value;
    };
    GLMaterialState.prototype.setDepthMask = function (value) {
        if (this.depthMask === value) {
            return;
        }
        this.depthMask = value;
    };
    GLMaterialState.prototype.setDepthRange = function (value) {
        if (this.depthRange[0] === value[0] && this.depthRange[1] === value[1]) {
            return;
        }
        this.depthRange[0] = value[0];
        this.depthRange[1] = value[1];
    };
    GLMaterialState.prototype.setDepthFunc = function (value) {
        if (this.depthFunc === value) {
            return;
        }
        this.depthFunc = value;
    };
    GLMaterialState.prototype.setPolygonOffsetFill = function (value) {
        if (this.polygonOffsetFill === value) {
            return;
        }
        this.polygonOffsetFill = value;
    };
    GLMaterialState.prototype.setPolygonOffset = function (value) {
        if (this.polygonOffset[0] === value[0] && this.polygonOffset[1] === value[1]) {
            return;
        }
        this.polygonOffset[0] = value[0];
        this.polygonOffset[1] = value[1];
    };
    GLMaterialState.prototype.setSampleAlphaToCoverage = function (value) {
        if (this.sampleAlphaToCoverage === value) {
            return;
        }
        this.sampleAlphaToCoverage = value;
    };
    GLMaterialState.prototype.setColorMask = function (color) {
        var _a = __read$1(color, 4), r = _a[0], g = _a[1], b = _a[2], a = _a[3];
        if (this.colorMask[0] === r && this.colorMask[1] === g && this.colorMask[2] === b && this.colorMask[3] === a) {
            return;
        }
        this.colorMask[0] = r;
        this.colorMask[1] = g;
        this.colorMask[2] = b;
        this.colorMask[3] = a;
    };
    GLMaterialState.prototype.setStencilTest = function (value) {
        if (this.stencilTest === value) {
            return;
        }
        this.stencilTest = value;
    };
    GLMaterialState.prototype.setStencilMask = function (value) {
        if (this.stencilMask[0] === value[0] && this.stencilMask[1] === value[1]) {
            return;
        }
        this.stencilMask[0] = value[0];
        this.stencilMask[1] = value[1];
    };
    GLMaterialState.prototype.setStencilRef = function (value) {
        if (this.stencilRef[0] === value[0] && this.stencilRef[1] === value[1]) {
            return;
        }
        this.stencilRef[0] = value[0];
        this.stencilRef[1] = value[1];
    };
    GLMaterialState.prototype.setStencilFunc = function (value) {
        if (this.stencilFunc[0] === value[0] && this.stencilFunc[1] === value[1]) {
            return;
        }
        this.stencilFunc[0] = value[0];
        this.stencilFunc[1] = value[1];
    };
    GLMaterialState.prototype.setStencilOpFail = function (value) {
        if (this.stencilOpFail[0] === value[0] && this.stencilOpFail[1] === value[1]) {
            return;
        }
        this.stencilOpFail[0] = value[0];
        this.stencilOpFail[1] = value[1];
    };
    GLMaterialState.prototype.setStencilOpZFail = function (value) {
        if (this.stencilOpZFail[0] === value[0] && this.stencilOpZFail[1] === value[1]) {
            return;
        }
        this.stencilOpZFail[0] = value[0];
        this.stencilOpZFail[1] = value[1];
    };
    GLMaterialState.prototype.setStencilOpZPass = function (value) {
        if (this.stencilOpZPass[0] === value[0] && this.stencilOpZPass[1] === value[1]) {
            return;
        }
        this.stencilOpZPass[0] = value[0];
        this.stencilOpZPass[1] = value[1];
    };
    GLMaterialState.prototype.setCulling = function (value) {
        if (this.culling === value) {
            return;
        }
        this.culling = value;
    };
    GLMaterialState.prototype.setFrontFace = function (value) {
        if (this.frontFace === value) {
            return;
        }
        this.frontFace = value;
    };
    GLMaterialState.prototype.setCullFace = function (value) {
        if (this.cullFace === value) {
            return;
        }
        this.cullFace = value;
    };
    GLMaterialState.prototype.reset = function () {
        this.blending = false;
        this.blendColor = [0, 0, 0, 0];
        this.blendFunctionParameters = [glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA, glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA];
        this.blendEquationParameters = [glContext.FUNC_ADD, glContext.FUNC_ADD];
        this.depthTest = false;
        this.depthMask = false;
        this.depthRange = [0, 1];
        this.depthFunc = glContext.LESS;
        this.polygonOffset = [0, 0];
        this.polygonOffsetFill = false;
        this.sampleAlphaToCoverage = false;
        this.colorMask = [true, true, true, true];
        this.stencilTest = false;
        this.stencilMask = [0xFF, 0xFF];
        this.stencilRef = [0, 0];
        this.stencilFunc = [glContext.ALWAYS, glContext.ALWAYS];
        this.stencilOpFail = [glContext.KEEP, glContext.KEEP];
        this.stencilOpZFail = [glContext.KEEP, glContext.KEEP];
        this.stencilOpZPass = [glContext.KEEP, glContext.KEEP];
        this.culling = false;
        this.frontFace = glContext.CW;
        this.cullFace = glContext.FRONT;
    };
    GLMaterialState.prototype.apply = function (pipelineContext) {
        pipelineContext.toggle(glContext.SAMPLE_ALPHA_TO_COVERAGE, this.sampleAlphaToCoverage);
        pipelineContext.toggle(glContext.BLEND, this.blending);
        pipelineContext.toggle(glContext.DEPTH_TEST, this.depthTest);
        pipelineContext.toggle(glContext.STENCIL_TEST, this.stencilTest);
        pipelineContext.toggle(glContext.CULL_FACE, this.culling);
        pipelineContext.toggle(glContext.POLYGON_OFFSET_FILL, this.polygonOffsetFill);
        if (this.stencilTest) {
            //stencil
            pipelineContext.stencilMaskSeparate(glContext.BACK, this.stencilMask[1]);
            pipelineContext.stencilMaskSeparate(glContext.FRONT, this.stencilMask[0]);
            pipelineContext.stencilFuncSeparate(glContext.BACK, this.stencilFunc[0], this.stencilRef[0], this.stencilMask[0]);
            pipelineContext.stencilFuncSeparate(glContext.FRONT, this.stencilFunc[1], this.stencilRef[1], this.stencilMask[1]);
            pipelineContext.stencilOpSeparate(glContext.BACK, this.stencilOpFail[0], this.stencilOpZFail[0], this.stencilOpZPass[0]);
            pipelineContext.stencilOpSeparate(glContext.FRONT, this.stencilOpFail[1], this.stencilOpZFail[1], this.stencilOpZPass[1]);
        }
        if (this.blending) {
            var _a = this, blendColor = _a.blendColor, blendEquationParameters = _a.blendEquationParameters, blendFunctionParameters = _a.blendFunctionParameters;
            pipelineContext.blendColor(blendColor[0], blendColor[1], blendColor[2], blendColor[3]);
            pipelineContext.blendEquationSeparate(blendEquationParameters[0], blendEquationParameters[1]);
            pipelineContext.blendFuncSeparate(blendFunctionParameters[0], blendFunctionParameters[1], blendFunctionParameters[2], blendFunctionParameters[3]);
        }
        //color depth
        pipelineContext.colorMask(this.colorMask[0], this.colorMask[1], this.colorMask[2], this.colorMask[3]);
        if (this.depthTest) {
            pipelineContext.depthMask(this.depthMask);
            pipelineContext.depthFunc(this.depthFunc);
            pipelineContext.depthRange(this.depthRange[0], this.depthRange[1]);
        }
        if (this.culling) {
            //face
            pipelineContext.cullFace(this.cullFace);
            pipelineContext.frontFace(this.frontFace);
        }
        if (this.polygonOffsetFill) {
            pipelineContext.polygonOffset(this.polygonOffset[0], this.polygonOffset[1]);
        }
    };
    return GLMaterialState;
}());

var GLMaterial = /** @class */ (function (_super) {
    __extends(GLMaterial, _super);
    function GLMaterial(props) {
        var _this = _super.call(this, props) || this;
        // material存放的uniform数据。
        _this.floats = {};
        _this.ints = {};
        _this.vector2s = {};
        _this.vector3s = {};
        _this.vector4s = {};
        _this.matrices = {};
        _this.matrice3s = {};
        _this.textures = {};
        _this.floatArrays = {};
        _this.vector4Arrays = {};
        _this.matrixArrays = {};
        _this.samplers = []; // material存放的sampler名称。
        _this.uniforms = []; // material存放的uniform名称（不包括sampler）。
        _this.uniformDirtyFlag = true;
        _this.glMaterialState = new GLMaterialState();
        return _this;
    }
    Object.defineProperty(GLMaterial.prototype, "blending", {
        get: function () {
            return this.glMaterialState.blending;
        },
        set: function (blending) {
            blending !== undefined && this.glMaterialState.setBlending(blending);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "blendColor", {
        get: function () {
            return this.glMaterialState.blendColor;
        },
        set: function (color) {
            color && this.glMaterialState.setBlendColor(color);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "blendFunction", {
        get: function () {
            return this.glMaterialState.blendFunctionParameters;
        },
        set: function (func) {
            func && this.glMaterialState.setBlendFunctionParameters(func);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "blendEquation", {
        get: function () {
            return this.glMaterialState.blendEquationParameters;
        },
        set: function (equation) {
            equation && this.glMaterialState.setBlendEquationParameters(equation);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "depthTest", {
        get: function () {
            return this.glMaterialState.depthTest;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setDepthTest(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "depthMask", {
        get: function () {
            return this.glMaterialState.depthMask;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setDepthMask(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "depthRange", {
        get: function () {
            return this.glMaterialState.depthRange;
        },
        set: function (value) {
            value && this.glMaterialState.setDepthRange(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "depthFunc", {
        get: function () {
            return this.glMaterialState.depthFunc;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setDepthFunc(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "polygonOffsetFill", {
        get: function () {
            return this.glMaterialState.polygonOffsetFill;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setPolygonOffsetFill(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "polygonOffset", {
        get: function () {
            return this.glMaterialState.polygonOffset;
        },
        set: function (value) {
            value && this.glMaterialState.setPolygonOffset(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "sampleAlphaToCoverage", {
        get: function () {
            return this.glMaterialState.sampleAlphaToCoverage;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setSampleAlphaToCoverage(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "colorMask", {
        get: function () {
            return this.glMaterialState.colorMask;
        },
        set: function (value) {
            value && this.glMaterialState.setColorMask(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilTest", {
        get: function () {
            return this.glMaterialState.stencilTest;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setStencilTest(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilMask", {
        get: function () {
            return this.glMaterialState.stencilMask;
        },
        set: function (value) {
            value && this.glMaterialState.setStencilMask(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilRef", {
        get: function () {
            return this.glMaterialState.stencilRef;
        },
        set: function (value) {
            value && this.glMaterialState.setStencilRef(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilFunc", {
        get: function () {
            return this.glMaterialState.stencilFunc;
        },
        set: function (value) {
            value && this.glMaterialState.setStencilFunc(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilOpFail", {
        get: function () {
            return this.glMaterialState.stencilOpFail;
        },
        set: function (value) {
            value && this.glMaterialState.setStencilOpFail(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilOpZFail", {
        get: function () {
            return this.glMaterialState.stencilOpZFail;
        },
        set: function (value) {
            value && this.glMaterialState.setStencilOpZFail(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilOpZPass", {
        get: function () {
            return this.glMaterialState.stencilOpZPass;
        },
        set: function (value) {
            value && this.glMaterialState.setStencilOpZPass(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "culling", {
        get: function () {
            return this.glMaterialState.culling;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setCulling(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "frontFace", {
        get: function () {
            return this.glMaterialState.frontFace;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setFrontFace(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "cullFace", {
        get: function () {
            return this.glMaterialState.cullFace;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setCullFace(value);
        },
        enumerable: false,
        configurable: true
    });
    GLMaterial.prototype.enableKeyword = function (keyword) {
        throw new Error('Method not implemented.');
    };
    GLMaterial.prototype.disableKeyword = function (keyword) {
        throw new Error('Method not implemented.');
    };
    GLMaterial.prototype.isKeywordEnabled = function (keyword) {
        throw new Error('Method not implemented.');
    };
    // TODO 待废弃 兼容 model/spine 插件 改造后可移除
    GLMaterial.prototype.createMaterialStates = function (states) {
        this.sampleAlphaToCoverage = !!(states.sampleAlphaToCoverage);
        this.depthTest = states.depthTest;
        this.depthMask = states.depthMask;
        this.depthRange = states.depthRange;
        this.depthFunc = states.depthFunc;
        this.colorMask = states.colorMask;
        this.polygonOffset = states.polygonOffset;
        this.polygonOffsetFill = states.polygonOffsetFill;
        this.blending = states.blending;
        this.blendFunction = states.blendFunction;
        this.stencilTest = states.stencilTest;
    };
    Object.defineProperty(GLMaterial.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    /**shader和texture的GPU资源初始化。 */
    GLMaterial.prototype.initialize = function (engine) {
        var e_1, _a;
        if (this.initialized) {
            return;
        }
        this.engine = engine;
        this.engine.addMaterial(this);
        if (!this.shader) {
            var pipelineContext = this.engine.getGLPipelineContext();
            this.shader = pipelineContext.shaderLibrary.createShader(this.shaderSource);
        }
        this.shader.initialize(engine);
        try {
            for (var _b = __values$1(Object.values(this.textures)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var texture = _c.value;
                texture.initialize(engine);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.initialized = true;
    };
    GLMaterial.prototype.setupStates = function (pipelineContext) {
        this.glMaterialState.apply(pipelineContext);
    };
    GLMaterial.prototype.use = function (renderer) {
        var engine = renderer.engine;
        var pipelineContext = engine.getGLPipelineContext();
        this.shader.program.bind();
        this.setupStates(pipelineContext);
        var name;
        if (this.uniformDirtyFlag) {
            this.shader.fillShaderInformation(this.uniforms, this.samplers);
            this.uniformDirtyFlag = false;
        }
        // 检查贴图数据是否初始化。
        for (name in this.textures) {
            if (!this.textures[name].textureBuffer) {
                this.textures[name].initialize(engine);
            }
        }
        for (name in this.floats) {
            this.shader.setFloat(name, this.floats[name]);
        }
        for (name in this.ints) {
            this.shader.setInt(name, this.ints[name]);
        }
        for (name in this.floatArrays) {
            this.shader.setFloats(name, this.floatArrays[name]);
        }
        for (name in this.textures) {
            this.shader.setTexture(name, this.textures[name]);
        }
        for (name in this.vector2s) {
            this.shader.setVector2(name, this.vector2s[name]);
        }
        for (name in this.vector3s) {
            this.shader.setVector3(name, this.vector3s[name]);
        }
        for (name in this.vector4s) {
            this.shader.setVector4(name, this.vector4s[name]);
        }
        for (name in this.matrices) {
            this.shader.setMatrix(name, this.matrices[name]);
        }
        for (name in this.matrice3s) {
            this.shader.setMatrix3(name, this.matrice3s[name]);
        }
        for (name in this.vector4Arrays) {
            this.shader.setVector4Array(name, this.vector4Arrays[name]);
        }
        for (name in this.matrixArrays) {
            this.shader.setMatrixArray(name, this.matrixArrays[name]);
        }
    };
    GLMaterial.prototype.getFloat = function (name) {
        return this.floats[name];
    };
    GLMaterial.prototype.setFloat = function (name, value) {
        this.checkUniform(name);
        this.floats[name] = value;
    };
    GLMaterial.prototype.getInt = function (name) {
        return this.ints[name];
    };
    GLMaterial.prototype.setInt = function (name, value) {
        this.checkUniform(name);
        this.ints[name] = value;
    };
    GLMaterial.prototype.getFloats = function (name) {
        return this.floatArrays[name];
    };
    GLMaterial.prototype.setFloats = function (name, value) {
        this.checkUniform(name);
        this.floatArrays[name] = value;
    };
    GLMaterial.prototype.getVector2 = function (name) {
        return this.vector2s[name];
    };
    GLMaterial.prototype.setVector2 = function (name, value) {
        this.checkUniform(name);
        this.vector2s[name] = value;
    };
    GLMaterial.prototype.getVector3 = function (name) {
        return this.vector3s[name];
    };
    GLMaterial.prototype.setVector3 = function (name, value) {
        this.checkUniform(name);
        this.vector3s[name] = value;
    };
    GLMaterial.prototype.getVector4 = function (name) {
        return this.vector4s[name];
    };
    GLMaterial.prototype.setVector4 = function (name, value) {
        this.checkUniform(name);
        this.vector4s[name] = value;
    };
    GLMaterial.prototype.getMatrix = function (name) {
        return this.matrices[name];
    };
    GLMaterial.prototype.setMatrix = function (name, value) {
        this.checkUniform(name);
        this.matrices[name] = value;
    };
    GLMaterial.prototype.setMatrix3 = function (name, value) {
        this.checkUniform(name);
        this.matrice3s[name] = value;
    };
    GLMaterial.prototype.getVector4Array = function (name) {
        return this.vector4Arrays[name];
    };
    GLMaterial.prototype.setVector4Array = function (name, array) {
        var e_2, _a;
        this.checkUniform(name);
        if (!this.vector4Arrays[name]) {
            this.vector4Arrays[name] = [];
        }
        try {
            for (var array_1 = __values$1(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
                var v = array_1_1.value;
                this.vector4Arrays[name].push(v[0], v[1], v[2], v[3]);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    GLMaterial.prototype.getMatrixArray = function (name) {
        return this.matrixArrays[name];
    };
    GLMaterial.prototype.setMatrixArray = function (name, array) {
        var e_3, _a;
        this.checkUniform(name);
        if (!this.matrixArrays[name]) {
            this.matrixArrays[name] = [];
        }
        try {
            for (var array_2 = __values$1(array), array_2_1 = array_2.next(); !array_2_1.done; array_2_1 = array_2.next()) {
                var m = array_2_1.value;
                for (var i = 0; i < 16; i++) {
                    this.matrixArrays[name].push(m[i]);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (array_2_1 && !array_2_1.done && (_a = array_2.return)) _a.call(array_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    GLMaterial.prototype.setMatrixNumberArray = function (name, array) {
        this.checkUniform(name);
        this.matrixArrays[name] = array;
    };
    GLMaterial.prototype.getTexture = function (name) {
        return this.textures[name];
    };
    GLMaterial.prototype.setTexture = function (name, texture) {
        if (!this.samplers.includes(name)) {
            this.samplers.push(name);
            this.uniformDirtyFlag = true;
        }
        this.textures[name] = texture;
    };
    GLMaterial.prototype.hasUniform = function (name) {
        return this.uniforms.includes(name) || this.samplers.includes(name);
    };
    GLMaterial.prototype.clone = function (props) {
        var newProps = props ? props : this.props;
        var clonedMaterial = new GLMaterial(newProps);
        // TODO: 更换 Object.assign，低端设备兼容问题
        clonedMaterial.glMaterialState = Object.assign(new GLMaterialState(), clonedMaterial.glMaterialState);
        clonedMaterial.floats = this.floats;
        clonedMaterial.ints = this.ints;
        clonedMaterial.vector2s = this.vector2s;
        clonedMaterial.vector3s = this.vector3s;
        clonedMaterial.vector4s = this.vector4s;
        clonedMaterial.matrices = this.matrices;
        clonedMaterial.textures = this.textures;
        clonedMaterial.floatArrays = this.floatArrays;
        clonedMaterial.vector4Arrays = this.vector4Arrays;
        clonedMaterial.matrixArrays = this.matrixArrays;
        clonedMaterial.samplers = this.samplers;
        clonedMaterial.uniforms = this.uniforms;
        clonedMaterial.uniformDirtyFlag = true;
        return clonedMaterial;
    };
    GLMaterial.prototype.checkUniform = function (uniformName) {
        if (!this.uniforms.includes(uniformName)) {
            this.uniforms.push(uniformName);
            this.uniformDirtyFlag = true;
        }
    };
    GLMaterial.prototype.dispose = function (options) {
        var e_4, _a;
        var _b;
        if (this.destroyed) {
            return;
        }
        (_b = this.shader) === null || _b === void 0 ? void 0 : _b.dispose();
        if ((options === null || options === void 0 ? void 0 : options.textures) !== exports.DestroyOptions.keep) {
            try {
                for (var _c = __values$1(Object.values(this.textures)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var texture = _d.value;
                    texture.dispose();
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        // @ts-expect-error
        this.shaderSource = null;
        // @ts-expect-error
        this.uniformSemantics = {};
        this.floats = {};
        this.ints = {};
        this.vector2s = {};
        this.vector3s = {};
        this.vector4s = {};
        this.matrices = {};
        this.matrice3s = {};
        this.textures = {};
        this.floatArrays = {};
        this.vector4Arrays = {};
        this.matrixArrays = {};
        this.samplers = [];
        this.uniforms = [];
        this.initialize = throwDestroyedError$1;
        this.destroyed = true;
        if (this.engine !== undefined) {
            this.engine.removeMaterial(this);
            this.engine = undefined;
        }
    };
    return GLMaterial;
}(Material));

var copyShaderId = '$mri-internal-copy';
var ExtWrap = /** @class */ (function () {
    function ExtWrap(renderer) {
        this.renderer = renderer;
        if (GPUCapability.getInstance().level === 1) {
            this.copyRenderPass = this.createCopyRenderPass().initialize(renderer);
            var shaderSource = this.copyRenderPass.meshes[0].material.shaderSource;
            renderer.pipelineContext.shaderLibrary.addShader(shaderSource);
        }
    }
    ExtWrap.prototype.resetColorAttachments = function (rp, colorTextures) {
        if (this.renderer) {
            rp.resetColorAttachments(colorTextures);
        }
    };
    ExtWrap.prototype.copyTexture = function (source, tex) {
        if (!this.renderer) {
            return;
        }
        var renderer = this.renderer;
        source.initialize(renderer.engine);
        tex.initialize(renderer.engine);
        tex.updateSource({
            sourceType: exports.TextureSourceType.framebuffer,
            data: {
                width: tex.getWidth() || source.getWidth(),
                height: tex.getHeight() || source.getHeight(),
            },
        });
        if (GPUCapability.getInstance().level === 2) {
            this.copy2(source, tex);
        }
        else {
            this.copy1(source, tex);
        }
    };
    ExtWrap.prototype.copy2 = function (source, target) {
        var _a;
        // 保存当前的 fbo
        var frameBuffer = this.renderer.getFrameBuffer();
        (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.glRenderer.copy2(source, target);
        // 还原 fbo
        this.renderer.setFrameBuffer(frameBuffer);
    };
    ExtWrap.prototype.copy1 = function (source, target) {
        var rp = this.copyRenderPass;
        if (rp) {
            var renderer = this.renderer;
            if (renderer) {
                var fb = rp.frameBuffer;
                fb.viewport[2] = target.getWidth() || source.getWidth();
                fb.viewport[3] = target.getHeight() || source.getHeight();
                renderer.glRenderer.resetColorAttachments(fb, [target]);
                var mesh = rp.meshes[0];
                mesh.material.setTexture('uTex', source);
                renderer.renderRenderPass(rp);
            }
        }
    };
    ExtWrap.prototype.createCopyRenderPass = function () {
        var name = 'mri-copy-mesh';
        var attachment = { texture: { format: glContext.RGBA } };
        var geometry = new GLGeometry({
            name: name,
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([-1, 1, -1, -1, 1, 1, 1, -1]),
                },
            },
            drawCount: 4,
        });
        var vertexShader = "\n        precision highp float;\n      attribute vec2 aPos;\n      varying vec2 vTex;\n      void main(){\n         gl_Position = vec4(aPos,0.,1.0);\n         vTex = (aPos + vec2(1.))/2.;\n       }\n      ";
        var fragmentShader = "\n        precision highp float;\n      varying vec2 vTex;\n      uniform sampler2D uTex;\n      void main(){gl_FragColor = texture2D(uTex,vTex);}\n      ";
        var level = GPUCapability.getInstance().level;
        var material = new GLMaterial({
            name: name,
            shader: {
                cacheId: copyShaderId,
                name: name,
                vertex: createShaderWithMarcos([], vertexShader, exports.ShaderType.vertex),
                fragment: createShaderWithMarcos([], fragmentShader, exports.ShaderType.fragment),
                glslVersion: level === 2 ? exports.GLSLVersion.GLSL3 : exports.GLSLVersion.GLSL1,
            },
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        var mesh = new GLMesh({
            name: name,
            geometry: geometry,
            material: material,
            priority: 0,
        });
        // TODO: RenderPass 加 camera 可以再看看是否必要？
        var camera = new Camera('ext_wrap_camera');
        return new CopyTexturePass({
            name: 'mri-copy-rp',
            clearAction: {
                colorAction: exports.TextureLoadAction.whatever,
            },
            attachments: [attachment],
            meshes: [mesh],
            camera: camera,
        });
    };
    ExtWrap.prototype.dispose = function () {
        var _a;
        if (this.renderer) {
            (_a = this.copyRenderPass) === null || _a === void 0 ? void 0 : _a.dispose();
            // @ts-expect-error
            this.renderer = undefined;
        }
    };
    return ExtWrap;
}());
var CopyTexturePass = /** @class */ (function (_super) {
    __extends(CopyTexturePass, _super);
    function CopyTexturePass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CopyTexturePass.prototype.configure = function (renderer) {
        this.currentFrameBuffer = renderer.getFrameBuffer();
        renderer.setFrameBuffer(this.frameBuffer);
    };
    CopyTexturePass.prototype.execute = function (renderer) {
        if (this.clearAction) {
            renderer.clear(this.clearAction);
        }
        renderer.renderMeshes(this.meshes);
        if (this.storeAction) {
            renderer.clear(this.storeAction);
        }
        renderer.setFrameBuffer(this.currentFrameBuffer);
    };
    return CopyTexturePass;
}(RenderPass));

var GLContextManager = /** @class */ (function () {
    function GLContextManager(canvas, glType, options) {
        if (glType === void 0) { glType = 'webgl'; }
        if (options === void 0) { options = {}; }
        var _this = this;
        this.canvas = canvas;
        this.glType = glType;
        this.restoreHandlers = [];
        this.lostHandlers = [];
        assertExist(canvas);
        this.gl = createGLContext(canvas, glType, options);
        this.contextLostListener = function (e) {
            var e_1, _a;
            try {
                for (var _b = __values$1(_this.lostHandlers), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var lostHandler = _c.value;
                    lostHandler.lost(e);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        this.contextRestoredListener = function (e) {
            var e_2, _a;
            try {
                for (var _b = __values$1(_this.restoreHandlers), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var restorable = _c.value;
                    restorable.restore();
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        canvas.addEventListener('webglcontextlost', this.contextLostListener);
        canvas.addEventListener('webglcontextrestored', this.contextRestoredListener);
    }
    GLContextManager.prototype.dispose = function () {
        if (this.canvas) {
            this.canvas.removeEventListener('webglcontextlost', this.contextLostListener);
            this.canvas.removeEventListener('webglcontextrestored', this.contextRestoredListener);
        }
        this.gl = null;
        this.canvas = null;
    };
    GLContextManager.prototype.addLostHandler = function (lostHandler) {
        this.lostHandlers.push(lostHandler);
    };
    GLContextManager.prototype.removeLostHandler = function (lostHandler) {
        var index = this.lostHandlers.indexOf(lostHandler);
        if (index > -1) {
            this.lostHandlers.splice(index, 1);
        }
    };
    GLContextManager.prototype.addRestoreHandler = function (restoreHandler) {
        this.restoreHandlers.push(restoreHandler);
    };
    GLContextManager.prototype.removeRestoreHandler = function (restorable) {
        var index = this.restoreHandlers.indexOf(restorable);
        if (index > -1) {
            this.restoreHandlers.splice(index, 1);
        }
    };
    return GLContextManager;
}());

var GLRenderBuffer = /** @class */ (function (_super) {
    __extends(GLRenderBuffer, _super);
    function GLRenderBuffer(props, renderer) {
        var _this = _super.call(this, props) || this;
        _this.initialized = false;
        if (renderer !== undefined) {
            _this.initialize(renderer);
        }
        return _this;
    }
    GLRenderBuffer.prototype.initialize = function (renderer) {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        this.renderer = renderer;
        this.buffer = renderer.createGLRenderBuffer(this);
    };
    GLRenderBuffer.prototype.setSize = function (width, height) {
        if (!this.initialized) {
            console.error('Can\'t set size for uninitialized render buffer');
            return;
        }
        if (width !== this.size[0] || height !== this.size[1]) {
            var _a = this.renderer, gl = _a.gl, state = _a.pipelineContext;
            state.bindRenderBuffer(gl.RENDERBUFFER, this.buffer);
            if (width && height) {
                gl.renderbufferStorage(gl.RENDERBUFFER, this.format, this.size[0] = width, this.size[1] = height);
            }
            else {
                console.error("Invalid render buffer size: ".concat(width, "x").concat(height));
            }
        }
    };
    GLRenderBuffer.prototype.dispose = function () {
        if (this.renderer) {
            this.renderer.deleteGLRenderBuffer(this);
            this.renderer = null;
            this.buffer = null;
        }
        this.destroyed = true;
        this.initialize = throwDestroyedError$1;
    };
    return GLRenderBuffer;
}(RenderBuffer));

var seed$1 = 1;
var GLFrameBuffer = /** @class */ (function (_super) {
    __extends(GLFrameBuffer, _super);
    function GLFrameBuffer(props, renderer) {
        var _this = this;
        var _a;
        _this = _super.call(this) || this;
        _this.attachmentTextures = [];
        _this.renderer = renderer;
        var depthStencilAttachment = props.depthStencilAttachment, viewport = props.viewport, isCustomViewport = props.isCustomViewport, _b = props.viewportScale, viewportScale = _b === void 0 ? 1 : _b, storeAction = props.storeAction, _c = props.name, name = _c === void 0 ? "GLFrameBuffer".concat(seed$1++) : _c;
        _this.depthStencilStorageType = (_a = depthStencilAttachment === null || depthStencilAttachment === void 0 ? void 0 : depthStencilAttachment.storageType) !== null && _a !== void 0 ? _a : exports.RenderPassAttachmentStorageType.none;
        _this.viewport = viewport;
        _this.isCustomViewport = !!isCustomViewport;
        _this.viewportScale = viewportScale;
        _this.name = name;
        _this.storeAction = storeAction;
        _this.updateProps(props);
        return _this;
    }
    Object.defineProperty(GLFrameBuffer.prototype, "stencilStorage", {
        get: function () {
            var storageType = this.depthStencilStorageType;
            if (storageType !== exports.RenderPassAttachmentStorageType.depth_16_opaque) {
                return this.depthStencilRenderBuffer;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLFrameBuffer.prototype, "depthStorage", {
        get: function () {
            if (this.depthStencilStorageType !== exports.RenderPassAttachmentStorageType.stencil_8_opaque) {
                return this.depthStencilRenderBuffer;
            }
        },
        enumerable: false,
        configurable: true
    });
    GLFrameBuffer.prototype.getDepthTexture = function () {
        return this.depthTexture;
    };
    GLFrameBuffer.prototype.getStencilTexture = function () {
        return this.stencilTexture;
    };
    GLFrameBuffer.prototype.getColorTextures = function () {
        return this.colorTextures;
    };
    GLFrameBuffer.prototype.updateAttachmentTextures = function () {
        var _this = this;
        this.attachmentTextures.length = 0;
        this.colorTextures.forEach(function (tex) {
            tex.initialize(_this.renderer.engine);
            addItem(_this.attachmentTextures, tex.textureBuffer);
        });
        if (this.stencilTexture) {
            addItem(this.attachmentTextures, this.stencilTexture.textureBuffer);
        }
        if (this.depthTexture) {
            addItem(this.attachmentTextures, this.depthTexture.textureBuffer);
        }
    };
    GLFrameBuffer.prototype.updateProps = function (props) {
        var _a, _b;
        var renderer = this.renderer;
        var gpuCapability = GPUCapability.getInstance();
        var depthStencilAttachment = (_a = props.depthStencilAttachment) !== null && _a !== void 0 ? _a : { storageType: exports.RenderPassAttachmentStorageType.none };
        var willUseFbo = props.attachments.length > 0;
        this.externalStorage = false;
        var separateDepthStencil = true;
        if (props.attachments.length > 1 && !gpuCapability.detail.drawBuffers) {
            throw Error('multiple color attachments not support');
        }
        var optDepthStencilTex = (_b = props.depthStencilAttachment) === null || _b === void 0 ? void 0 : _b.texture;
        var readableDepthStencilTextures = gpuCapability.detail.readableDepthStencilTextures;
        this.colorTextures = props.attachments.slice();
        if (!willUseFbo && depthStencilAttachment.storageType !== exports.RenderPassAttachmentStorageType.none) {
            throw Error('use depth stencil attachment without color attachments');
        }
        if (willUseFbo) {
            this.fbo = renderer.glRenderer.createGLFrameBuffer(this, this.name);
        }
        var storageType = depthStencilAttachment.storageType;
        if (storageType === exports.RenderPassAttachmentStorageType.depth_stencil_opaque) {
            if (depthStencilAttachment.storage) {
                if (depthStencilAttachment.storage instanceof GLRenderBuffer) {
                    this.depthStencilRenderBuffer = depthStencilAttachment.storage;
                    this.externalStorage = true;
                }
                else {
                    throw Error('invalid depth stencil attachment storage');
                }
            }
            else {
                this.depthStencilRenderBuffer = new GLRenderBuffer({
                    format: glContext.DEPTH_STENCIL,
                    attachment: glContext.DEPTH_STENCIL_ATTACHMENT,
                    storageType: storageType,
                }, renderer.glRenderer);
            }
            separateDepthStencil = false;
        }
        else if (storageType === exports.RenderPassAttachmentStorageType.depth_16_opaque) {
            if (depthStencilAttachment.storage) {
                if (depthStencilAttachment.storage instanceof GLRenderBuffer) {
                    this.depthStencilRenderBuffer = depthStencilAttachment.storage;
                    this.externalStorage = true;
                }
                else {
                    throw Error('invalid depth attachment storage');
                }
            }
            else {
                this.depthStencilRenderBuffer = new GLRenderBuffer({
                    attachment: glContext.DEPTH_ATTACHMENT,
                    format: glContext.DEPTH_COMPONENT16,
                    storageType: storageType,
                }, renderer.glRenderer);
            }
        }
        else if (storageType === exports.RenderPassAttachmentStorageType.stencil_8_opaque) {
            if (depthStencilAttachment.storage) {
                if (depthStencilAttachment.storage instanceof GLRenderBuffer) {
                    this.depthStencilRenderBuffer = depthStencilAttachment.storage;
                    this.externalStorage = true;
                }
                else {
                    throw Error('invalid stencil attachment storage');
                }
            }
            else {
                this.depthStencilRenderBuffer = new GLRenderBuffer({
                    attachment: glContext.STENCIL_ATTACHMENT,
                    format: glContext.STENCIL_INDEX8,
                    storageType: storageType,
                }, renderer.glRenderer);
            }
        }
        else if (storageType === exports.RenderPassAttachmentStorageType.depth_16_texture) {
            if (!readableDepthStencilTextures) {
                throw Error('depth texture is not support in framebuffer');
            }
            this.depthTexture = optDepthStencilTex !== null && optDepthStencilTex !== void 0 ? optDepthStencilTex : new GLTexture({
                sourceType: exports.TextureSourceType.framebuffer,
                format: glContext.DEPTH_COMPONENT,
                internalFormat: gpuCapability.internalFormatDepth16,
                type: glContext.UNSIGNED_SHORT,
                name: "".concat(this.name, "##depthTex"),
            });
            this.depthTexture.initialize(renderer.engine);
        }
        else if (storageType === exports.RenderPassAttachmentStorageType.depth_24_stencil_8_texture) {
            if (!readableDepthStencilTextures) {
                throw Error('depth stencil texture is not support in framebuffer');
            }
            this.depthTexture = this.stencilTexture = optDepthStencilTex !== null && optDepthStencilTex !== void 0 ? optDepthStencilTex : new GLTexture({
                sourceType: exports.TextureSourceType.framebuffer,
                format: glContext.DEPTH_STENCIL,
                internalFormat: gpuCapability.internalFormatDepth24_stencil8,
                type: gpuCapability.UNSIGNED_INT_24_8,
                name: "".concat(this.name, "##dpthStclTex"),
            });
            this.depthTexture.initialize(renderer.engine);
            separateDepthStencil = true;
        }
        this.storeInvalidAttachments = this.getStoreAttachments(this.storeAction, separateDepthStencil);
        this.updateAttachmentTextures();
    };
    GLFrameBuffer.prototype.getStoreAttachments = function (storeAction, separateDepthStencil) {
        var gl = this.renderer.glRenderer.gl;
        var colorLen = this.colorTextures.length;
        if (storeAction && isWebGL2(gl) && colorLen > 0) {
            var attachments = [];
            if (storeAction.depthAction === exports.TextureStoreAction.clear && this.depthStorage) {
                addItem(attachments, separateDepthStencil ? gl.DEPTH_ATTACHMENT : gl.DEPTH_STENCIL_ATTACHMENT);
            }
            if (storeAction.stencilAction === exports.TextureStoreAction.clear && this.stencilStorage) {
                addItem(attachments, separateDepthStencil ? gl.STENCIL_ATTACHMENT : gl.DEPTH_STENCIL_ATTACHMENT);
            }
            if (storeAction.colorAction === exports.TextureStoreAction.clear) {
                for (var i = 0; i < colorLen; i++) {
                    addItem(attachments, gl["COLOR_ATTACHMENT".concat(i)]);
                }
            }
            return attachments;
        }
    };
    GLFrameBuffer.prototype.unbind = function () {
        var att = this.storeInvalidAttachments;
        if (att === null || att === void 0 ? void 0 : att.length) {
            var gl = this.renderer.glRenderer.gl;
            gl.invalidateFramebuffer(gl.FRAMEBUFFER, att);
        }
        this.renderer.pipelineContext.bindSystemFramebuffer();
    };
    GLFrameBuffer.prototype.bind = function () {
        var _this = this;
        var gl = this.renderer.glRenderer.gl;
        var state = this.renderer.pipelineContext;
        if (this.fbo) {
            var FRAMEBUFFER = gl.FRAMEBUFFER;
            var _a = __read$1(this.viewport, 4), x = _a[0], y = _a[1], width = _a[2], height = _a[3];
            state.bindFramebuffer(FRAMEBUFFER, this.fbo);
            // TODO 不在bind中设置viewport
            state.viewport(x, y, width, height);
            var emptyTexture_1 = this.renderer.glRenderer.emptyTexture2D.textureBuffer;
            // in case frame texture loop
            Object.keys(state.textureUnitDict).forEach(function (unit) {
                var texture = state.textureUnitDict[unit];
                if (texture !== emptyTexture_1 &&
                    texture &&
                    _this.attachmentTextures.includes(texture)) {
                    state.activeTexture(+unit);
                    _this.renderer.glRenderer.emptyTexture2D.bind();
                }
            });
            // FIXME: 没有pipeline对象的临时方案
            for (var i = 0; i < 4; i++) {
                state.activeTexture(gl.TEXTURE0 + i);
                this.renderer.glRenderer.emptyTexture2D.bind();
            }
            if (!this.ready) {
                var _b = this, depthStencilRenderBuffer = _b.depthStencilRenderBuffer, depthTexture = _b.depthTexture, stencilTexture = _b.stencilTexture;
                state.activeTexture(gl.TEXTURE0);
                if (depthStencilRenderBuffer) {
                    depthStencilRenderBuffer.setSize(width, height);
                    gl.framebufferRenderbuffer(FRAMEBUFFER, depthStencilRenderBuffer.attachment, gl.RENDERBUFFER, depthStencilRenderBuffer.buffer);
                }
                else if (depthTexture) {
                    // 解决RenderPass在Clone深度贴图时width和height丢失的问题
                    depthTexture.source.data = { width: width, height: height };
                    depthTexture.update({ data: { width: width, height: height, data: new Uint16Array(0) } });
                    var attachment = depthTexture && stencilTexture ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                    gl.framebufferTexture2D(FRAMEBUFFER, attachment, gl.TEXTURE_2D, depthTexture.textureBuffer, 0);
                }
                this.resetColorTextures(this.colorTextures);
                var status_1 = gl.checkFramebufferStatus(FRAMEBUFFER);
                if (status_1 !== gl.FRAMEBUFFER_COMPLETE) {
                    throw new Error("Framebuffer failed, status: ".concat(status_1, ", error: ").concat(gl.getError()));
                }
                this.ready = true;
            }
        }
    };
    GLFrameBuffer.prototype.resetColorTextures = function (colorTextures) {
        var e_1, _a;
        var colors = colorTextures;
        var gl = this.renderer.glRenderer.gl;
        var gpuCapability = GPUCapability.getInstance();
        var viewport = this.viewport;
        var buffers = [];
        if (colors) {
            try {
                for (var colors_1 = __values$1(colors), colors_1_1 = colors_1.next(); !colors_1_1.done; colors_1_1 = colors_1.next()) {
                    var texture = colors_1_1.value;
                    texture.initialize(this.renderer.engine);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (colors_1_1 && !colors_1_1.done && (_a = colors_1.return)) _a.call(colors_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.colorTextures = colors.slice();
        }
        this.renderer.pipelineContext.activeTexture(gl.TEXTURE0);
        this.colorTextures.forEach(function (tex, index) {
            var width = viewport[2];
            var height = viewport[3];
            var data = { width: width, height: height, data: new Uint8Array(0) };
            tex.update({ data: data });
            gpuCapability.framebufferTexture2D(gl, gl.FRAMEBUFFER, index, gl.TEXTURE_2D, tex.textureBuffer);
            buffers.push(true);
        });
        gpuCapability.drawBuffers(gl, buffers);
        this.updateAttachmentTextures();
    };
    GLFrameBuffer.prototype.resize = function (x, y, width, height) {
        var _a = __read$1(this.viewport, 4), preX = _a[0], preY = _a[1], preWidth = _a[2], preHeight = _a[3];
        if (preX !== x || preY !== y || preWidth !== width || preHeight !== height) {
            this.viewport = [x, y, width, height];
            this.ready = false;
            this.bind();
        }
    };
    GLFrameBuffer.prototype.dispose = function (opt) {
        var _a, _b;
        var renderer = this.renderer;
        if (renderer) {
            renderer.glRenderer.deleteGLFrameBuffer(this);
            delete this.fbo;
            var clearAttachment = (opt === null || opt === void 0 ? void 0 : opt.depthStencilAttachment) ? opt.depthStencilAttachment : exports.RenderPassDestroyAttachmentType.force;
            if (clearAttachment === exports.RenderPassDestroyAttachmentType.force || (clearAttachment === exports.RenderPassDestroyAttachmentType.keepExternal && !this.externalStorage)) {
                (_a = this.depthStencilRenderBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
                (_b = this.depthTexture) === null || _b === void 0 ? void 0 : _b.dispose();
            }
            // @ts-expect-error safe to assign
            this.renderer = this.stencilRenderBuffer = this.depthStencilRenderBuffer = null;
        }
    };
    return GLFrameBuffer;
}(FrameBuffer));

function hash(str) {
  var hash = 5381,
      i    = str.length;

  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }

  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */
  return hash >>> 0;
}

var stringHash = hash;

var _a, _b;
var BlockUniformInfoOffset = 1;
var BlockUniformInfoByteLength = 8;
var BlockUniformInfoType = 0;
var BlockUniformInfoArrayStride = 4;
var BlockUniformInfoArraySize = 2;
var BlockUniformInfoRowStride = 5;
var fullRange = [0, 0];
var ItemPerValueMap = (_a = {},
    _a[glContext.FLOAT] = 1,
    _a[glContext.INT] = 1,
    _a[glContext.UNSIGNED_INT] = 1,
    _a[glContext.SHORT] = 1,
    _a[glContext.BOOL] = 1,
    _a[glContext.UNSIGNED_SHORT] = 1,
    _a[glContext.FLOAT_VEC2] = 2,
    _a[glContext.FLOAT_VEC3] = 3,
    _a[glContext.FLOAT_VEC4] = 4,
    _a[glContext.FLOAT_MAT2] = 4,
    _a[glContext.FLOAT_MAT3] = 9,
    _a[glContext.FLOAT_MAT4] = 16,
    _a[glContext.FLOAT_MAT2x3] = 6,
    _a[glContext.FLOAT_MAT2x4] = 8,
    _a[glContext.FLOAT_MAT4x3] = 12,
    _a[glContext.FLOAT_MAT4x2] = 8,
    _a[glContext.FLOAT_MAT3x4] = 12,
    _a[glContext.FLOAT_MAT3x2] = 6,
    _a[glContext.INT_VEC2] = 2,
    _a[glContext.INT_VEC3] = 3,
    _a[glContext.INT_VEC4] = 4,
    _a[glContext.UNSIGNED_INT_VEC2] = 2,
    _a[glContext.UNSIGNED_INT_VEC3] = 3,
    _a[glContext.UNSIGNED_INT_VEC4] = 4,
    _a[glContext.BOOL_VEC2] = 2,
    _a[glContext.BOOL_VEC3] = 3,
    _a[glContext.BOOL_VEC4] = 4,
    _a);
var setFloat32Array = arraySetter(Float32Array);
var setInt32Array = arraySetter(Int32Array);
var setUInt8Array = arraySetter(Uint8Array);
var memorySetter = (_b = {},
    _b[glContext.FLOAT] = numberSetter(Float32Array),
    _b[glContext.INT] = numberSetter(Int32Array),
    _b[glContext.UNSIGNED_INT] = numberSetter(Uint32Array),
    _b[glContext.SHORT] = numberSetter(Int16Array),
    _b[glContext.BOOL] = numberSetter(Uint8Array),
    _b[glContext.UNSIGNED_SHORT] = numberSetter(Uint16Array),
    _b[glContext.FLOAT_VEC2] = setFloat32Array,
    _b[glContext.FLOAT_VEC3] = setFloat32Array,
    _b[glContext.FLOAT_VEC4] = setFloat32Array,
    _b[glContext.FLOAT_MAT2] = setFloat32Array,
    _b[glContext.FLOAT_MAT3] = setFloat32Array,
    _b[glContext.FLOAT_MAT4] = setFloat32Array,
    _b[glContext.FLOAT_MAT2x3] = setFloat32Array,
    _b[glContext.FLOAT_MAT2x4] = setFloat32Array,
    _b[glContext.FLOAT_MAT4x3] = setFloat32Array,
    _b[glContext.FLOAT_MAT4x2] = setFloat32Array,
    _b[glContext.FLOAT_MAT3x4] = setFloat32Array,
    _b[glContext.FLOAT_MAT3x2] = setFloat32Array,
    _b[glContext.INT_VEC2] = setInt32Array,
    _b[glContext.INT_VEC3] = setInt32Array,
    _b[glContext.INT_VEC4] = setInt32Array,
    _b[glContext.UNSIGNED_INT_VEC2] = setInt32Array,
    _b[glContext.UNSIGNED_INT_VEC3] = setInt32Array,
    _b[glContext.UNSIGNED_INT_VEC4] = setInt32Array,
    _b[glContext.BOOL_VEC2] = setUInt8Array,
    _b[glContext.BOOL_VEC3] = setUInt8Array,
    _b[glContext.BOOL_VEC4] = setUInt8Array,
    _b);
var UniformBlockBuffer = /** @class */ (function () {
    function UniformBlockBuffer(pipelineContext, info) {
        this.info = info;
        this.buffer = new GLGPUBuffer(pipelineContext, {
            target: glContext.UNIFORM_BUFFER,
            name: info.name,
            type: glContext.BYTE,
            elementCount: info.size,
        });
        this.dirtyFlags = {};
    }
    UniformBlockBuffer.prototype.setValues = function (uniformValues, dirtyFlags, uniformValueOffsets) {
        var _this = this;
        Object.keys(uniformValues).forEach(function (name) {
            var value = uniformValues[name];
            var uniformInfo = _this.info.uniforms[name];
            if (uniformInfo && dirtyFlags[name]) {
                var range = uniformValueOffsets[name] || fullRange;
                var setter = memorySetter[uniformInfo[BlockUniformInfoType]];
                _this.dirtyFlags[name] = setter(value, uniformInfo, name, range);
            }
        });
    };
    UniformBlockBuffer.prototype.bind = function (gl, program, bufferBindIndex) {
        var _this = this;
        var buffer = this.buffer;
        if (buffer) {
            buffer.bind();
            Object.values(this.dirtyFlags).forEach(function (flag) {
                if (flag.dirty) {
                    // @ts-expect-error
                    buffer.bufferSubData(flag.start, new Uint8Array(flag.buffer.buffer));
                    if (!_this.keepData) {
                        delete flag.buffer;
                    }
                    flag.dirty = false;
                }
            });
            gl.uniformBlockBinding(program, bufferBindIndex, bufferBindIndex);
            gl.bindBufferRange(gl.UNIFORM_BUFFER, bufferBindIndex, buffer.glBuffer, 0, this.info.size);
        }
    };
    UniformBlockBuffer.prototype.dispose = function () {
        if (this.buffer) {
            this.buffer.dispose();
            this.buffer = undefined;
        }
    };
    return UniformBlockBuffer;
}());
function numberSetter(typedArray) {
    return function (value, info, name, range) {
        var flag = {
            start: info[BlockUniformInfoOffset],
            dirty: true,
        };
        var arrSize = info[BlockUniformInfoArraySize];
        if (arrSize > 1) {
            var values = value;
            if (values.length) {
                var eleCount = range[1] || values.length;
                var vecLen = info[BlockUniformInfoArrayStride] / typedArray.BYTES_PER_ELEMENT;
                var buffer = flag.buffer = new typedArray(eleCount * vecLen);
                var start = range[0] || 0;
                for (var i = 0; i < eleCount; i++) {
                    buffer[i * vecLen] = values[i + start];
                }
                flag.start += start * vecLen;
            }
        }
        else {
            flag.buffer = new typedArray([value]);
        }
        return flag;
    };
}
function arraySetter(type) {
    return function (value, info, name, range) {
        var blockByteLen = info[BlockUniformInfoByteLength];
        var arrSize = info[BlockUniformInfoArraySize];
        var rowStride = info[BlockUniformInfoRowStride];
        var entryStride = arrSize === 1 ? blockByteLen : info[BlockUniformInfoArrayStride];
        var entryRowCount = rowStride ? entryStride / rowStride : 1;
        var rowNumPadding = entryStride / type.BYTES_PER_ELEMENT / entryRowCount;
        var maxRowCount = blockByteLen / type.BYTES_PER_ELEMENT / rowNumPadding;
        //set array
        var numPerEntry = ItemPerValueMap[info[BlockUniformInfoType]];
        var numPerRow = numPerEntry / entryRowCount;
        var valueStartIndex = (range[0] || 0) * numPerEntry;
        var totalRow = range[1] ? entryRowCount * range[1] : maxRowCount;
        var buffer = new type(rowNumPadding * totalRow);
        var flag = {
            start: info[BlockUniformInfoOffset] + entryStride * (range[0] || 0),
            dirty: true,
            buffer: buffer,
        };
        for (var i = 0, bufferTarget = 0, sourceIndex = valueStartIndex; i < totalRow; i++) {
            for (var j = 0; j < numPerRow; j++) {
                buffer[bufferTarget + j] = value[sourceIndex + j];
            }
            bufferTarget += rowNumPadding;
            sourceIndex += numPerRow;
        }
        return flag;
    };
}
// TODO: 函数名重定义
function createUniformBlockDataFromProgram(gl, program) {
    var blockSpecs = [];
    var blockUniformNames = [];
    var uniformBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
    var _loop_1 = function (idx) {
        var name_1 = gl.getActiveUniformBlockName(program, idx);
        var blockSpec = {
            index: gl.getUniformBlockIndex(program, name_1),
            usedByVertexShader: gl.getActiveUniformBlockParameter(program, idx, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),
            usedByFragmentShader: gl.getActiveUniformBlockParameter(program, idx, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),
            size: gl.getActiveUniformBlockParameter(program, idx, gl.UNIFORM_BLOCK_DATA_SIZE),
            uniformIndices: gl.getActiveUniformBlockParameter(program, idx, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),
            used: false,
            uniforms: {},
            name: name_1,
            id: '',
        };
        blockSpec.used = blockSpec.usedByVertexShader || blockSpec.usedByFragmentShader;
        blockSpecs[idx] = blockSpec;
        var indices = blockSpec.uniformIndices;
        var uniformNames = [];
        for (var i = 0; i < indices.length; i++) {
            var name_2 = gl.getActiveUniform(program, indices[i]).name.replace('[0]', '');
            blockSpec.uniforms[name_2] = [0, 0, 0, 0, 0, 0, 0, i, 0];
            uniformNames[i] = name_2;
            blockUniformNames.push(name_2);
        }
        [
            gl.UNIFORM_TYPE,
            gl.UNIFORM_OFFSET,
            gl.UNIFORM_SIZE,
            gl.UNIFORM_BLOCK_INDEX,
            gl.UNIFORM_ARRAY_STRIDE,
            gl.UNIFORM_MATRIX_STRIDE,
            gl.UNIFORM_IS_ROW_MAJOR,
        ].forEach(function (param, pi) {
            gl.getActiveUniforms(program, indices, param)
                .forEach(function (value, idx) {
                var name = uniformNames[idx];
                blockSpec.uniforms[name][pi] = +value;
            });
        });
        for (var i = 0; i < uniformNames.length; i++) {
            var uniform = blockSpec.uniforms[uniformNames[i]];
            var nextUniform = blockSpec.uniforms[uniformNames[i + 1]];
            var size = nextUniform ? nextUniform[1] : blockSpec.size;
            uniform[8] = size - uniform[1];
        }
        blockSpec.id = getUboHash(blockSpec) + '';
    };
    for (var idx = 0; idx < uniformBlocks; ++idx) {
        _loop_1(idx);
    }
    return { blockSpecs: blockSpecs, blockUniformNames: blockUniformNames };
}
function getUboHash(spec) {
    var name = spec.name, size = spec.size, uniforms = spec.uniforms, uniformIndices = spec.uniformIndices;
    Object.keys(uniforms)
        .map(function (name) { return "".concat(name, "[").concat(uniforms[name].join(':'), "]"); })
        .join('+');
    return stringHash("".concat(name, "+"), "".concat(size, "+"), "".concat(uniformIndices.length, "+"));
}

var GLProgram = /** @class */ (function () {
    function GLProgram(pipelineContext, program, shared, id) {
        var _this = this;
        this.pipelineContext = pipelineContext;
        this.program = program;
        this.shared = shared;
        this.id = id;
        this.uniformBlockMap = {};
        this.pipelineContext = pipelineContext;
        var gl = pipelineContext.gl;
        pipelineContext.useProgram(program);
        this.attribInfoMap = this.createAttribMap();
        if (isWebGL2(gl)) {
            var _a = createUniformBlockDataFromProgram(gl, program), blockSpecs = _a.blockSpecs; _a.blockUniformNames;
            blockSpecs.forEach(function (b) { return _this.uniformBlockMap[b.name] = b; });
        }
        pipelineContext.useProgram(null);
        //gl.activeTexture(gl.TEXTURE0);
        //pipelineContext.activeTexture(gl.TEXTURE0);
        //emptyTexture2D.bind();
        //this.uniformInfoMap = uniformMap;
    }
    GLProgram.prototype.bind = function () {
        var gl = this.pipelineContext.gl;
        gl.useProgram(this.program);
    };
    /**
     * 绑定 vao 对象并设置顶点属性
     * 如果当前环境不支持 vao，则使用 gl 函数依次设置属性。
     * @param geometry
     * @returns
     */
    GLProgram.prototype.setupAttributes = function (geometry) {
        var _this = this;
        var _a;
        var gl = this.pipelineContext.gl;
        var programId = this.id;
        var vao;
        if (geometry.vaos[programId]) {
            vao = geometry.vaos[programId];
        }
        else {
            vao = new GLVertexArrayObject(this.pipelineContext.gl, "".concat(geometry.name, "-").concat(programId));
            if (!vao) {
                console.warn('创建vao对象失败。');
            }
            geometry.vaos[programId] = vao;
        }
        if (vao) {
            vao.bind();
            if (vao.ready) {
                return vao;
            }
        }
        Object.keys(this.attribInfoMap).forEach(function (name) {
            var attrInfo = _this.attribInfoMap[name];
            var attribute = geometry.attributes[name];
            if (attribute) {
                var buffer = geometry.buffers[attribute.dataSource];
                if (!buffer) {
                    throw Error("no buffer named ".concat(attribute.dataSource || name));
                }
                buffer.bind();
                gl.enableVertexAttribArray(attrInfo.loc);
                gl.vertexAttribPointer(attrInfo.loc, attribute.size, attribute.type, attribute.normalize, attribute.stride || 0, attribute.offset || 0);
            }
        });
        (_a = geometry.indicesBuffer) === null || _a === void 0 ? void 0 : _a.bind();
        if (vao) {
            vao.ready = true;
        }
        return vao;
    };
    GLProgram.prototype.createAttribMap = function () {
        var gl = this.pipelineContext.gl;
        var program = this.program;
        var attribMap = {};
        var num = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < num; i++) {
            var _a = gl.getActiveAttrib(program, i), name_1 = _a.name, type = _a.type, size = _a.size;
            var loc = gl.getAttribLocation(program, name_1);
            attribMap[name_1] = {
                type: type,
                name: name_1,
                size: size,
                loc: loc,
            };
        }
        return attribMap;
    };
    GLProgram.prototype.dispose = function () {
        if (this.pipelineContext) {
            this.pipelineContext.gl.deleteProgram(this.program);
            // @ts-expect-error safe to assign
            this.pipelineContext = null;
        }
    };
    return GLProgram;
}());

var GLShader = /** @class */ (function (_super) {
    __extends(GLShader, _super);
    function GLShader(source) {
        var _this = _super.call(this, source) || this;
        _this.initialized = false;
        _this.uniformLocations = {};
        _this.samplerChannels = {};
        return _this;
    }
    // shader 的 GPU 资源初始化方法，在绘制前调用
    GLShader.prototype.initialize = function (engine) {
        if (this.initialized) {
            return;
        }
        // 核心初始化都在 compileShader
        // 否则会出现编译了却没有初始化的情况
        var pipelineContext = engine.getGLPipelineContext();
        pipelineContext.shaderLibrary.compileShader(this);
    };
    GLShader.prototype.setFloat = function (name, value) {
        this.pipelineContext.setFloat(this.uniformLocations[name], value);
    };
    GLShader.prototype.setInt = function (name, value) {
        this.pipelineContext.setInt(this.uniformLocations[name], value);
    };
    GLShader.prototype.setFloats = function (name, value) {
        this.pipelineContext.setFloats(this.uniformLocations[name], value);
    };
    GLShader.prototype.setTexture = function (name, texture) {
        this.pipelineContext.setTexture(this.uniformLocations[name], this.samplerChannels[name], texture);
    };
    GLShader.prototype.setVector2 = function (name, value) {
        this.pipelineContext.setVector2(this.uniformLocations[name], value);
    };
    GLShader.prototype.setVector3 = function (name, value) {
        this.pipelineContext.setVector3(this.uniformLocations[name], value);
    };
    GLShader.prototype.setVector4 = function (name, value) {
        this.pipelineContext.setVector4(this.uniformLocations[name], value);
    };
    GLShader.prototype.setMatrix = function (name, value) {
        this.pipelineContext.setMatrix(this.uniformLocations[name], value);
    };
    GLShader.prototype.setMatrix3 = function (name, value) {
        this.pipelineContext.setMatrix3(this.uniformLocations[name], value);
    };
    GLShader.prototype.setVector4Array = function (name, array) {
        this.pipelineContext.setVector4Array(this.uniformLocations[name], array);
    };
    GLShader.prototype.setMatrixArray = function (name, array) {
        this.pipelineContext.setMatrixArray(this.uniformLocations[name], array);
    };
    GLShader.prototype.fillShaderInformation = function (uniformNames, samplers) {
        // 避免修改原数组。
        var samplerList = samplers.slice();
        uniformNames = uniformNames.concat(samplerList);
        var avaliableUniforms = this.pipelineContext.getUniforms(this.program.program, uniformNames);
        for (var i = 0; i < uniformNames.length; i++) {
            this.uniformLocations[uniformNames[i]] = avaliableUniforms[i];
        }
        var index;
        for (index = 0; index < samplerList.length; index++) {
            var sampler = this.uniformLocations[(samplerList[index])];
            if (sampler == null) {
                samplerList.splice(index, 1);
                index--;
            }
        }
        for (index = 0; index < samplerList.length; index++) {
            var samplerName = samplerList[index];
            this.samplerChannels[samplerName] = index;
        }
    };
    GLShader.prototype.dispose = function () {
        var _a;
        if (this.compileResult && this.compileResult.shared) {
            return;
        }
        (_a = this.program) === null || _a === void 0 ? void 0 : _a.dispose();
    };
    return GLShader;
}(Shader));

var shaderSeed = 0;
var GLShaderLibrary = /** @class */ (function () {
    function GLShaderLibrary(pipelineContext) {
        this.pipelineContext = pipelineContext;
        this.shaderResults = {};
        this.programMap = {};
        this.glVertShaderMap = new Map();
        this.glFragShaderMap = new Map();
        this.shaderAllDone = false;
        this.cachedShaders = {};
        this.glAsyncCompileExt = this.pipelineContext.gl.getExtension('KHR_parallel_shader_compile');
    }
    GLShaderLibrary.prototype.compileAllShaders = function (asyncCallback) {
        var e_1, _a;
        var _this = this;
        if (!this.shaderAllDone) {
            var pendings = [];
            try {
                for (var _b = __values$1(Object.keys(this.cachedShaders)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (!this.cachedShaders[key].initialized) {
                        pendings.push(key);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (asyncCallback) {
                if (pendings.length) {
                    Promise.all(pendings.map(function (key) { return new Promise(function (resolve) { return _this.compileShader(_this.cachedShaders[key], resolve); }); }))
                        .then(asyncCallback)
                        .catch(function () { return 0; });
                }
                else {
                    asyncCallback([]);
                }
            }
            else {
                pendings.map(function (key) { return _this.compileShader(_this.cachedShaders[key]); });
            }
            this.shaderAllDone = true;
        }
        else if (asyncCallback) {
            asyncCallback([]);
        }
    };
    // TODO 创建shader的ShaderWithSource和shader的source类型一样，待优化。
    GLShaderLibrary.prototype.addShader = function (shaderSource) {
        var shaderCacheId = this.computeShaderCacheId(shaderSource);
        if (this.cachedShaders[shaderCacheId]) {
            return shaderCacheId;
        }
        this.shaderAllDone = false;
        var header = shaderSource.glslVersion === exports.GLSLVersion.GLSL3 ? '#version 300 es\n' : '';
        var vertex = shaderSource.vertex ? header + shaderSource.vertex : '';
        var fragment = shaderSource.fragment ? header + shaderSource.fragment : '';
        var shared = false;
        if (shaderSource.shared || shaderSource.cacheId) {
            shared = true;
        }
        this.cachedShaders[shaderCacheId] = new GLShader({
            vertex: vertex,
            fragment: fragment,
            name: shaderSource.name || shaderCacheId,
            shared: shared,
        });
        this.cachedShaders[shaderCacheId].id = shaderCacheId;
        return shaderCacheId;
    };
    GLShaderLibrary.prototype.createShader = function (shaderSource) {
        var shaderCacheId = this.addShader(shaderSource);
        return this.cachedShaders[shaderCacheId];
    };
    GLShaderLibrary.prototype.compileShader = function (shader, asyncCallback) {
        var _this = this;
        var shaderSource = shader.source;
        var shared = false;
        if (shaderSource.shared || shaderSource.cacheId) {
            shared = true;
        }
        var shaderData = {
            vertex: shaderSource.vertex,
            fragment: shaderSource.fragment,
            name: shaderSource.name,
            shared: shared,
        };
        var gl = this.pipelineContext.gl;
        var result = { shared: shaderData.shared, status: exports.ShaderCompileResultStatus.compiling };
        var linkProgram = this.createProgram(gl, shaderData.vertex, shaderData.fragment, result);
        var ext = this.glAsyncCompileExt;
        var startTime = performance.now();
        var setupProgram = function (glProgram) {
            result.status = exports.ShaderCompileResultStatus.success;
            result.compileTime = performance.now() - startTime;
            shader.program = glProgram;
            shader.initialized = true;
            shader.pipelineContext = _this.pipelineContext;
            if (_this.programMap[shader.id] !== undefined) {
                console.warn('find duplicated shader id', shader.id);
            }
            _this.programMap[shader.id] = glProgram;
        };
        var checkComplete = function () {
            var shouldLink = !asyncCallback || !ext || (ext && gl.getProgramParameter(result.program, ext.COMPLETION_STATUS_KHR) == true);
            var program = shouldLink && linkProgram();
            if (program) {
                if (result.status !== exports.ShaderCompileResultStatus.fail) {
                    assignInspectorName(program, shaderData.name);
                    var glProgram = new GLProgram(_this.pipelineContext, program, shared, shader.id);
                    gl.validateProgram(program);
                    var valid = gl.getProgramParameter(program, gl.VALIDATE_STATUS);
                    if (!valid) {
                        var error = gl.getProgramInfoLog(program);
                        var err0 = 'Samplers of conflicting types refer to the same texture image unit (0)';
                        var err1 = 'Samplers of different types use the same texture image unit.';
                        if ((error === null || error === void 0 ? void 0 : error.includes(err0)) || (error === null || error === void 0 ? void 0 : error.includes(err1))) {
                            // 忽略这类错误
                            setupProgram(glProgram);
                        }
                        else {
                            result.status = exports.ShaderCompileResultStatus.fail;
                            result.error = error;
                            console.error('compileProgramError: ' + error, '\nvertex:\n', shaderData.vertex, '\nfragment:\n', shaderData.fragment);
                            gl.deleteProgram(program);
                        }
                    }
                    else {
                        setupProgram(glProgram);
                    }
                }
                if (asyncCallback) {
                    asyncCallback(result);
                }
            }
            else if (asyncCallback) {
                requestAnimationFrame(checkComplete);
            }
        };
        shader.compileResult = result;
        checkComplete();
    };
    GLShaderLibrary.prototype.computeShaderCacheId = function (shader) {
        var vertex = shader.vertex ? shader.vertex : '';
        var fragment = shader.fragment ? shader.fragment : '';
        var shaderCacheId;
        if (shader.shared || shader.cacheId) {
            // FIXME: string-hash有冲突，这里先用strHashCode替代
            shaderCacheId = shader.cacheId || "shared_".concat(strHashCode(vertex, fragment));
        }
        else {
            shaderCacheId = 'instanced_' + shaderSeed++;
        }
        return shaderCacheId;
    };
    GLShaderLibrary.prototype.createProgram = function (gl, vs, fs, result) {
        var program = gl.createProgram();
        var vertexShader = this.createGLShader(gl, gl.VERTEX_SHADER, vs);
        var fragShader = this.createGLShader(gl, gl.FRAGMENT_SHADER, fs);
        if (program && vertexShader && fragShader) {
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);
            result.program = program;
            result.status = exports.ShaderCompileResultStatus.compiling;
            return function () {
                delete result.program;
                var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
                if (!linked) {
                    var vsCheckResult = checkShader(gl, vertexShader, 'vertex', vs);
                    var fsCheckResult = checkShader(gl, fragShader, 'fragment', fs);
                    result.status = exports.ShaderCompileResultStatus.fail;
                    if (vsCheckResult) {
                        result.error = vsCheckResult.error;
                        result.status = vsCheckResult.status;
                    }
                    if (fsCheckResult) {
                        result.error = fsCheckResult.error;
                        result.status = fsCheckResult.status;
                    }
                    return program;
                }
                return program;
            };
        }
        result.status = exports.ShaderCompileResultStatus.fail;
        return function () { return null; };
    };
    GLShaderLibrary.prototype.createGLShader = function (gl, shaderType, code) {
        var map = shaderType === gl.VERTEX_SHADER ? this.glVertShaderMap : this.glFragShaderMap;
        var strHash = stringHash(code !== null && code !== void 0 ? code : '');
        var ret = map.get(strHash);
        if (ret) {
            return ret;
        }
        var shader = gl.createShader(shaderType);
        if (shader) {
            gl.shaderSource(shader, code);
            gl.compileShader(shader);
            map.set(strHash, shader);
        }
        return shader;
    };
    GLShaderLibrary.prototype.deleteShader = function (cacheId) {
        var program = this.programMap[cacheId];
        if (program !== undefined) {
            program.dispose();
            delete this.programMap[cacheId];
        }
        var result = this.shaderResults[cacheId];
        if (result !== undefined) {
            delete this.shaderResults[cacheId];
        }
    };
    GLShaderLibrary.prototype.restore = function () {
        // TODO
    };
    GLShaderLibrary.prototype.dispose = function () {
        Object.values(this.programMap).forEach(function (program) {
            program.dispose();
        });
        this.programMap = {};
        if (this.pipelineContext) {
            var gl_1 = this.pipelineContext.gl;
            this.glFragShaderMap.forEach(function (shader) {
                gl_1.deleteShader(shader);
            });
            this.glVertShaderMap.forEach(function (shader) {
                gl_1.deleteShader(shader);
            });
            this.glVertShaderMap = new Map();
            this.glFragShaderMap = new Map();
        }
    };
    return GLShaderLibrary;
}());
function checkShader(gl, shader, type, code) {
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var error = gl.getShaderInfoLog(shader);
        console.error('compile ' + (type) + ' error: ' + error, (code !== null && code !== void 0 ? code : '')
            .split('\n')
            .map(function (line, index) { return "".concat(index + 1, " ").concat(line); })
            .join('\n'));
        return { error: error, status: exports.ShaderCompileResultStatus.fail };
    }
}
function strHashCode() {
    var strings = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        strings[_i] = arguments[_i];
    }
    var h = 0;
    for (var j = 0; j < arguments.length; j++) {
        var s = strings[j];
        for (var i = 0; i < s.length; i++) {
            h = Math.imul(31, h) + s.charCodeAt(i) | 0;
        }
    }
    return h;
}

var GLPipelineContext = /** @class */ (function () {
    function GLPipelineContext(gl) {
        this.gl = gl;
        this.shaderLibrary = new GLShaderLibrary(this);
        this.maxTextureCount = gl.TEXTURE0 + gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS) - 1;
        this.reset();
    }
    GLPipelineContext.prototype.dispose = function () {
        this.shaderLibrary.dispose();
        this.reset();
    };
    GLPipelineContext.prototype.reset = function () {
        this.glCapabilityCache = {};
        this.activeTextureIndex = glContext.TEXTURE0;
        this.textureUnitDict = {};
        this.currentFramebuffer = {};
        this.pixelStorei = {};
        this.currentRenderBuffer = {};
    };
    GLPipelineContext.prototype.toggle = function (capability, enable) {
        if (enable) {
            this.enable(capability);
        }
        else {
            this.disable(capability);
        }
    };
    /**
     * 对于该上下文开启某种特性
     * @param capability
     * example:
     * gl.enable(gl.DITHER);
     */
    GLPipelineContext.prototype.enable = function (capability) {
        var value = this.glCapabilityCache[capability];
        if (value !== true) {
            this.glCapabilityCache[capability] = true;
            this.gl.enable(capability);
        }
    };
    /**
     * 基于某种上下文关闭特性
     * @param capability
     * example:
     * gl.disable(gl.DITHER);
     */
    GLPipelineContext.prototype.disable = function (capability) {
        var value = this.glCapabilityCache[capability];
        if (value !== false) {
            this.glCapabilityCache[capability] = false;
            this.gl.disable(capability);
        }
    };
    /**
     * 绑定framebuffer webgl2新增: gl.DRAW_FRAMEBUFFER 和 gl.READ_FRAMEBUFFER
     * @param target
     * @param framebuffer
     * example:
     * const framebuffer = gl.createFramebuffer();
     * gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
     */
    GLPipelineContext.prototype.bindFramebuffer = function (target, framebuffer) {
        if (this.currentFramebuffer[target] !== framebuffer) {
            this.currentFramebuffer[target] = framebuffer;
            this.gl.bindFramebuffer(target, framebuffer);
        }
    };
    GLPipelineContext.prototype.bindRenderBuffer = function (target, renderBuffer) {
        if (this.currentRenderBuffer[target] !== renderBuffer) {
            this.currentRenderBuffer[target] = renderBuffer;
            this.gl.bindRenderbuffer(target, renderBuffer);
        }
    };
    /**
     * 绑定系统 framebuffer
     */
    GLPipelineContext.prototype.bindSystemFramebuffer = function () {
        this.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    };
    /**
     * 将定义好的 WebGLProgram 对象添加到当前的渲染状态中。
     * @param program
     * example:
     * gl.useProgram(program);
     * gl.useProgram(null);
     */
    GLPipelineContext.prototype.useProgram = function (program) {
        this.set1('useProgram', program);
    };
    /**
     * 使用预设值来清空缓冲
     * @param mask
     * example:
     * gl.clear(gl.DEPTH_BUFFER_BIT);
     * gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
     */
    GLPipelineContext.prototype.clear = function (mask) {
        this.gl.clear(mask);
    };
    /*** depth start ***/
    /**
     * 设置深度缓冲区的深度清除值
     * @param depth
     * example:
     * gl.clearDepth(0.5);
     */
    GLPipelineContext.prototype.clearDepth = function (depth) {
        this.set1('clearDepth', depth);
    };
    /**
     * 指定将输入像素深度与当前深度缓冲区值进行比较的函数。
     * @param func
     * example:
     * gl.enable(gl.DEPTH_TEST);
     * gl.depthFunc(gl.NEVER);
     */
    GLPipelineContext.prototype.depthFunc = function (func) {
        this.set1('depthFunc', func);
    };
    /**
     * 设置是否启用写入深度缓冲。
     * @param flag
     * example:
     * gl.depthMask(false);
     */
    GLPipelineContext.prototype.depthMask = function (flag) {
        this.set1('depthMask', flag);
    };
    GLPipelineContext.prototype.polygonOffset = function (factor, unit) {
        this.set2('polygonOffset', factor, unit);
    };
    /**
     * 将 z 值从规范化设备坐标映射到窗口坐标
     * @param zNear
     * @param zFar
     * example:
     * gl.depthRange(0.2, 0.6);
     */
    GLPipelineContext.prototype.depthRange = function (zNear, zFar) {
        this.set2('depthRange', zNear, zFar);
    };
    /*** depth end ***/
    /*** stencil start ***/
    /**
     * 模版测试设置函数和引用值。
     * @param func
     * @param ref
     * @param mask
     * example:
     * gl.enable(gl.STENCIL_TEST);
     * gl.stencilFunc(gl.LESS, 0, 0b1110011);
     */
    GLPipelineContext.prototype.clearStencil = function (s) {
        this.set1('clearStencil', s);
    };
    /**
     * 控制启用和禁用模板平面中单个位的正面和背面写入
     * @param mask
     * example:
     * gl.stencilMask(0xff);
     */
    GLPipelineContext.prototype.stencilMask = function (mask) {
        this.stencilMaskSeparate(this.gl.FRONT, mask);
        this.stencilMaskSeparate(this.gl.BACK, mask);
    };
    /**
     * 模版测试设置函数和引用值。
     * @param func
     * @param ref
     * @param mask
     * example:
     * gl.enable(gl.STENCIL_TEST);
     * gl.stencilFunc(gl.LESS, 0, 0b1110011);
     */
    GLPipelineContext.prototype.stencilFunc = function (func, ref, mask) {
        this.stencilFuncSeparate(this.gl.FRONT, func, ref, mask);
        this.stencilFuncSeparate(this.gl.BACK, func, ref, mask);
    };
    /**
     * 单面模版测试
     * @param face
     * @param func
     * @param ref
     * @param mask
     * example:
     * gl.enable(gl.STENCIL_TEST);
     * gl.stencilFuncSeparate(gl.FRONT, gl.LESS, 0.2, 1110011);
     */
    GLPipelineContext.prototype.stencilFuncSeparate = function (face, func, ref, mask) {
        this.set4('stencilFuncSeparate', face, func, ref, mask);
    };
    /**
     * 单面的mask写入
     * @param face
     * @param mask
     * example:
     * gl.stencilMaskSeparate(gl.FRONT, 110101);
     */
    GLPipelineContext.prototype.stencilMaskSeparate = function (face, mask) {
        this.set2('stencilMaskSeparate', face, mask);
    };
    /**
     * 设置正面和背面模板测试操作
     * @param fail
     * @param zfail
     * @param zpass
     * example:
     * gl.enable(gl.STENCIL_TEST);
     * gl.stencilOp(gl.INCR, gl.DECR, gl.INVERT);
     */
    GLPipelineContext.prototype.stencilOp = function (fail, zfail, zpass) {
        this.stencilOpSeparate(this.gl.FRONT, fail, zfail, zpass);
        this.stencilOpSeparate(this.gl.BACK, fail, zfail, zpass);
    };
    /**
     * 设置正面和/或背面模板测试操作
     * @param face
     * @param fail
     * @param zfail
     * @param zpass
     * example:
     * gl.enable(gl.STENCIL_TEST);
     * gl.stencilOpSeparate(gl.FRONT, gl.INCR, gl.DECR, gl.INVERT);
     */
    GLPipelineContext.prototype.stencilOpSeparate = function (face, fail, zfail, zpass) {
        this.set4('stencilOpSeparate', face, fail, zfail, zpass);
    };
    /*** stencil end ***/
    /*** face start ***/
    /**
     * 剔除方式
     * @param mode
     * example:
     * gl.enable(gl.CULL_FACE);
     * gl.cullFace(gl.FRONT_AND_BACK);
     */
    GLPipelineContext.prototype.cullFace = function (mode) {
        this.set1('cullFace', mode);
    };
    /**
     * 设置卷绕方向
     * @param mode
     * example:
     * gl.frontFace(gl.CW);
     */
    GLPipelineContext.prototype.frontFace = function (mode) {
        this.set1('frontFace', mode);
    };
    /*** face end ***/
    /*** color start ***/
    /**
     * 设置颜色写入
     * @param red
     * @param green
     * @param blue
     * @param alpha
     * example:
     * gl.colorMask(true, true, true, false);
     */
    GLPipelineContext.prototype.clearColor = function (red, green, blue, alpha) {
        this.set4('clearColor', red, green, blue, alpha);
    };
    /**
     * 设置颜色写入
     * @param red
     * @param green
     * @param blue
     * @param alpha
     * example:
     * gl.colorMask(true, true, true, false);
     */
    GLPipelineContext.prototype.colorMask = function (red, green, blue, alpha) {
        this.set4('colorMask', red, green, blue, alpha);
    };
    /**
     * 设置源和目标混合因子
     * @param red
     * @param green
     * @param blue
     * @param alpha
     * example:
     * gl.blendColor(0, 0.5, 1, 1);
     */
    GLPipelineContext.prototype.blendColor = function (red, green, blue, alpha) {
        this.set4('blendColor', red, green, blue, alpha);
    };
    /**
     * 用于混合像素算法
     * @param sfactor
     * @param dfactor
     * example:
     * gl.enable(gl.BLEND);
     * gl.blendFunc(gl.SRC_COLOR, gl.DST_COLOR);
     */
    GLPipelineContext.prototype.blendFunc = function (sfactor, dfactor) {
        this.blendFuncSeparate(sfactor, dfactor, sfactor, dfactor);
    };
    /**
     * 分别设置应用在 RGB 和 Alpha 上的 factor
     * @param srcRGB
     * @param dstRGB
     * @param srcAlpha
     * @param dstAlpha
     * example:
     * gl.enable(gl.BLEND);
     * gl.blendFuncSeparate(gl.SRC_COLOR, gl.DST_COLOR, gl.ONE, gl.ZERO);
     */
    GLPipelineContext.prototype.blendFuncSeparate = function (srcRGB, dstRGB, srcAlpha, dstAlpha) {
        this.set4('blendFuncSeparate', srcRGB, dstRGB, srcAlpha, dstAlpha);
    };
    /**
     * 设置混合模式
     * @param mode
     * example:
     * gl.blendEquation(gl.FUNC_ADD);
     * gl.blendEquation(gl.FUNC_SUBTRACT);
     * gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT);
     */
    GLPipelineContext.prototype.blendEquation = function (mode) {
        this.set1('blendEquation', mode);
    };
    /**
     * 可以分别对 RGB 和 Alpha 做不同的操作处理
     * @param modeRGB
     * @param modeAlpha
     * example:
     * gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_SUBTRACT);
     */
    GLPipelineContext.prototype.blendEquationSeparate = function (modeRGB, modeAlpha) {
        this.set2('blendEquationSeparate', modeRGB, modeAlpha);
    };
    /*** color end ***/
    /**
     * 图像预处理
     * @param pname
     * @param param
     * example:
     * var tex = gl.createTexture();
     * gl.bindTexture(gl.TEXTURE_2D, tex);
     * gl.pixelStorei(gl.PACK_ALIGNMENT, 4);
     */
    GLPipelineContext.prototype.setPixelStorei = function (pname, param) {
        var currentParam = this.pixelStorei[pname];
        if (currentParam !== param) {
            this.pixelStorei[pname] = param;
            this.gl.pixelStorei(pname, param);
        }
    };
    /**
     * 用来设置视口，即指定从标准设备到窗口坐标的x、y仿射变换。
     * @param x
     * @param y
     * @param width
     * @param height
     * example:
     * gl.viewport(0, 0, width, height);
     */
    GLPipelineContext.prototype.viewport = function (x, y, width, height) {
        this.set4('viewport', x, y, width, height);
    };
    /**
     * 激活指定的纹理单元
     * @param texture
     * example:
     * gl.activeTexture(gl.TEXTURE1);
     */
    GLPipelineContext.prototype.activeTexture = function (texture) {
        texture = Math.min(texture, this.maxTextureCount);
        if (this.activeTextureIndex !== texture) {
            this.activeTextureIndex = texture;
            this.gl.activeTexture(texture);
        }
    };
    /**
     * 绑定WebGLTexture
     * @param target
     * @param texture
     * @param force
     * example:
     * const texture = gl.createTexture();
     * gl.bindTexture(gl.TEXTURE_2D, texture)
     */
    // TODO: texture.bind 替换时对于这段逻辑的处理
    GLPipelineContext.prototype.bindTexture = function (target, texture, force) {
        if (this.currentTextureBinding !== texture || force) {
            this.gl.bindTexture(target, texture);
            this.currentTextureBinding = texture;
        }
        this.textureUnitDict[this.activeTextureIndex] = texture;
    };
    GLPipelineContext.prototype.set1 = function (name, param) {
        var value = this.glCapabilityCache[name];
        if (value !== param) {
            this.glCapabilityCache[name] = param;
            // @ts-expect-error save to assign
            this.gl[name](param);
        }
    };
    GLPipelineContext.prototype.set2 = function (name, param0, param1) {
        var value = this.glCapabilityCache[name];
        if (!value) {
            value = this.glCapabilityCache[name] = { x: NaN, y: NaN };
        }
        if (value.x !== param0 || value.y !== param1) {
            // @ts-expect-error save to assign
            this.gl[name](value.x = param0, value.y = param1);
        }
    };
    GLPipelineContext.prototype.set3 = function (name, param0, param1, param2) {
        var value = this.glCapabilityCache[name];
        if (!value) {
            value = this.glCapabilityCache[name] = { x: NaN, y: NaN, z: NaN };
        }
        if (value.x !== param0 || value.y !== param1 || value.z !== param2) {
            // @ts-expect-error safe to assign
            this.gl[name](value.x = param0, value.y = param1, value.z = param2);
        }
    };
    GLPipelineContext.prototype.set4 = function (name, param0, param1, param2, param3) {
        var value = this.glCapabilityCache[name];
        if (!value) {
            value = this.glCapabilityCache[name] = {
                x: NaN, y: NaN, z: NaN, w: NaN,
            };
        }
        if (value.x !== param0 || value.y !== param1 || value.z !== param2 || value.w !== param3) {
            // @ts-expect-error safe to assign
            this.gl[name](value.x = param0, value.y = param1, value.z = param2, value.w = param3);
        }
    };
    // TODO 命名
    GLPipelineContext.prototype.get = function (name) {
        return this.glCapabilityCache[name];
    };
    GLPipelineContext.prototype.setFloat = function (uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniform1f(uniform, value);
    };
    GLPipelineContext.prototype.setInt = function (uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniform1i(uniform, value);
    };
    GLPipelineContext.prototype.setFloats = function (uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniform1fv(uniform, value);
    };
    GLPipelineContext.prototype.setVector2 = function (uniform, value) {
        this.setFloat2(uniform, value[0], value[1]);
    };
    GLPipelineContext.prototype.setVector3 = function (uniform, value) {
        this.setFloat3(uniform, value[0], value[1], value[2]);
    };
    GLPipelineContext.prototype.setVector4 = function (uniform, value) {
        this.setFloat4(uniform, value[0], value[1], value[2], value[3]);
    };
    GLPipelineContext.prototype.setVector4Array = function (uniform, array) {
        if (!uniform || array.length % 4 !== 0) {
            return;
        }
        this.gl.uniform4fv(uniform, array);
    };
    GLPipelineContext.prototype.setMatrix = function (uniform, value) {
        if (!uniform || value.length != 16) {
            return;
        }
        this.gl.uniformMatrix4fv(uniform, false, value);
    };
    GLPipelineContext.prototype.setMatrix3 = function (uniform, value) {
        if (!uniform || value.length != 9) {
            return;
        }
        this.gl.uniformMatrix3fv(uniform, false, value);
    };
    GLPipelineContext.prototype.setMatrixArray = function (uniform, array) {
        if (!uniform || array.length % 16 !== 0) {
            return;
        }
        this.gl.uniformMatrix4fv(uniform, false, array);
    };
    GLPipelineContext.prototype.setTexture = function (uniform, channel, texture) {
        if (!uniform) {
            return;
        }
        this.gl.activeTexture(this.gl.TEXTURE0 + channel);
        var target = texture.target;
        this.gl.bindTexture(target, texture.textureBuffer);
        this.gl.uniform1i(uniform, channel);
    };
    /**
     * 查询所有uniform的location。
     * @param program 查询的shader program
     * @param uniformsNames 查询的uniform名称列表
     * @returns
     */
    GLPipelineContext.prototype.getUniforms = function (program, uniformsNames) {
        var results = [];
        for (var index = 0; index < uniformsNames.length; index++) {
            results.push(this.gl.getUniformLocation(program, uniformsNames[index]));
        }
        return results;
    };
    GLPipelineContext.prototype.setFloat4 = function (uniform, x, y, z, w) {
        if (!uniform) {
            return;
        }
        this.gl.uniform4f(uniform, x, y, z, w);
    };
    GLPipelineContext.prototype.setFloat3 = function (uniform, x, y, z) {
        if (!uniform) {
            return;
        }
        this.gl.uniform3f(uniform, x, y, z);
    };
    GLPipelineContext.prototype.setFloat2 = function (uniform, x, y) {
        if (!uniform) {
            return;
        }
        this.gl.uniform2f(uniform, x, y);
    };
    return GLPipelineContext;
}());

var GLEngine = /** @class */ (function (_super) {
    __extends(GLEngine, _super);
    function GLEngine() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GLEngine.prototype.dispose = function () {
        if (this.isDestroyed) {
            return;
        }
        _super.prototype.dispose.call(this);
    };
    GLEngine.prototype.getGLRenderer = function () {
        return this.renderer;
    };
    GLEngine.prototype.getGLRendererInternal = function () {
        return this.getGLRenderer().glRenderer;
    };
    GLEngine.prototype.getGLPipelineContext = function () {
        return this.getGLRenderer().pipelineContext;
    };
    return GLEngine;
}(Engine));

var GLRenderer = /** @class */ (function (_super) {
    __extends(GLRenderer, _super);
    function GLRenderer(canvas, framework, renderOptions) {
        var _this = _super.call(this) || this;
        _this.canvas = canvas;
        var options = __assign$1({ preserveDrawingBuffer: undefined, alpha: true, stencil: true, antialias: true, depth: true, premultipliedAlpha: true }, renderOptions);
        _this.context = new GLContextManager(canvas, framework, options);
        var gl = _this.context.gl;
        assertExist(gl);
        GPUCapability.initialize(gl);
        _this.pipelineContext = new GLPipelineContext(gl);
        _this.engine = new GLEngine();
        _this.engine.renderer = _this;
        _this.glRenderer = new GLRendererInternal(_this.engine);
        _this.extension = new ExtWrap(_this);
        _this.renderingData = {
            //@ts-expect-error
            currentFrame: {},
        };
        _this.frameBuffer = new GLFrameBuffer({
            storeAction: {},
            viewport: [0, 0, _this.width, _this.height],
            attachments: [new GLTexture({
                    sourceType: exports.TextureSourceType.framebuffer,
                    data: { width: _this.width, height: _this.height },
                })],
            depthStencilAttachment: { storageType: exports.RenderPassAttachmentStorageType.none },
        }, _this);
        return _this;
    }
    Object.defineProperty(GLRenderer.prototype, "isDestroyed", {
        get: function () {
            var internal = this.glRenderer;
            return internal ? internal.isDestroyed : true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLRenderer.prototype, "height", {
        get: function () {
            var _a;
            return ((_a = this.glRenderer) === null || _a === void 0 ? void 0 : _a.height) || 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLRenderer.prototype, "width", {
        get: function () {
            var _a;
            return ((_a = this.glRenderer) === null || _a === void 0 ? void 0 : _a.width) || 0;
        },
        enumerable: false,
        configurable: true
    });
    GLRenderer.prototype.renderRenderFrame = function (renderFrame) {
        var e_1, _a, e_2, _b;
        var frame = renderFrame;
        // TODO 需要一个贴图统一初始化的管理类，避免在渲染逻辑代码中初始化。
        // 初始化renderframe的贴图资源
        // if (frame.cachedTextures) {
        //   for (const texture of frame.cachedTextures) {
        //     (texture as GLTexture).initialize(this.pipelineContext);
        //   }
        // }
        if (frame.resource) {
            frame.resource.color_b.initialize(this.engine);
        }
        frame.emptyTexture.initialize(this.engine);
        frame.transparentTexture.initialize(this.engine);
        var passes = frame._renderPasses;
        if (this.isDestroyed) {
            return console.error('renderer is destroyed', this);
        }
        frame.renderer.getShaderLibrary().compileAllShaders();
        this.setFrameBuffer(null);
        this.clear(frame.clearAction);
        this.renderingData.currentFrame = frame;
        this.renderingData.currentCamera = frame.camera;
        // 根据 priority 排序 pass
        passes.sortByOrder();
        try {
            for (var passes_1 = __values$1(passes), passes_1_1 = passes_1.next(); !passes_1_1.done; passes_1_1 = passes_1.next()) {
                var pass = passes_1_1.value;
                var delegate = pass.delegate;
                delegate.willBeginRenderPass && (delegate === null || delegate === void 0 ? void 0 : delegate.willBeginRenderPass(pass, this.renderingData));
                this.renderRenderPass(pass);
                delegate.didEndRenderPass && (delegate === null || delegate === void 0 ? void 0 : delegate.didEndRenderPass(pass, this.renderingData));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (passes_1_1 && !passes_1_1.done && (_a = passes_1.return)) _a.call(passes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var passes_2 = __values$1(passes), passes_2_1 = passes_2.next(); !passes_2_1.done; passes_2_1 = passes_2.next()) {
                var pass = passes_2_1.value;
                pass.frameCleanup(this);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (passes_2_1 && !passes_2_1.done && (_b = passes_2.return)) _b.call(passes_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    GLRenderer.prototype.renderRenderPass = function (pass) {
        this.renderingData.currentPass = pass;
        // 初始化 pass attachment GPU资源
        pass.initialize(this);
        // 配置当前 renderer 的 RT
        pass.configure(this);
        // 执行当前 pass
        pass.execute(this);
    };
    GLRenderer.prototype.renderMeshes = function (meshes) {
        var e_3, _a;
        var glMeshes = meshes;
        var delegate = this.renderingData.currentPass.delegate;
        try {
            for (var glMeshes_1 = __values$1(glMeshes), glMeshes_1_1 = glMeshes_1.next(); !glMeshes_1_1.done; glMeshes_1_1 = glMeshes_1.next()) {
                var mesh = glMeshes_1_1.value;
                if (mesh.isDestroyed) {
                    // console.error(`mesh ${mesh.name} destroyed`, mesh);
                    continue;
                }
                if (mesh.getVisible()) {
                    continue;
                }
                delegate.willRenderMesh && delegate.willRenderMesh(mesh, this.renderingData);
                mesh.render(this);
                delegate.didiRenderMesh && delegate.didiRenderMesh(mesh, this.renderingData);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (glMeshes_1_1 && !glMeshes_1_1.done && (_a = glMeshes_1.return)) _a.call(glMeshes_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    GLRenderer.prototype.setFrameBuffer = function (frameBuffer) {
        if (frameBuffer) {
            this.frameBuffer = frameBuffer;
            this.frameBuffer.bind();
            this.setViewport(frameBuffer.viewport[0], frameBuffer.viewport[1], frameBuffer.viewport[2], frameBuffer.viewport[3]);
        }
        else {
            //this.frameBuffer = null;
            this.pipelineContext.bindSystemFramebuffer();
            this.setViewport(0, 0, this.getWidth(), this.getHeight());
        }
    };
    GLRenderer.prototype.getFrameBuffer = function () {
        return this.frameBuffer;
    };
    GLRenderer.prototype.setRenderTarget = function (color, depth) {
        var colorAttachments = [];
        if (color instanceof Texture) {
            colorAttachments.push(color);
        }
        else {
            colorAttachments = color;
        }
        if (!this.frameBuffer) {
            var _a = GPUCapability.getInstance(), detail = _a.detail, level = _a.level;
            var depthStencilType = detail.readableDepthStencilTextures && detail.writableFragDepth ?
                exports.RenderPassAttachmentStorageType.depth_24_stencil_8_texture :
                exports.RenderPassAttachmentStorageType.depth_stencil_opaque;
            var filter = level === 2 ? glContext.LINEAR : glContext.NEAREST;
            this.frameBuffer = new GLFrameBuffer({
                attachments: [Texture.create({
                        sourceType: exports.TextureSourceType.framebuffer,
                        format: glContext.RGBA,
                        name: 'frame_a',
                        minFilter: filter,
                        magFilter: filter,
                    })],
                depthStencilAttachment: { storageType: depthStencilType },
                viewport: [0, 0, this.width, this.height],
                storeAction: {
                    colorAction: exports.TextureStoreAction.store,
                    depthAction: exports.TextureStoreAction.store,
                    stencilAction: exports.TextureStoreAction.store,
                },
            }, this);
            this.frameBuffer.bind();
        }
        this.frameBuffer.resetColorTextures(colorAttachments);
    };
    GLRenderer.prototype.setViewport = function (x, y, width, height) {
        this.pipelineContext.viewport(x, y, width, height);
    };
    GLRenderer.prototype.clear = function (action) {
        var state = this.pipelineContext;
        var bit = 0;
        if (action.colorAction === exports.TextureLoadAction.clear) {
            var clearColor = action.clearColor;
            if (clearColor) {
                state.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
            }
            state.colorMask(true, true, true, true);
            bit = glContext.COLOR_BUFFER_BIT;
        }
        if (action.stencilAction === exports.TextureLoadAction.clear) {
            state.stencilMask(0xff);
            state.clearStencil(action.clearStencil || 0);
            bit = bit | glContext.STENCIL_BUFFER_BIT;
        }
        if (action.depthAction === exports.TextureLoadAction.clear) {
            var depth = action.clearDepth;
            state.depthMask(true);
            state.clearDepth(Number.isFinite(depth) ? depth : 1);
            bit = bit | glContext.DEPTH_BUFFER_BIT;
        }
        if (bit) {
            state.clear(bit);
        }
    };
    GLRenderer.prototype.addLostHandler = function (lostHandler) {
        this.context.addLostHandler(lostHandler);
    };
    GLRenderer.prototype.addRestoreHandler = function (restoreHandler) {
        this.context.addRestoreHandler(restoreHandler);
    };
    GLRenderer.prototype.getShaderLibrary = function () {
        return this.pipelineContext.shaderLibrary;
    };
    GLRenderer.prototype.getWidth = function () {
        return this.width;
    };
    GLRenderer.prototype.getHeight = function () {
        return this.height;
    };
    GLRenderer.prototype.dispose = function (haltGL) {
        var _a;
        this.context.dispose();
        this.extension.dispose();
        this.pipelineContext.dispose();
        (_a = this.glRenderer) === null || _a === void 0 ? void 0 : _a.dispose(haltGL);
        // @ts-expect-error
        this.canvas = null;
        this.engine.dispose();
    };
    GLRenderer.prototype.lost = function (e) {
        e.preventDefault();
        this.pipelineContext.dispose();
        this.extension.dispose();
        this.glRenderer.lost(e);
    };
    GLRenderer.prototype.restore = function () {
        // FIXME: 需要测试下lost和restore流程
        var gl = this.context.gl;
        if (!gl) {
            throw new Error('Can not restore automatically because losing gl context');
        }
        GPUCapability.initialize(gl);
        this.pipelineContext = new GLPipelineContext(gl);
        this.glRenderer = new GLRendererInternal(this.engine);
        this.extension = new ExtWrap(this);
    };
    GLRenderer.prototype.resize = function (width, height) {
        var internal = this.glRenderer;
        if (internal) {
            if (this.width !== width || this.height !== height) {
                internal.resize(width, height);
            }
        }
    };
    return GLRenderer;
}(Renderer));

var GLMaterialDataBlock = /** @class */ (function (_super) {
    __extends(GLMaterialDataBlock, _super);
    function GLMaterialDataBlock(props) {
        var _this = _super.call(this, props) || this;
        _this.uniformValueRanges = {};
        _this.uboBufferMap = {};
        _this.uniformFlags = {};
        _this.uniformValues = {};
        _this.keepUboData = !!props.keepUboData;
        if (props.uniformValues) {
            _this.setUniformValues(props.uniformValues);
        }
        return _this;
    }
    Object.defineProperty(GLMaterialDataBlock.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    GLMaterialDataBlock.prototype.hasUniformValue = function (name) {
        return name in this.uniformValues;
    };
    GLMaterialDataBlock.prototype.getUniformValue = function (name) {
        return this.uniformValues[name];
    };
    GLMaterialDataBlock.prototype.getUniformFlag = function (name) {
        return this.uniformFlags[name];
    };
    GLMaterialDataBlock.prototype.getUniformValues = function () {
        return this.uniformValues;
    };
    /**初始化uniformValues中的贴图GPU资源 */
    GLMaterialDataBlock.prototype.initialize = function (engine) {
        var e_1, _a, e_2, _b;
        this.engine = engine;
        try {
            for (var _c = __values$1(Object.values(this.uniformValues)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var value = _d.value;
                if (value instanceof Array) {
                    try {
                        for (var value_1 = (e_2 = void 0, __values$1(value)), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                            var v = value_1_1.value;
                            if (this.isTexture(v)) {
                                v.initialize(engine);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (value_1_1 && !value_1_1.done && (_b = value_1.return)) _b.call(value_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                else {
                    if (this.isTexture(value)) {
                        value.initialize(engine);
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    GLMaterialDataBlock.prototype.createUboBuffer = function (spec) {
        if (!this.uboBufferMap[spec.id] && this.gl && this.name === spec.name) {
            var pipelineContext = this.engine.getGLPipelineContext();
            var ubo = this.uboBufferMap[spec.id] = new UniformBlockBuffer(pipelineContext, spec);
            ubo.keepData = this.keepUboData;
        }
        return this.uboBufferMap[spec.id];
    };
    GLMaterialDataBlock.prototype.setUboBuffer = function (uboBuffer) {
        uboBuffer.setValues(this.uniformValues, this.uniformFlags, this.uniformValueRanges);
    };
    GLMaterialDataBlock.prototype.clearFlags = function () {
        this.uniformFlags = {};
    };
    // TODO 考虑调用逻辑是否合理，目前该函数会有在initialize函数调用前调用的情况。
    // 主要问题是texture在GLMaterialDataBlock的initialize前初始化会有gl报错。
    GLMaterialDataBlock.prototype.setUniformValue = function (name, value) {
        var _this = this;
        if (isUniformStruct(value)) {
            Object.keys(value).forEach(function (key) {
                var nameInStruct = "".concat(name, ".").concat(key);
                var valueInStruct = value[key];
                _this.uniformValues[nameInStruct] = valueInStruct;
                _this.uniformFlags[nameInStruct] = true;
                _this.assignUniformValueRenderer(_this.engine, valueInStruct);
            });
            // 只是用来保存结构体对象
            this.uniformValues[name] = value;
            this.uniformFlags[name] = false;
        }
        else if (isUniformStructArray(value)) {
            value.forEach(function (valueData, i) {
                Object.keys(valueData).forEach(function (key) {
                    var valueInStruct = valueData[key];
                    var nameInStruct = "".concat(name, "[").concat(i, "].").concat(key);
                    _this.uniformValues[nameInStruct] = valueInStruct;
                    _this.uniformFlags[nameInStruct] = true;
                    _this.assignUniformValueRenderer(_this.engine, valueInStruct);
                });
            });
            // 只是用来保存结构体对象
            this.uniformValues[name] = value;
            this.uniformFlags[name] = false;
        }
        else {
            this.uniformValues[name] = value;
            this.uniformFlags[name] = true;
            this.assignUniformValueRenderer(this.engine, value);
        }
    };
    GLMaterialDataBlock.prototype.removeUniformValue = function (name) {
        if (this.getUniformValue(name)) {
            delete this.uniformValues[name];
            this.uniformFlags[name] = false;
        }
    };
    GLMaterialDataBlock.prototype.invalidAllFlags = function () {
        var _this = this;
        Object.keys(this.uniformValues).forEach(function (key) {
            _this.uniformFlags[key] = true;
            _this.uniformValueRanges[key] = [0, 0];
        });
    };
    GLMaterialDataBlock.prototype.updateUniformSubData = function (name, start, count) {
        var range = this.uniformValueRanges[name];
        if (!this.uniformValueRanges[name]) {
            this.uniformValueRanges[name] = [start, count];
        }
        else {
            var end = Math.max(range[0] + range[1], start + count);
            var s = Math.min(start, range[0]);
            this.uniformValueRanges[name] = [s, end - s];
        }
        this.uniformFlags[name] = true;
    };
    GLMaterialDataBlock.prototype.assignUniformValueRenderer = function (engine, value) {
        var _this = this;
        if (engine) {
            var assign = function (value) { return _this.isTexture(value) && value.initialize(engine); };
            if (value instanceof Array) {
                value.forEach(assign);
            }
            else {
                assign(value);
            }
        }
    };
    /**
     * 判断 uniform 值是否是 texture
     * @param value
     * @returns
     */
    GLMaterialDataBlock.prototype.isTexture = function (value) {
        if (typeof value === 'object' && value && value instanceof Texture) {
            return true;
        }
        return false;
    };
    GLMaterialDataBlock.prototype.dispose = function (options) {
        if ((options === null || options === void 0 ? void 0 : options.textures) !== exports.DestroyOptions.keep) {
            Object.values(this.uniformValues).forEach(function (uniform) {
                if (uniform instanceof GLTexture) {
                    uniform.dispose();
                }
            });
        }
        Object.values(this.uboBufferMap).forEach(function (uboBuffer) { return uboBuffer === null || uboBuffer === void 0 ? void 0 : uboBuffer.dispose(); });
        this.uboBufferMap = {};
        this.uniformFlags = {};
        this.uniformValues = {};
        this.initialize = throwDestroyedError$1;
        this.destroyed = true;
    };
    return GLMaterialDataBlock;
}(MaterialDataBlock));

var HELP_LINK = {
    'Container size overflowed': 'https://yuque.antfin.com/huoxing/knaszl/qtnsf2g9ofigggor#MvjnY',
    'DPI overflowed': 'https://yuque.antfin.com/huoxing/knaszl/qtnsf2g9ofigggor#ulfNT',
    'Invalid container size': 'https://yuque.antfin.com/huoxing/knaszl/qtnsf2g9ofigggor#lLlSW',
    'Container is not an HTMLElement': 'https://yuque.antfin.com/huoxing/knaszl/qtnsf2g9ofigggor#WZaWg',
    'Never use destroyed player again': 'https://yuque.antfin.com/huoxing/knaszl/qtnsf2g9ofigggor#YSWQr',
    'Current running player count': 'https://yuque.antfin.com/huoxing/knaszl/qtnsf2g9ofigggor#IzodZ',
};

var Ticker = /** @class */ (function () {
    function Ticker(fps) {
        if (fps === void 0) { fps = 60; }
        this.paused = true;
        this.lastTime = 0;
        this.setFPS(fps);
        this.tickers = [];
    }
    Ticker.prototype.getFPS = function () {
        return this.targetFPS;
    };
    Ticker.prototype.setFPS = function (fps) {
        this.targetFPS = clamp$1(fps, 1, 120);
        this.interval = Math.floor(1000 / fps) - 1;
    };
    Ticker.prototype.getPaused = function () {
        return this.paused;
    };
    Ticker.prototype.start = function () {
        var _this = this;
        this.paused = false;
        if (!this.intervalId) {
            this.lastTime = performance.now();
            var raf_1 = requestAnimationFrame || function (func) {
                return window.setTimeout(func, 16);
            };
            var runLoop_1 = function () {
                _this.intervalId = raf_1(runLoop_1);
                if (!_this.paused) {
                    _this.tick();
                }
            };
            runLoop_1();
        }
    };
    Ticker.prototype.stop = function () {
        (cancelAnimationFrame || window.clearTimeout)(this.intervalId);
        this.intervalId = 0;
        this.lastTime = 0;
        this.paused = true;
        this.tickers = [];
    };
    Ticker.prototype.pause = function () {
        this.paused = true;
    };
    Ticker.prototype.resume = function () {
        this.paused = false;
    };
    Ticker.prototype.tick = function () {
        if (this.paused) {
            return;
        }
        var startTime = performance.now();
        var deltaTime = startTime - this.lastTime;
        if (deltaTime >= this.interval) {
            this.lastTime = startTime;
            if (this.resetTickers) {
                this.tickers = this.tickers.filter(function (tick) { return tick; });
                this.resetTickers = false;
            }
            for (var i = 0, len = this.tickers.length; i < len; i++) {
                var tick = this.tickers[i];
                tick(deltaTime);
            }
        }
    };
    Ticker.prototype.add = function (ticker) {
        if (typeof (ticker) !== 'function') {
            throw new Error('Ticker: The tick object must implement the tick method.');
        }
        this.tickers.push(ticker);
    };
    return Ticker;
}());

function isDowngradeIOS() {
    var iOSVersionRegex = /iPhone OS (\d+)_(\d+)/;
    var match = iOSVersionRegex.exec(navigator.userAgent);
    if (match) {
        return match[1] === '13' || (match[1] === '16' && match[2] === '5');
    }
    return false;
}

var playerMap = new Map();
var enableDebugType = false;
var seed = 1;
/**
 * Mars 播放器
 */
var MarsPlayer = /** @class */ (function () {
    /**
     * 播放器的构造函数
     * @param config
     */
    function MarsPlayer(config) {
        var _this = this;
        var _a, _b;
        /**
         * 当前播放的合成对象数组，请不要修改内容
         */
        this.compositions = [];
        this.displayScale = 1;
        this.resumePending = false;
        this.disposed = false;
        /**
         * 播放器在 `webglcontextlost` 时执行的操作
         * @param e - Event
         */
        this.lost = function (e) {
            var _a, _b;
            (_a = _this.ticker) === null || _a === void 0 ? void 0 : _a.pause();
            _this.compositions.forEach(function (comp) { return comp.lost(e); });
            _this.renderer.lost(e);
            (_b = _this.handleWebGLContextLost) === null || _b === void 0 ? void 0 : _b.call(_this, e);
        };
        /**
         * 播放器在 `webglcontextrestored` 时执行的操作
         * @returns
         */
        this.restore = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            var _this = this;
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        this.renderer.restore();
                        _a = this;
                        return [4 /*yield*/, Promise.all(this.compositions.map(function (composition) { return __awaiter(_this, void 0, void 0, function () {
                                var currentTime, url, speed, keepResource, reusable, renderOrder, rootTransform, videoState, scene, renderer, options, i, video, newComp;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            currentTime = composition.time, url = composition.url, speed = composition.speed, keepResource = composition.keepResource, reusable = composition.reusable, renderOrder = composition.renderOrder, rootTransform = composition.rootTransform, videoState = composition.videoState;
                                            return [4 /*yield*/, this.loadScene(url)];
                                        case 1:
                                            scene = _a.sent();
                                            renderer = this.renderer;
                                            options = {
                                                speed: speed,
                                                keepResource: keepResource,
                                                reusable: reusable,
                                                baseRenderOrder: renderOrder,
                                                transform: rootTransform,
                                            };
                                            i = 0;
                                            _a.label = 2;
                                        case 2:
                                            if (!(i < videoState.length)) return [3 /*break*/, 5];
                                            if (!videoState[i]) return [3 /*break*/, 4];
                                            video = scene.textureOptions[i].video;
                                            video.currentTime = videoState[i];
                                            return [4 /*yield*/, video.play()];
                                        case 3:
                                            _a.sent();
                                            _a.label = 4;
                                        case 4:
                                            i++;
                                            return [3 /*break*/, 2];
                                        case 5:
                                            newComp = Composition.initialize(scene, __assign$1(__assign$1({}, options), { currentTime: currentTime, renderer: renderer, width: renderer.getWidth(), height: renderer.getHeight(), shaderLibrary: renderer.getShaderLibrary(), event: this.event, handlePlayerPause: this.handlePlayerPause, handleMessageItem: this.handleMessageItem, handleEnd: this.handleEnd }));
                                            newComp.start();
                                            newComp.forwardTime(currentTime);
                                            return [2 /*return*/, newComp];
                                    }
                                });
                            }); }))];
                    case 1:
                        _a.compositions = _c.sent();
                        (_b = this.handleWebGLContextRestored) === null || _b === void 0 ? void 0 : _b.call(this);
                        this.ticker.resume();
                        return [2 /*return*/];
                }
            });
        }); };
        this.handleResume = function () {
            var _a;
            (_a = _this.handlePlayableUpdate) === null || _a === void 0 ? void 0 : _a.call(_this, {
                player: _this,
                playing: true,
            });
        };
        this.handleClick = function (e) {
            var x = e.x, y = e.y;
            _this.compositions.forEach(function (composition) {
                var _a;
                var regions = composition.hitTest(x, y);
                if (regions.length) {
                    for (var i = 0; i < regions.length; i++) {
                        var behavior = regions[i].behavior || InteractBehavior$2.NOTIFY;
                        if (behavior === InteractBehavior$2.NOTIFY) {
                            var _b = regions[i], name_1 = _b.name, id = _b.id, hitPositions = _b.hitPositions;
                            (_a = _this.handleItemClicked) === null || _a === void 0 ? void 0 : _a.call(_this, {
                                name: name_1,
                                player: _this,
                                composition: composition.name,
                                id: id,
                                compositionId: composition.id,
                                hitPositions: hitPositions,
                            });
                        }
                        else if (behavior === InteractBehavior$2.RESUME_PLAYER) {
                            void _this.resume();
                        }
                    }
                }
            });
        };
        var container = config.container, canvas = config.canvas, gl = config.gl, fps = config.fps, name = config.name, pixelRatio = config.pixelRatio, manualRender = config.manualRender, interactive = config.interactive, reportGPUTime = config.reportGPUTime, onMessageItem = config.onMessageItem, onPausedByItem = config.onPausedByItem, onItemClicked = config.onItemClicked, onPlayableUpdate = config.onPlayableUpdate, onRenderError = config.onRenderError, onWebGLContextLost = config.onWebGLContextLost, onWebGLContextRestored = config.onWebGLContextRestored, glType = config.renderFramework, _c = config.env, env = _c === void 0 ? '' : _c;
        // v2.0.0 将 willCaptureImage, premultiplyAlpha 统一到 renderOptions 下
        var _d = (_b = (_a = config.renderOptions) !== null && _a !== void 0 ? _a : config) !== null && _b !== void 0 ? _b : {}, willCaptureImage = _d.willCaptureImage, premultiplyAlpha = _d.premultiplyAlpha;
        // 原 debug-disable 直接返回
        if (enableDebugType || glType === 'debug-disable') {
            return;
        }
        // 注意：安卓设备和 iOS 13/iOS 16.5 在 WebGL2 下有渲染或卡顿问题，故默认使用 WebGL1
        var framework = (isAndroid() || isDowngradeIOS()) ? 'webgl' : 'webgl2';
        // 用户可以通过传入 renderFramework，手动强制使用 WebGL 1/2 来渲染
        if (glType) {
            framework = glType === 'webgl' ? 'webgl' : 'webgl2';
        }
        this.handleWebGLContextLost = onWebGLContextLost;
        this.handleWebGLContextRestored = onWebGLContextRestored;
        this.reportGPUTime = reportGPUTime;
        this.handleItemClicked = onItemClicked;
        this.handleMessageItem = onMessageItem;
        this.handlePlayableUpdate = onPlayableUpdate;
        this.handleRenderError = onRenderError;
        this.handlePlayerPause = function (item) {
            if (_this.pause()) {
                onPausedByItem === null || onPausedByItem === void 0 ? void 0 : onPausedByItem({
                    name: item.name,
                    player: _this,
                });
            }
        };
        this.pixelRatio = Number.isFinite(pixelRatio) ? pixelRatio : getPixelRatio();
        this.offscreenMode = true;
        setConfig(RUNTIME_ENV, env);
        this.env = env;
        if (canvas) {
            this.canvas = canvas;
        }
        else if (gl) {
            this.canvas = gl.canvas;
        }
        else {
            assertContainer(container);
            this.canvas = document.createElement('canvas');
            container === null || container === void 0 ? void 0 : container.appendChild(this.canvas);
        }
        this.renderer = Renderer.create(this.canvas, framework, {
            preserveDrawingBuffer: willCaptureImage,
            premultipliedAlpha: premultiplyAlpha,
        });
        this.clearPipeline = new RenderFrame({
            clearAction: {
                stencilAction: exports.TextureLoadAction.clear,
                clearStencil: 0,
                depthAction: exports.TextureLoadAction.clear,
                clearDepth: 1,
                colorAction: exports.TextureLoadAction.clear,
                clearColor: [0, 0, 0, 0],
            },
            renderer: this.renderer,
            camera: new Camera('clear_pipeline_camera'),
        });
        this.renderer.addLostHandler({ lost: this.lost });
        this.renderer.addRestoreHandler({ restore: this.restore });
        this.gpuCapability = GPUCapability.getInstance();
        if (!manualRender) {
            this.ticker = new Ticker(fps);
            this.ticker.add(this.tick.bind(this));
        }
        this.event = new EventSystem(this.canvas);
        this.event.bindListeners();
        this.event.addEventListener(EVENT_TYPE_CLICK, this.handleClick);
        this.interactive = interactive !== null && interactive !== void 0 ? interactive : false;
        this.name = name || "".concat(seed++);
        if (!gl) {
            this.resize();
        }
        setSpriteMeshMaxItemCountByGPU(this.gpuCapability.detail);
        this.container = this.canvas.parentElement;
        playerMap.set(this.canvas, this);
        assertNoConcurrentPlayers();
        broadcastPlayerEvent(this, true);
    }
    Object.defineProperty(MarsPlayer.prototype, "currentComposition", {
        /**
         * 获取当前播放合成，如果是多个合成同时播放，返回第一个合成
         * @since 2.0.0
         */
        get: function () {
            return this.compositions[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MarsPlayer.prototype, "currentCompositionName", {
        /**
         * 当前播放的合成名称，如果是多个合成同时播放，返回第一个合成名称
         * @internal
         * @deprecated since 2.0.0 - use `currentComposition.name` instead
         */
        get: function () {
            var _a;
            console.warn('The currentCompositionName property is deprecated. Use currentComposition.name instead.');
            var name = ((_a = this.currentComposition) !== null && _a !== void 0 ? _a : {}).name;
            return name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MarsPlayer.prototype, "hasPlayable", {
        /**
         * 是否有合成在播放
         */
        get: function () {
            return this.compositions.length > 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MarsPlayer.prototype, "paused", {
        /**
         * 播放器是否已暂停
         */
        get: function () {
            var _a;
            return (_a = this.ticker) === null || _a === void 0 ? void 0 : _a.getPaused();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MarsPlayer.prototype, "interactive", {
        /**
         * 获取播放器是否可交互
         */
        get: function () {
            return this.event.enabled;
        },
        /**
         * 设置播放器是否可交互
         */
        set: function (enable) {
            this.event.enabled = enable;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 异步加载动画资源
     * @since 2.0.0
     * @param url - URL 或者通过 URL 请求的 JSONObject
     * @param options - 加载可选参数
     * @returns
     */
    MarsPlayer.prototype.loadScene = function (url, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var scene;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.assetManager = new AssetManager(options);
                        return [4 /*yield*/, this.assetManager.loadScene(url, this.renderer.getShaderLibrary())];
                    case 1:
                        scene = _a.sent();
                        return [2 /*return*/, scene];
                }
            });
        });
    };
    /**
     * @internal
     * @deprecated since 2.0.0 - use `loadScene` instead
     */
    MarsPlayer.prototype.loadSceneAsync = function (url, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                console.warn('The loadSceneAsync function is deprecated. Use loadScene instead.');
                return [2 /*return*/, this.loadScene(url, options)];
            });
        });
    };
    /**
     * 创建并播放合成对象
     * > 此方法会进行 shader 异步编译（如果 MarsPlayer 要和 CSS 同时使用可避免卡顿）
     * @since 2.0.0
     * @param scene - 合成对象或加载好的动画网络资源
     * @param options - 播放可选参数
     * @returns
     */
    MarsPlayer.prototype.play = function (scene, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var renderer, startTime, composition, multipleCompositions, startComposition;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        renderer = this.renderer;
                        startTime = performance.now();
                        // 对老参数 willReverseTime 的兼容
                        if (options.reusable === undefined && options.willReverseTime !== undefined) {
                            options.reusable = options.willReverseTime;
                        }
                        if (this.offscreenMode) {
                            this.resize();
                            this.offscreenMode = false;
                        }
                        multipleCompositions = !!options.multipleCompositions;
                        if (!multipleCompositions) {
                            this.compositions.forEach(function (comp) { return comp.dispose(); });
                        }
                        if (scene instanceof Composition) {
                            composition = scene;
                            if (!composition.renderer) {
                                throw new Error('Destroyed composition cannot be used again');
                            }
                        }
                        else {
                            composition = Composition.initialize(scene, __assign$1(__assign$1({}, options), { renderer: renderer, width: renderer.getWidth(), height: renderer.getHeight(), shaderLibrary: renderer.getShaderLibrary(), event: this.event, handlePlayerPause: this.handlePlayerPause, handleMessageItem: this.handleMessageItem, handleEnd: options.onEnd }));
                            composition.content.start();
                            this.handleEnd = options.onEnd;
                        }
                        startComposition = function () {
                            if (multipleCompositions) {
                                addItemWithOrder(_this.compositions, composition, 'renderOrder');
                            }
                            else {
                                _this.compositions = [composition];
                            }
                            composition.content.start();
                            var ticker = _this.ticker;
                            if (ticker) {
                                if (composition.renderLevel === RenderLevel$1.B) {
                                    ticker.setFPS(Math.min(ticker.getFPS(), 30));
                                }
                                ticker.start();
                            }
                            var time = options.currentTime;
                            if (isNaN(+time)) {
                                time = composition.startTime;
                            }
                            _this.forwardCompositionTime(composition, time || 0);
                            _this.renderFrame({
                                pauseOnFirstFrame: options.pauseOnFirstFrame,
                            });
                            var timeEnd = performance.now() - startTime;
                            var firstFrameTime = timeEnd + composition.statistic.loadTime;
                            composition.statistic.firstFrameTime = firstFrameTime;
                            console.info("first frame: [".concat(composition.name, "]").concat(firstFrameTime.toFixed(4), "ms"));
                        };
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                _this.renderer.getShaderLibrary().compileAllShaders(function () {
                                    startComposition();
                                    resolve(null);
                                });
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, composition];
                }
            });
        });
    };
    /**
     * @internal
     * @deprecated since 2.0.0 - use `play` instead
     */
    MarsPlayer.prototype.playAsync = function (scene, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                console.warn('The playAsync function is deprecated. Use play instead.');
                return [2 /*return*/, this.play(scene, options)];
            });
        });
    };
    /**
     * 暂停播放器
     * @param options
     * @param options.offloadTexture - 是否卸载贴图纹理，减少内存
     * @returns
     */
    MarsPlayer.prototype.pause = function (options) {
        var _a, _b;
        if (!this.paused) {
            (_a = this.ticker) === null || _a === void 0 ? void 0 : _a.pause();
            (_b = this.handlePlayableUpdate) === null || _b === void 0 ? void 0 : _b.call(this, {
                player: this,
                playing: false,
            });
            if (options && options.offloadTexture) {
                this.offloadTexture();
            }
            return true;
        }
    };
    /**
     * 恢复播放器
     * > 如果暂停时卸载了纹理贴图，此函数将自动请求网络重新加载纹理
     * @since 2.0.0
     * @returns
     */
    MarsPlayer.prototype.resume = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this.resumePending) {
                            return [2 /*return*/];
                        }
                        if (!this.paused) return [3 /*break*/, 2];
                        this.resumePending = true;
                        return [4 /*yield*/, Promise.all(this.compositions.map(function (c) { return c.reloadTexture(); }))];
                    case 1:
                        _b.sent();
                        this.resumePending = false;
                        if (isIOS()) {
                            // fix iOS bug
                            this.canvas ? this.canvas.style.display = 'none' : '';
                            window.setTimeout(function () {
                                _this.canvas ? _this.canvas.style.display = '' : '';
                            }, 0);
                        }
                        this.handleResume();
                        _b.label = 2;
                    case 2:
                        (_a = this.ticker) === null || _a === void 0 ? void 0 : _a.resume();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * @deprecated since 2.0.0 - use `resume` instead
     */
    MarsPlayer.prototype.resumeAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                console.warn('The resumeAsync function is deprecated. Use resume instead.');
                return [2 /*return*/, this.resume()];
            });
        });
    };
    /**
     * player 在定时器每帧的回调
     * @param dt - 时间差，毫秒
     */
    MarsPlayer.prototype.tick = function (dt) {
        this.doTick(dt, this.forceRenderNextFrame);
        this.forceRenderNextFrame = false;
    };
    MarsPlayer.prototype.doTick = function (dt, forceRender) {
        var _this = this;
        var _a, _b, _c;
        dt = Math.min(dt, 33);
        var removed = false;
        var comps = this.compositions;
        var skipRender = false;
        comps.forEach(function (composition, i) {
            if (composition.textureOffloaded) {
                skipRender = true;
                console.error("Composition ".concat(composition.name, " texture offloaded, skip render."));
            }
            if (composition.renderer) {
                composition.update(dt);
            }
            if (composition.isDestroyed) {
                delete comps[i];
                removed = true;
            }
        });
        if (removed) {
            comps = comps.filter(function (comp) { return comp; });
            this.compositions = comps;
        }
        if (skipRender) {
            (_a = this.handleRenderError) === null || _a === void 0 ? void 0 : _a.call(this, new Error('play when texture offloaded'));
            return (_b = this.ticker) === null || _b === void 0 ? void 0 : _b.pause();
        }
        if (!this.paused || forceRender) {
            var level = this.gpuCapability.level;
            var gl = this.renderer.context.gl;
            var time = (level === 2 && this.reportGPUTime) ? gpuTimer(gl) : undefined;
            time === null || time === void 0 ? void 0 : time.begin();
            if (this.compositions.length || forceRender) {
                this.renderer.renderRenderFrame(this.clearPipeline);
                for (var i = 0; i < comps.length; i++) {
                    this.renderer.renderRenderFrame(comps[i].renderFrame);
                }
            }
            time === null || time === void 0 ? void 0 : time.end();
            time === null || time === void 0 ? void 0 : time.getTime().then(function (t) { var _a; return (_a = _this.reportGPUTime) === null || _a === void 0 ? void 0 : _a.call(_this, t !== null && t !== void 0 ? t : 0); }).catch;
            if (!this.forwardingTime) {
                (_c = this.handlePlayableUpdate) === null || _c === void 0 ? void 0 : _c.call(this, {
                    player: this,
                    playing: true,
                });
            }
        }
    };
    /**
     * 调整画布的宽高比
     * @param aspect
     * @param scale
     */
    MarsPlayer.prototype.resizeToAspect = function (aspect, scale) {
        if (scale === void 0) { scale = 1; }
        if (aspect !== this.displayAspect) {
            this.displayAspect = aspect;
        }
        if (scale !== this.displayScale) {
            this.displayScale = scale;
        }
        this.resize();
    };
    /**
     * 将播放器重新和父容器大小对齐
     */
    MarsPlayer.prototype.resize = function () {
        var _a;
        var parentElement = this.canvas.parentElement;
        var containerWidth;
        var containerHeight;
        var canvasWidth;
        var canvasHeight;
        if (parentElement) {
            var size = this.getTargetSize(parentElement);
            containerWidth = size[0];
            containerHeight = size[1];
            canvasWidth = size[2];
            canvasHeight = size[3];
        }
        else {
            containerWidth = canvasWidth = this.canvas.width;
            containerHeight = canvasHeight = this.canvas.height;
        }
        var aspect = containerWidth / containerHeight;
        if (containerWidth && containerHeight) {
            var documentWidth = document.documentElement.clientWidth;
            if (canvasWidth > documentWidth * 2) {
                console.error("DPI overflowed, width ".concat(canvasWidth, " is more than 2x document width ").concat(documentWidth, ", see ").concat(HELP_LINK['DPI overflowed']));
            }
            var maxSize = this.env ? this.gpuCapability.detail.maxTextureSize : 2048;
            if ((canvasWidth > maxSize || canvasHeight > maxSize)) {
                console.error("Container size overflowed ".concat(canvasWidth, "x").concat(canvasHeight, ", see ").concat(HELP_LINK['Container size overflowed']));
                if (aspect > 1) {
                    canvasWidth = Math.round(maxSize);
                    canvasHeight = Math.round(maxSize / aspect);
                }
                else {
                    canvasHeight = Math.round(maxSize);
                    canvasWidth = Math.round(maxSize * aspect);
                }
            }
            // ios 14.1 -ios 14.3 resize canvas will cause memory leak
            this.renderer.resize(canvasWidth, canvasHeight);
            this.canvas.style.width = containerWidth + 'px';
            this.canvas.style.height = containerHeight + 'px';
            console.debug("Resize player ".concat(this.name, " [").concat(canvasWidth, ",").concat(canvasHeight, ",").concat(containerWidth, ",").concat(containerHeight, "]."));
            (_a = this.compositions) === null || _a === void 0 ? void 0 : _a.forEach(function (comp) {
                comp.camera.aspect = aspect;
            });
        }
    };
    /**
     * 修改播放器的配置
     * @param config - 播放配置，当前仅支持修改合成播放速度
     */
    MarsPlayer.prototype.config = function (config) {
        var singleComp = typeof config.compositionName === 'string';
        if ('speed' in config) {
            var speed_1 = +(config.speed || 1);
            if (singleComp) {
                var comp = this.compositions.find(function (comp) { return comp.name === config.compositionName; });
                if (comp) {
                    comp.speed = speed_1;
                }
            }
            else {
                this.compositions.forEach(function (comp) { return (comp.speed = speed_1); });
            }
        }
    };
    /**
     * 快进/快退指定时间间隔
     * @param composition - 要快进的合成
     * @param timeInSeconds - 需要快进/快退的时间长度（秒），可正可负
     */
    MarsPlayer.prototype.forwardCompositionTime = function (composition, timeInSeconds) {
        if (timeInSeconds) {
            this.forwardingTime = true;
            composition.forwardTime(timeInSeconds);
            this.forwardingTime = false;
        }
    };
    /**
     * 清空 canvas 的画面
     * @param immediate - 如果立即清理，当前画面将会消失，如果 player 还有合成在渲染，可能出现闪烁
     */
    MarsPlayer.prototype.clearCanvas = function (immediate) {
        if (immediate) {
            this.renderer.renderRenderFrame(this.clearPipeline);
        }
        else {
            this.forceRenderNextFrame = true;
        }
    };
    /**
     * @internal
     * @deprecated since 2.0.0
     * @param id
     * @param options
     */
    MarsPlayer.prototype.destroyItem = function (id, options) {
    };
    /**
     * 设置 Canvas 的背景图片用于降级
     * @internal
     * @deprecated since 2.0.0
     * @param url
     * @param container - 在 player 被销毁的时候，会使用这个 container 降级
     */
    MarsPlayer.prototype.useDowngradeImage = function (url, container) {
        var _a, _b;
        console.warn('The useDowngradeImage function is deprecated. Do downgrade logic in you biz code.');
        var style = ((_b = (_a = this.container) !== null && _a !== void 0 ? _a : container) !== null && _b !== void 0 ? _b : {}).style;
        if (style) {
            style.backgroundImage = "url(".concat(url, ")");
            style.backgroundRepeat = 'no-repeat';
            style.backgroundSize = 'cover';
            style.backgroundPosition = 'center';
        }
    };
    /**
     * 销毁播放器
     * @since 2.0.0
     * @param keepCanvas - 是否保留 canvas 画面，默认不保留，canvas 不能再被使用
     */
    MarsPlayer.prototype.dispose = function (keepCanvas) {
        var _a, _b;
        if (this.disposed) {
            return;
        }
        playerMap.delete(this.canvas);
        this.pause();
        (_a = this.ticker) === null || _a === void 0 ? void 0 : _a.stop();
        (_b = this.assetManager) === null || _b === void 0 ? void 0 : _b.dispose();
        this.compositions.forEach(function (comp) { return comp.dispose(); });
        this.compositions.length = 0;
        this.clearPipeline.dispose();
        this.renderer.context.removeLostHandler({ lost: this.lost });
        this.renderer.context.removeRestoreHandler({ restore: this.restore });
        this.event.dispose();
        this.renderer.dispose(!keepCanvas);
        broadcastPlayerEvent(this, false);
        if (this.canvas instanceof HTMLCanvasElement &&
            !keepCanvas &&
            this.renderer.context) {
            // canvas will become a cry emoji in Android if still in dom
            if (this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
            }
            this.canvas.remove();
        }
        this.tick = throwDestroyedError;
        this.resize = throwDestroyedError;
        this.loadScene = throwDestroyedErrorPromise;
        this.play = throwDestroyedErrorPromise;
        this.resume = throwDestroyedErrorPromise;
        this.disposed = true;
    };
    /**
     * @internal
     * @deprecated since 2.0.0 - use `dispose` instead
     */
    MarsPlayer.prototype.destroy = function (keepCanvas) {
        console.warn('The destroy function is deprecated. Use dispose instead.');
        this.dispose(keepCanvas);
    };
    MarsPlayer.prototype.renderFrame = function (opts) {
        var _this = this;
        this.compositions.forEach(function (comp) { return _this.forwardCompositionTime(comp, opts.currentTime); });
        this.doTick(0, true);
        if (opts.pauseOnFirstFrame) {
            this.pause();
        }
        else {
            this.resume().catch(console.error);
        }
    };
    MarsPlayer.prototype.offloadTexture = function () {
        this.compositions.forEach(function (comp) { return comp.offloadTexture(); });
    };
    MarsPlayer.prototype.getTargetSize = function (parentEle) {
        assertContainer(parentEle);
        var displayAspect = this.displayAspect;
        var targetWidth;
        var targetHeight;
        if (displayAspect) {
            var parentAspect = parentEle.clientWidth / parentEle.clientHeight;
            if (parentAspect > displayAspect) {
                targetHeight = parentEle.clientHeight * this.displayScale;
                targetWidth = targetHeight * displayAspect;
            }
            else {
                targetWidth = parentEle.clientWidth * this.displayScale;
                targetHeight = targetWidth / displayAspect;
            }
        }
        else {
            targetWidth = parentEle.clientWidth;
            targetHeight = parentEle.clientHeight;
        }
        var ratio = this.pixelRatio;
        var containerWidth = targetWidth;
        var containerHeight = targetHeight;
        targetWidth = Math.round(targetWidth * ratio);
        targetHeight = Math.round(targetHeight * ratio);
        if (targetHeight < 1 || targetHeight < 1) {
            if (this.offscreenMode) {
                targetWidth = targetHeight = containerWidth = containerHeight = 1;
            }
            else {
                throw Error("Invalid container size ".concat(targetWidth, "x").concat(targetHeight, ", see ").concat(HELP_LINK['Invalid container size']));
            }
        }
        return [containerWidth, containerHeight, targetWidth, targetHeight];
    };
    return MarsPlayer;
}());
/**
 * 禁止/允许创建新的播放器，已创建的不受影响
 * @param disable - 是否禁止
 */
function disableAllPlayer(disable) {
    enableDebugType = !!disable;
}
/**
 * 判断指定的 canvas 是否有播放器正在使用
 * @param canvas - 指定的 canvas
 * @returns
 */
function isCanvasUsedByPlayer(canvas) {
    return playerMap.has(canvas);
}
/**
 * 获取 canvas 对应的播放器
 * @param canvas - 指定的 canvas
 * @returns
 */
function getPlayerByCanvas(canvas) {
    return playerMap.get(canvas);
}
/**
 * 获取使用中的播放器
 * @returns
 */
function getActivePlayers() {
    return Array.from(playerMap.values());
}
/**
 * 播放器在实例化、销毁（`dispose`）时分别触发插件的 `onPlayerCreated`、`onPlayerDestroy` 回调
 * @param player - 播放器
 * @param isCreate - 是否处于实例化时
 */
function broadcastPlayerEvent(player, isCreate) {
    Object.values(pluginLoaderMap).forEach(function (ctrl) {
        var func = isCreate ? ctrl.onPlayerCreated : ctrl.onPlayerDestroy;
        func === null || func === void 0 ? void 0 : func(player);
    });
}
/**
 * 同时允许的播放器数量超过 1 时打印错误
 */
function assertNoConcurrentPlayers() {
    var e_1, _a;
    var runningPlayers = [];
    try {
        for (var _b = __values$1(playerMap.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var player_1 = _c.value;
            if (!player_1.paused) {
                runningPlayers.push(player_1);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (runningPlayers.length > 1) {
        console.error("Current running player count: ".concat(runningPlayers.length, ", see ").concat(HELP_LINK['Current running player count']), runningPlayers);
    }
}
/**
 * 创建播放器传入的容器不是 `HTMLElement` 时抛出错误
 * @param container
 */
function assertContainer(container) {
    if (!(container instanceof HTMLElement)) {
        throw new Error("Container is not an HTMLElement, see ".concat(HELP_LINK['Container is not an HTMLElement']));
    }
}
var destroyedErrorMessage = "Never use destroyed player again, see ".concat(HELP_LINK['Never use destroyed player again']);
function throwDestroyedError() {
    throw new Error(destroyedErrorMessage);
}
function throwDestroyedErrorPromise() {
    return Promise.reject(destroyedErrorMessage);
}

Texture.create = function (props) {
    return new GLTexture(props);
};
Texture.createWithData = function (data, options) {
    if (data === void 0) { data = imageDataFromColor('#fff'); }
    if (options === void 0) { options = {}; }
    var _a = options, _b = _a.type, type = _b === void 0 ? glContext.UNSIGNED_BYTE : _b, _c = _a.format, format = _c === void 0 ? glContext.RGBA : _c, internalFormat = _a.internalFormat, _d = _a.wrapS, wrapS = _d === void 0 ? glContext.MIRRORED_REPEAT : _d, _e = _a.wrapT, wrapT = _e === void 0 ? glContext.MIRRORED_REPEAT : _e, _f = _a.minFilter, minFilter = _f === void 0 ? glContext.NEAREST : _f, _g = _a.magFilter, magFilter = _g === void 0 ? glContext.NEAREST : _g;
    var tex = new GLTexture({
        data: data,
        type: type,
        sourceType: exports.TextureSourceType.data,
        format: format,
        internalFormat: internalFormat || format,
        wrapS: wrapS,
        wrapT: wrapT,
        minFilter: minFilter,
        magFilter: magFilter,
    });
    return tex;
};
MaterialDataBlock.create = function (props) {
    return new GLMaterialDataBlock(props);
};
Material.create = function (props) {
    return new GLMaterial(props);
};
Geometry.create = function (props) {
    return new GLGeometry(props);
};
Mesh.create = function (props) {
    return new GLMesh(props);
};
RenderBuffer.create = function (props) {
    return new GLRenderBuffer(props);
};
FrameBuffer.create = function (props, renderer) {
    return new GLFrameBuffer(props, renderer);
    // FrameBuffer.create = ()=>{
    //   return new GLFrameBuffer();
};
Renderer.create = function (canvas, framework, renderOptions) {
    return new GLRenderer(canvas, framework, renderOptions);
};
Engine.create = function () {
    return new GLEngine();
};
var version = "2.1.0-beta.0";
console.info('[Mars Player] version: ' + "2.1.0-beta.0");

exports.AbstractPlugin = AbstractPlugin;
exports.AssetManager = AssetManager;
exports.BYTES_TYPE_MAP = BYTES_TYPE_MAP;
exports.BezierSegments = BezierSegments;
exports.CLICK_BEHAVIOR_DESTROY_PARTICLE = CLICK_BEHAVIOR_DESTROY_PARTICLE;
exports.COMPRESSED_TEXTURE = COMPRESSED_TEXTURE;
exports.COPY_FRAGMENT_SHADER = COPY_FRAGMENT_SHADER;
exports.COPY_MESH_SHADER_ID = COPY_MESH_SHADER_ID;
exports.COPY_VERTEX_SHADER = COPY_VERTEX_SHADER;
exports.CalculateGroup = CalculateGroup;
exports.CalculateItem = CalculateItem;
exports.CalculateLoader = CalculateLoader;
exports.CalculateVFXItem = CalculateVFXItem;
exports.Camera = Camera;
exports.CameraController = CameraController;
exports.CameraVFXItem = CameraVFXItem;
exports.CameraVFXItemLoader = CameraVFXItemLoader;
exports.Composition = Composition;
exports.CurveValue = CurveValue;
exports.DEG2RAD = DEG2RAD;
exports.Downloader = Downloader;
exports.EVENT_TYPE_CLICK = EVENT_TYPE_CLICK;
exports.EVENT_TYPE_TOUCH_END = EVENT_TYPE_TOUCH_END;
exports.EVENT_TYPE_TOUCH_MOVE = EVENT_TYPE_TOUCH_MOVE;
exports.EVENT_TYPE_TOUCH_START = EVENT_TYPE_TOUCH_START;
exports.Engine = Engine;
exports.EventSystem = EventSystem;
exports.FILTER_NAME_NONE = FILTER_NAME_NONE;
exports.FilterSpriteVFXItem = FilterSpriteVFXItem;
exports.Float16ArrayWrapper = Float16ArrayWrapper;
exports.FrameBuffer = FrameBuffer;
exports.GPUCapability = GPUCapability;
exports.Geometry = Geometry;
exports.GradientValue = GradientValue;
exports.HELP_LINK = HELP_LINK$1;
exports.InteractBehavior = InteractBehavior$1;
exports.InteractItem = InteractItem;
exports.InteractLoader = InteractLoader;
exports.InteractMesh = InteractMesh;
exports.InteractVFXItem = InteractVFXItem;
exports.KTXTexture = KTXTexture;
exports.LineSegments = LineSegments;
exports.LinearValue = LinearValue;
exports.MARS_COPY_MESH_NAME = MARS_COPY_MESH_NAME;
exports.MarsPlayer = MarsPlayer;
exports.Material = Material;
exports.MaterialDataBlock = MaterialDataBlock;
exports.Mesh = Mesh;
exports.NumberEpsilon = NumberEpsilon;
exports.PLAYER_OPTIONS_ENV_EDITOR = PLAYER_OPTIONS_ENV_EDITOR;
exports.ParticleLoader = ParticleLoader;
exports.ParticleMesh = ParticleMesh;
exports.ParticleSystem = ParticleSystem;
exports.ParticleVFXItem = ParticleVFXItem;
exports.PassTextureCache = PassTextureCache;
exports.PathSegments = PathSegments;
exports.PluginSystem = PluginSystem;
exports.QCanvasViewer = QCanvasViewer;
exports.QText = QText;
exports.RENDER_PASS_NAME_PREFIX = RENDER_PASS_NAME_PREFIX;
exports.RENDER_PREFER_LOOKUP_TEXTURE = RENDER_PREFER_LOOKUP_TEXTURE;
exports.RUNTIME_ENV = RUNTIME_ENV;
exports.RandomSetValue = RandomSetValue;
exports.RandomValue = RandomValue;
exports.RandomVectorValue = RandomVectorValue;
exports.RenderBuffer = RenderBuffer;
exports.RenderFrame = RenderFrame;
exports.RenderPass = RenderPass;
exports.RenderPassPriorityNormal = RenderPassPriorityNormal;
exports.RenderPassPriorityPostprocess = RenderPassPriorityPostprocess;
exports.RenderPassPriorityPrepare = RenderPassPriorityPrepare;
exports.RenderTargetHandle = RenderTargetHandle;
exports.Renderer = Renderer;
exports.SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_0 = SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_0;
exports.SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_SIZE_0 = SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_SIZE_0;
exports.SEMANTIC_PRE_COLOR_ATTACHMENT_0 = SEMANTIC_PRE_COLOR_ATTACHMENT_0;
exports.SEMANTIC_PRE_COLOR_ATTACHMENT_SIZE_0 = SEMANTIC_PRE_COLOR_ATTACHMENT_SIZE_0;
exports.SPRITE_VERTEX_STRIDE = SPRITE_VERTEX_STRIDE;
exports.SemanticMap = SemanticMap;
exports.Shader = Shader;
exports.SpriteItem = SpriteItem;
exports.SpriteLoader = SpriteLoader;
exports.SpriteMesh = SpriteMesh;
exports.SpriteVFXItem = SpriteVFXItem;
exports.StaticValue = StaticValue;
exports.TEMPLATE_USE_OFFSCREEN_CANVAS = TEMPLATE_USE_OFFSCREEN_CANVAS;
exports.Texture = Texture;
exports.TextureFactory = TextureFactory;
exports.Transform = Transform;
exports.Tree = Tree;
exports.TreeVFXItem = TreeVFXItem;
exports.VFXItem = VFXItem;
exports.VFXItemManager = VFXItemManager;
exports.VFX_ITEM_TYPE_TREE = VFX_ITEM_TYPE_TREE;
exports.ValueGetter = ValueGetter;
exports.addItem = addItem;
exports.addItemWithOrder = addItemWithOrder;
exports.alphaFrameFrag = alphaFrameFrag;
exports.alphaMaskFrag = alphaMaskFrag;
exports.assertExist = assertExist;
exports.asserts = asserts;
exports.blend = blend;
exports.bloomMixVert = bloomMixVert;
exports.bloomThresholdVert = bloomThresholdVert;
exports.calculateTranslation = calculateTranslation;
exports.cameraMoveFrag = cameraMove_frag;
exports.cameraMoveVert = cameraMoveVert;
exports.clamp = clamp$1;
exports.colorStopsFromGradient = colorStopsFromGradient;
exports.colorToArr = colorToArr$1;
exports.combineImageTemplate = combineImageTemplate;
exports.combineImageTemplate1 = combineImageTemplate1;
exports.combineImageTemplate1Async = combineImageTemplate1Async;
exports.combineImageTemplate2 = combineImageTemplate2;
exports.combineImageTemplate2Async = combineImageTemplate2Async;
exports.combineImageTemplateAsync = combineImageTemplateAsync;
exports.compatibleFrag = compatible_frag;
exports.compatibleVert = compatible_vert;
exports.convertParticleOrigin2Anchor = convertParticleOrigin2Anchor;
exports.copyFrag = copyFrag;
exports.createCopyShader = createCopyShader;
exports.createFilter = createFilter;
exports.createFilterShaders = createFilterShaders;
exports.createGLContext = createGLContext;
exports.createKeyFrameMeta = createKeyFrameMeta;
exports.createShaderWithMarcos = createShaderWithMarcos;
exports.createVFXItem = createVFXItem;
exports.createValueGetter = createValueGetter;
exports.deepClone = deepClone;
exports.defaultPlugins = defaultPlugins;
exports.delayFrag = delayFrag;
exports.deserializeMipmapTexture = deserializeMipmapTexture;
exports.disableAllPlayer = disableAllPlayer;
exports.distortionFrag = distortionFrag;
exports.distortionVert = distortionVert;
exports.dotInTriangle = dotInTriangle;
exports.enlargeBuffer = enlargeBuffer;
exports.ensureVec3 = ensureVec3;
exports.findPreviousRenderPass = findPreviousRenderPass;
exports.generateEmptyTypedArray = generateEmptyTypedArray;
exports.generateHalfFloatTexture = generateHalfFloatTexture;
exports.getActivePlayers = getActivePlayers;
exports.getBackgroundImage = getBackgroundImage;
exports.getColorFromGradientStops = getColorFromGradientStops;
exports.getComposition = getComposition;
exports.getCompositionByName = getCompositionByName;
exports.getConfig = getConfig;
exports.getDefaultTemplateCanvasPool = getDefaultTemplateCanvasPool;
exports.getDefaultTextureFactory = getDefaultTextureFactory;
exports.getImageItemRenderInfo = getImageItemRenderInfo;
exports.getKTXTextureOptions = getKTXTextureOptions;
exports.getKeyFrameMetaByRawValue = getKeyFrameMetaByRawValue;
exports.getMat4TR = getMat4TR;
exports.getMat4TRS = getMat4TRS;
exports.getParticleMeshShader = getParticleMeshShader;
exports.getPixelRatio = getPixelRatio;
exports.getPlayerByCanvas = getPlayerByCanvas;
exports.getPreMultiAlpha = getPreMultiAlpha;
exports.getStandardComposition = getStandardComposition;
exports.getStandardImage = getStandardImage;
exports.getStandardItem = getStandardItem;
exports.getStandardJSON = getStandardJSON;
exports.getTextureSize = getTextureSize;
exports.glContext = glContext;
exports.gpuTimer = gpuTimer;
exports.imageDataFromColor = imageDataFromColor;
exports.imageDataFromGradient = imageDataFromGradient;
exports.integrate = integrate;
exports.interpolateColor = interpolateColor;
exports.intersectRayBox = intersectRayBox;
exports.intersectRaySphere = intersectRaySphere;
exports.intersectRayTriangle = intersectRayTriangle;
exports.isAndroid = isAndroid;
exports.isArray = isArray;
exports.isCanvasUsedByPlayer = isCanvasUsedByPlayer;
exports.isFunction = isFunction;
exports.isIOS = isIOS;
exports.isObject = isObject;
exports.isSimulatorCellPhone = isSimulatorCellPhone;
exports.isString = isString;
exports.isUniformStruct = isUniformStruct;
exports.isUniformStructArray = isUniformStructArray;
exports.isWebGL2 = isWebGL2;
exports.isZeroVec = isZeroVec;
exports.itemDefine = item_define;
exports.itemFrag = itemFrag;
exports.itemFrameFrag = itemFrameFrag;
exports.itemVert = itemVert;
exports.loadBinary = loadBinary;
exports.loadBlob = loadBlob;
exports.loadImage = loadImage;
exports.loadVideo = loadVideo;
exports.loadWebPOptional = loadWebPOptional;
exports.mat3FromQuat = mat3FromQuat;
exports.mat3FromRotation = mat3FromRotation;
exports.mat3FromRotationZ = mat3FromRotationZ;
exports.mat4Clone = mat4Clone;
exports.mat4Determinate = mat4Determinate;
exports.mat4create = mat4create;
exports.mat4fromRotationTranslationScale = mat4fromRotationTranslationScale;
exports.mat4invert = mat4invert;
exports.mat4multiply = mat4multiply;
exports.mat4perspective = mat4perspective;
exports.modifyMaxKeyframeShader = modifyMaxKeyframeShader;
exports.nearestPowerOfTwo = nearestPowerOfTwo;
exports.noop = noop;
exports.parsePercent = parsePercent$1;
exports.particleFrag = particleFrag;
exports.particleVert = particleVert;
exports.pluginLoaderMap = pluginLoaderMap;
exports.quatFromRotation = quatFromRotation;
exports.quatStar = quatStar;
exports.random = random;
exports.registerFilter = registerFilter;
exports.registerFilters = registerFilters;
exports.registerPlugin = registerPlugin;
exports.removeItem = removeItem;
exports.requestAsync = requestAsync;
exports.rotateByQuat = rotateByQuat;
exports.rotationFromMat3 = rotationFromMat3;
exports.setBlendMode = setBlendMode;
exports.setConfig = setConfig;
exports.setDefaultTextureFactory = setDefaultTextureFactory;
exports.setMaskMode = setMaskMode;
exports.setMaxSpriteMeshItemCount = setMaxSpriteMeshItemCount;
exports.setRayFromCamera = setRayFromCamera;
exports.setSideMode = setSideMode;
exports.setSpriteMeshMaxFragmentTextures = setSpriteMeshMaxFragmentTextures;
exports.setSpriteMeshMaxItemCountByGPU = setSpriteMeshMaxItemCountByGPU;
exports.spec = index;
exports.spriteMeshShaderFromFilter = spriteMeshShaderFromFilter;
exports.spriteMeshShaderFromRenderInfo = spriteMeshShaderFromRenderInfo;
exports.spriteMeshShaderIdFromRenderInfo = spriteMeshShaderIdFromRenderInfo;
exports.throwDestroyedError = throwDestroyedError$1;
exports.trailVert = trailVert;
exports.translatePoint = translatePoint;
exports.trianglesFromRect = trianglesFromRect;
exports.unregisterPlugin = unregisterPlugin;
exports.valIfUndefined = valIfUndefined;
exports.value = value;
exports.valueDefine = valueDefine;
exports.vec3Cross = vec3Cross;
exports.vec3MulMat3 = vec3MulMat3;
exports.vec3MulMat4 = vec3MulMat4;
exports.vec3RotateByMat4 = vec3RotateByMat4;
exports.vecAdd = vecAdd;
exports.vecAssign = vecAssign;
exports.vecDot = vecDot;
exports.vecFill = vecFill;
exports.vecMinus = vecMinus;
exports.vecMulCombine = vecMulCombine;
exports.vecMulScalar = vecMulScalar;
exports.vecNormalize = vecNormalize;
exports.vecSquareDistance = vecSquareDistance;
exports.version = version;
//# sourceMappingURL=index.js.map
